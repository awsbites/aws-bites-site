WEBVTT

1
00:00:00.000 --> 00:00:04.400
Are you looking for an easy way to set up a relational database with best practices,

2
00:00:04.400 --> 00:00:09.280
resilience and disaster recovery in mind? Are you maybe looking for something reliable but also

3
00:00:09.280 --> 00:00:14.080
cheap and easy to maintain? Today we're going to try and answer the question, does such a thing

4
00:00:14.080 --> 00:00:19.120
even exist? The best hope for an AWS solution to this challenge is Amazon Aurora. We're going to

5
00:00:19.120 --> 00:00:24.160
dive into Aurora, talk about its unique capabilities, intricacies and of course, trade-offs.

6
00:00:24.160 --> 00:00:27.360
I'm Eoin, I'm joined by Luciano and this is AWS Bites.

7
00:00:30.000 --> 00:00:40.000
AWS Bites is brought to you by fourTheorem. If you need someone to work with you to build the

8
00:00:40.000 --> 00:00:46.080
best designed, highly available database on AWS, give us a shout. Check out fourtheorem.com or contact

9
00:00:46.080 --> 00:00:50.000
us directly using the links in the show notes. Luciano, before we dive into Aurora,

10
00:00:50.000 --> 00:00:54.800
what's the use case? Maybe let's try and imagine a scenario where Aurora might be a good fit.

11
00:00:59.760 --> 00:01:04.960
Yeah, I think it's always good to try to put a frame to the conversation by defining a good use case. Here we are talking about enterprise applications, so not really like hobbyist type

12
00:01:04.960 --> 00:01:10.320
of databases. So that's what it means. It means basically you might have hundreds or even thousands

13
00:01:10.320 --> 00:01:16.960
of data users connected to the database. Volume of transactions that can vary, they can be

14
00:01:16.960 --> 00:01:21.040
relatively low, but they can grow as needed because as a business, you might have your own

15
00:01:21.040 --> 00:01:25.120
spikes and you need to figure out how to manage all of that. Generally speaking, we are talking

16
00:01:25.120 --> 00:01:29.680
about really important business data, so something we can consider critical. So something you really

17
00:01:29.680 --> 00:01:36.240
don't want to lose. And we are expecting low RPO and RTO. So RPO probably in terms of minutes,

18
00:01:36.240 --> 00:01:40.720
RTO in terms of maybe one hour. And of course, something that needs to be replicated across

19
00:01:40.720 --> 00:01:46.480
availability zones and possibly have regional failure. So this is a very common use case,

20
00:01:46.480 --> 00:01:51.520
but it still considers something really, really hard to achieve. So somewhat of a pain point if

21
00:01:51.520 --> 00:01:56.720
you find yourself having to set up this kind of databases. So we are wondering today if there is

22
00:01:56.800 --> 00:02:02.720
a way that can make us happy and make all these things easy for you and give us low overhead

23
00:02:02.720 --> 00:02:07.680
managed database, high availability, multi-region, fast recovery, something that is relatively secure,

24
00:02:08.240 --> 00:02:13.680
also as cheap as possible. That's always something nice to have and somewhat developer-friendly.

25
00:02:13.680 --> 00:02:19.520
So is this something we can achieve on AWS? If yes, what kind of services we should be looking at

26
00:02:19.520 --> 00:02:24.080
and try to analyze and decide if they really fit our description. And the first service that comes

27
00:02:24.080 --> 00:02:29.680
to mind is Aurora. So what is Aurora? So if you're looking for a relational database on AWS,

28
00:02:29.680 --> 00:02:34.240
you have a few options. You're probably aware of RDS, which is a service that allows you to

29
00:02:34.240 --> 00:02:39.680
create relational databases and supports a big number of databases, including SQL Server,

30
00:02:39.680 --> 00:02:44.960
Oracle, but also open source ones like Postgres, MariaDB, MySQL. And the idea is that they give

31
00:02:44.960 --> 00:02:49.920
you a service that is somewhat managed and it somehow removes some of the pain points of having

32
00:02:49.920 --> 00:02:55.200
to manage databases, but it's still running on EC2 instances. So it does abstract some things,

33
00:02:55.200 --> 00:02:58.960
but there is still a bit of the pain point of having to manage servers.

34
00:02:58.960 --> 00:03:04.000
So with RDS, you also have another category of databases, which is the one called Aurora.

35
00:03:04.000 --> 00:03:09.920
And Aurora promises to deliver MySQL and Postgres compatibility with performance three times faster

36
00:03:09.920 --> 00:03:15.680
than the regular one that you find in the regular MySQL and Postgres RDS. On top of that, Aurora has

37
00:03:15.680 --> 00:03:20.560
some different characteristics that are only possible because effectively AWS reinvented this

38
00:03:20.560 --> 00:03:24.800
kind of databases. It's a service that they somewhat recreated, provided the compatibility

39
00:03:24.800 --> 00:03:30.080
with the protocols of MySQL and Postgres. So they figured out clever ways to optimize the service

40
00:03:30.080 --> 00:03:36.000
more than what you would get with the open source alternatives. So let's try to dive into the

41
00:03:36.000 --> 00:03:40.080
details. Maybe we should talk first about the storage, because I think that's the first thing

42
00:03:40.080 --> 00:03:45.760
that comes to mind when we try to think why Aurora is different from just a simple MySQL

43
00:03:45.760 --> 00:03:50.640
or Postgres.

44
00:03:50.640 --> 00:03:56.000
Yeah, definitely the most important thing to know about Aurora is that its storage is different to RDS and to most other databases out there. You mentioned three times faster

45
00:03:56.000 --> 00:04:00.720
performance in some benchmarks. That ultimately comes down from the way they have designed Aurora

46
00:04:00.720 --> 00:04:06.320
storage. I mean, the engines themselves are using the open source MySQL and Postgres engines on top

47
00:04:06.400 --> 00:04:10.400
of this new storage layer, but because of the way it's been architected, they've been able to reduce

48
00:04:10.400 --> 00:04:15.280
the number of writes that those database engines have to do and achieve that better performance.

49
00:04:15.280 --> 00:04:19.920
Normally when you configure a database on a server, you configure the database running as

50
00:04:19.920 --> 00:04:25.600
a process or a set of processes, and then you have the storage, which could be attached in some way.

51
00:04:25.600 --> 00:04:30.000
With Aurora, it's a bit different in that the storage is completely separate from the compute

52
00:04:30.000 --> 00:04:35.040
layer and it uses its own magic to give you that better performance, as well as more durability

53
00:04:35.040 --> 00:04:39.040
and faster recovery, which if you're an enterprise, all of those things sound like a dream.

54
00:04:39.760 --> 00:04:44.080
Now you can think of Aurora storage, I think, as an intelligent kind of EBS volume layer

55
00:04:44.080 --> 00:04:49.040
that is database transaction aware. So all of the data you store is automatically stored in six

56
00:04:49.040 --> 00:04:54.880
copies across three availability zones by default. So that automatically gives you great resilience.

57
00:04:55.520 --> 00:05:00.080
And then you have asynchronous replication processes that happen outside of the database

58
00:05:00.080 --> 00:05:04.560
compute. So normally when you have other databases, you have to configure the engines

59
00:05:04.560 --> 00:05:09.280
themselves to do the replication between the compute notes. With Aurora storage, it happens

60
00:05:09.280 --> 00:05:14.240
at the storage layer, so you don't have that compute level replication. So when your data

61
00:05:14.240 --> 00:05:18.080
is replicated, it doesn't actually affect the instance performance, which is a really good thing.

62
00:05:18.880 --> 00:05:24.560
And then because it's being written all the time, asynchronously, recovery time is really fast

63
00:05:24.560 --> 00:05:29.600
because the data is not affected by instances going down. The data is already replicated by

64
00:05:29.600 --> 00:05:33.440
design. And you can then add new instances to a database cluster that give you horizontal

65
00:05:33.440 --> 00:05:39.280
scalability using that existing storage layer. The other thing to know about Aurora storage is

66
00:05:39.280 --> 00:05:42.800
that it scales automatically, so you don't have to provision storage capacity upfront.

67
00:05:42.800 --> 00:05:49.360
It just grows automatically in increments of 10 gigabytes up to a maximum of 128 terabytes.

68
00:05:49.360 --> 00:05:53.040
So let's try and understand all this a bit better. And we might take a look at, I suppose,

69
00:05:53.040 --> 00:05:58.640
a few Aurora concepts and constructs and how you might architect a database based on Aurora.

70
00:05:58.800 --> 00:06:02.480
Luciano, would you like to take us through some of the terminology and concepts in Aurora?

71
00:06:02.480 --> 00:06:06.560
Yeah, the first one that comes to mind is probably the concept of a cluster.

72
00:06:06.560 --> 00:06:12.080
And this is something that is already different from a more traditional RDS database. So the first thing you need to create

73
00:06:12.080 --> 00:06:16.880
is this idea that your database exists in a cluster, you need to create this cluster.

74
00:06:16.880 --> 00:06:23.360
And this represents the storage layer. So even if you don't have any database, meaning the compute

75
00:06:23.360 --> 00:06:28.960
part of a database in this cluster, the storage exists as a kind of baseline. And of course,

76
00:06:28.960 --> 00:06:33.040
you'll want at some point to add at least one instance to make it useful because just the

77
00:06:33.040 --> 00:06:37.680
storage alone is not going to allow you to do any query or any actual operation. It's just there to

78
00:06:37.680 --> 00:06:43.680
keep your data safe. So every cluster can have one writer instance that allows you to effectively

79
00:06:43.680 --> 00:06:48.320
under-read and write requests, but you cannot add more than one writer. So you can have only one

80
00:06:48.880 --> 00:06:54.320
writer per cluster. So that means that you can only scale writes vertically by using bigger

81
00:06:54.320 --> 00:07:00.000
write instance if you end up having necessity for a bigger write throughput. You can add though

82
00:07:00.000 --> 00:07:04.320
up to 15 reader instances. So you can definitely scale horizontally the number of reader instances.

83
00:07:04.320 --> 00:07:08.720
So we can also call them read replica if that term is a little bit more familiar to you. And that's

84
00:07:08.720 --> 00:07:12.480
something that allows you to handle read scalability. So you can easily spin up more

85
00:07:12.480 --> 00:07:17.200
instances if you see that you need more throughput in terms of read. There are ways to do auto

86
00:07:17.200 --> 00:07:21.760
scaling. So you can set up auto scaling policies, and this allows you to basically look for things

87
00:07:21.760 --> 00:07:27.120
like CPU utilization or number of connections to provision new reader nodes as you see that

88
00:07:27.120 --> 00:07:31.360
your traffic increases. And of course, you can also scale it down if you see that that traffic

89
00:07:31.360 --> 00:07:35.920
decreases. So each instance in the cluster will have its own endpoint. So this is the idea that

90
00:07:35.920 --> 00:07:41.040
you need to have a way to connect to the specific instances. So every instance has its own kind of

91
00:07:41.040 --> 00:07:45.600
address that allows you to connect to it. But there is also a concept of a cluster

92
00:07:45.600 --> 00:07:51.760
read and write endpoints. And these endpoints are kind of the preferred way to connect to

93
00:07:51.760 --> 00:07:57.600
a database because they will automatically do all the routing for you, figuring out which instance

94
00:07:57.600 --> 00:08:01.680
is the most appropriate to handle that particular request. And this is important because, for

95
00:08:01.680 --> 00:08:07.600
instance, as you scale up and down, or maybe if there is some failover in your cluster, that layer,

96
00:08:07.600 --> 00:08:13.120
that kind of global endpoint will know exactly what to do to make sure that your request gets

97
00:08:13.120 --> 00:08:17.840
answered correctly. If you manage your own connection directly to the specific instances,

98
00:08:17.840 --> 00:08:22.880
then doing all of that stuff is on you. And of course, that's not always fun to do. It can lead

99
00:08:22.880 --> 00:08:26.960
to all sorts of problems. So try to avoid it unless you really know what you're doing.

100
00:08:26.960 --> 00:08:32.720
So on the topic of failover recovery, if your writer fails, because remember, you only have

101
00:08:32.720 --> 00:08:36.640
one writer, so you might be wondering, okay, what happens if that writer fails? Of course,

102
00:08:36.640 --> 00:08:41.680
there is some kind of failover mechanism. Aurora will automatically promote one of your

103
00:08:41.920 --> 00:08:46.960
replicas to a writer. So this is all within a single region. We mentioned also that Aurora

104
00:08:46.960 --> 00:08:51.120
supports the concept of multi-region, which is something that seems really, really cool

105
00:08:51.120 --> 00:08:54.960
and promising. And if you ever tried to do a multi-region database, you know that it's

106
00:08:54.960 --> 00:08:59.280
extremely complicated to do it correctly. So maybe we should talk a little bit more about

107
00:08:59.280 --> 00:09:03.360
this particular characteristic of Aurora.

108
00:09:03.360 --> 00:09:08.000
When we get to talk about cost a little bit later in the episode, spoiler alert, Aurora is a little bit more expensive than the alternatives.

109
00:09:08.560 --> 00:09:13.520
And for that, you have to expect some extra value. And I think when it comes to replication,

110
00:09:13.520 --> 00:09:17.840
failover, all of these disaster recovery scenarios and scalability, that's really where you see the

111
00:09:17.840 --> 00:09:22.720
value. And multi-region is one of those things where you just get something that you can't

112
00:09:22.720 --> 00:09:27.920
really achieve easily with other databases. So let's talk about global databases. With Aurora,

113
00:09:27.920 --> 00:09:32.320
a global database is something that connects together clusters across multiple regions.

114
00:09:32.320 --> 00:09:38.720
So it's essentially a grouping of one or more regional Aurora clusters. And only one of those

115
00:09:38.720 --> 00:09:43.200
clusters can be the primary. And that's where the writer instance exists. Now, there is a thing

116
00:09:43.200 --> 00:09:49.680
called multi-master for MySQL only, but let's put that aside for the moment. If you're looking at a

117
00:09:49.680 --> 00:09:55.120
global database, you'll have one primary region and that's where the writer will exist. And a

118
00:09:55.120 --> 00:09:59.680
global database is really just an identifier that Aurora uses to replicate data from the primary

119
00:09:59.680 --> 00:10:05.600
cluster to read clusters in different regions. And because Aurora global databases are using

120
00:10:05.600 --> 00:10:09.920
Aurora storage, replication is very fast, typically less than a second. And this is

121
00:10:09.920 --> 00:10:15.440
with a database that can support up to 150,000 transactions per second. So when it comes to

122
00:10:15.440 --> 00:10:21.920
multi-region disaster recovery, if you've got a very low recovery point objective (RPO), this is

123
00:10:21.920 --> 00:10:26.240
a way to achieve it. It's really something that's very difficult to achieve without Aurora.

124
00:10:26.240 --> 00:10:31.840
Now, you can have up to six regions in a global database in total. And if we take the 15 read

125
00:10:31.840 --> 00:10:36.480
replicas supported per region mentioned already, this allows you to go to a pretty big scale with

126
00:10:36.480 --> 00:10:42.000
90 read replicas in your database in total. So then if you've got your multi-region database

127
00:10:42.000 --> 00:10:48.240
setup, you can use this for data locality. If you have some readers in some regions, which might be

128
00:10:48.240 --> 00:10:55.600
better to serve requests from users in a specific region, you can also use it for disaster recovery.

129
00:10:55.600 --> 00:11:00.960
And if you have your multi-region global database, you can trigger a failover from primary region to

130
00:11:00.960 --> 00:11:04.800
a secondary region. And this is really useful for enterprise use cases where you need to seriously

131
00:11:04.800 --> 00:11:10.640
reduce the risk of data loss and lower downtime as well. Now, global databases don't have global

132
00:11:10.640 --> 00:11:15.760
endpoints. So we mentioned about cluster endpoints, read and write endpoints per region. So you still

133
00:11:15.760 --> 00:11:19.680
need to use those regional cluster endpoints for your application. You need to decide which region

134
00:11:19.680 --> 00:11:24.960
you're targeting. You can use DNS of course, to manage that or ensure that the application is

135
00:11:24.960 --> 00:11:29.120
aware of the cluster typology and failover scenarios and can respond accordingly.

136
00:11:30.160 --> 00:11:33.520
But there's no such thing as a global endpoint that automatically does that for you at the moment.

137
00:11:34.400 --> 00:11:38.080
Interestingly, there is a thing called write forwarding in Aurora. So you can actually

138
00:11:38.080 --> 00:11:42.960
configure regional read endpoints to take write requests, and they'll just forward them to the

139
00:11:42.960 --> 00:11:48.240
write node for you, which is something that might be useful to you, especially in disaster recovery

140
00:11:48.240 --> 00:11:53.600
scenarios. Now, I think that's pretty much all the terminology and some of the primary benefits of

141
00:11:53.600 --> 00:11:59.040
Aurora, but something that makes the headlines quite frequently is Aurora serverless, sometimes

142
00:11:59.040 --> 00:12:04.240
for the good reasons, sometimes not so good. Luciano, can you take us through Aurora serverless

143
00:12:04.240 --> 00:12:09.200
and what it can offer people?

144
00:12:09.200 --> 00:12:13.520
Yeah, so what we've described so far is what we would call provision mode. So effectively you have to configure your instance sizes more or less similar to what you

145
00:12:13.520 --> 00:12:18.720
do with standard RDS. And the only difference is that you don't have to provision the storage.

146
00:12:18.720 --> 00:12:24.880
But as you say, there is also a serverless mode, and this is what is generally referred to as

147
00:12:24.880 --> 00:12:29.840
Aurora serverless. It gets a little bit confusing because there was originally a V1, which was,

148
00:12:29.840 --> 00:12:34.000
of course, just called Aurora serverless. Then they did a big rebranding changes and they call

149
00:12:34.000 --> 00:12:38.160
it Aurora serverless V2. We'll talk a little bit later about the differences between these two

150
00:12:38.160 --> 00:12:43.920
versions. But the point is, what is this concept of Aurora serverless? Is it something that it is

151
00:12:43.920 --> 00:12:48.560
somewhat easier to use because the terminology serverless generally is associated with something

152
00:12:49.280 --> 00:12:53.520
that you don't have to manage almost anything. So it's kind of an easier user experience.

153
00:12:53.520 --> 00:12:58.000
Or maybe something else, is it something that maybe looks like if you ever use services like

154
00:12:58.000 --> 00:13:04.320
Neon or PlanerScale or Supabase, are we talking about something like that? And my personal answer

155
00:13:04.320 --> 00:13:09.840
is probably no. It is quite different from products like Neon, PlanerScale or Supabase.

156
00:13:10.400 --> 00:13:16.480
And I think before we go into the details, maybe it's worth remembering what a serverless database

157
00:13:16.480 --> 00:13:20.320
look like, or at least trying to define it in some way. And of course, the first one that comes

158
00:13:20.320 --> 00:13:24.560
to mind when you try to think about a serverless database, of course, is DynamoDB in the context of

159
00:13:24.560 --> 00:13:30.560
AWS. And it's kind of the gold standard, if you want, for serverlessness in database world.

160
00:13:31.120 --> 00:13:36.160
And the idea is that it's a database that scales to zero by default. So you don't really have to

161
00:13:36.160 --> 00:13:43.280
even think about that. It can go up and down and you can also in terms of pricing, you can pick

162
00:13:43.280 --> 00:13:47.840
between provision and on demand. But when you pick the on demand approach, again, even the pricing

163
00:13:47.840 --> 00:13:54.160
model becomes more serverless. And you have almost a spontaneous creation of tables. You don't even

164
00:13:54.160 --> 00:13:58.800
have to think in terms of clusters or databases. You just create tables and they almost immediately

165
00:13:58.800 --> 00:14:03.520
appear. But what is the problem with DynamoDB? Why aren't we just using DynamoDB then? Because

166
00:14:03.520 --> 00:14:10.320
DynamoDB is a NoSQL database. It's not an RDBMS type of database. So when you need relations,

167
00:14:10.320 --> 00:14:16.160
DynamoDB gets much trickier to use to do all the things that you can do with a relational database.

168
00:14:16.160 --> 00:14:20.720
So services like Neon or PlanetScale are really cool because they try to give you that kind of

169
00:14:20.720 --> 00:14:25.600
experience where almost everything is managed for you, almost like with DynamoDB, but you get a fully

170
00:14:25.600 --> 00:14:30.000
fledged relational database that you can use straight away. Just connect to it and use it.

171
00:14:30.000 --> 00:14:34.800
The problem with those services is that generally they seem to be targeting more kind of software as

172
00:14:34.800 --> 00:14:40.000
a services or smaller startups, not as much as the enterprise, at least for what we have seen so far.

173
00:14:40.560 --> 00:14:45.120
While Aurora on the other end seems to be positioning themselves as the relational database

174
00:14:45.120 --> 00:14:49.840
product for kind of the serious enterprise that needs a certain number of features and needs

175
00:14:49.840 --> 00:14:54.720
something to be really, really reliable. And maybe cost is not always the first trade off that they

176
00:14:54.720 --> 00:15:01.200
look for. So what are we talking about here is more of a modern take on something like Oracle RAC

177
00:15:01.760 --> 00:15:07.680
and maybe a little bit cheaper, but the idea is that something runs natively in the cloud on AWS.

178
00:15:07.680 --> 00:15:12.720
What is Aurora Serverless at this point? Why did they give you all this appeal about DynamoDB and

179
00:15:12.720 --> 00:15:17.680
what we mean by serverless and why we think that Aurora Serverless is not really serverless as you

180
00:15:17.680 --> 00:15:22.880
might think? The first thing, okay, scales up and down to some degree it does that. The problem is

181
00:15:22.880 --> 00:15:29.040
it doesn't really scale to zero. There is a concept of ACU, which stands for Aurora Capacity Unit.

182
00:15:29.040 --> 00:15:35.920
And the idea is that one ACU is equal to two gigabytes of RAM, more or less. And the idea is

183
00:15:35.920 --> 00:15:41.760
that you cannot just scale to zero ACUs. There is a minimum and the minimum is 0.5, which means that

184
00:15:41.760 --> 00:15:46.800
even if you have a database that is totally idle, because maybe, I don't know, it's a dev deployment,

185
00:15:46.800 --> 00:15:51.200
you maybe are on a break because it's the weekend, nobody's really using that database.

186
00:15:51.200 --> 00:15:56.560
You are still paying for two days, 0.5 ACUs, at least for that particular deployment. And imagine

187
00:15:56.560 --> 00:16:01.280
if you have multiple development environments, maybe you try to segregate things by domain,

188
00:16:01.280 --> 00:16:07.040
you might have dozens of database laying around just doing nothing and costing you money. So in

189
00:16:07.040 --> 00:16:11.920
that sense, it's not really serverless as we might like it to be. So that means there is a minimum

190
00:16:11.920 --> 00:16:16.240
cost. And the other interesting thing is that there are still maintenance windows required.

191
00:16:16.240 --> 00:16:23.680
So you need to plan around those. So depending on what you do, you might need... eight ACUs are

192
00:16:23.680 --> 00:16:30.880
recommended for global cluster in the primary. So certain parts of your setup will require even more

193
00:16:31.280 --> 00:16:37.280
ACUs if you want to follow the recommended setup. And two ACUs are for performance insight,

194
00:16:37.280 --> 00:16:44.400
which is a tool that gives you query metrics. So it can be even more expensive as a baseline

195
00:16:44.400 --> 00:16:48.800
if you actually apply all the suggestions that you get from the documentation. And the funny thing is

196
00:16:48.800 --> 00:16:54.080
that we recently realized while we were using Aurora that there is the possibility to reboot

197
00:16:54.080 --> 00:16:58.400
the server. So we were seeing the server rebooting. So it's kind of funny to see that

198
00:16:58.400 --> 00:17:03.600
a serverless product, you actually see the server rebooting. So again, it doesn't really feel as

199
00:17:03.600 --> 00:17:08.640
serverless as you might like to think. So with all of that being said, there is a benefit in

200
00:17:08.640 --> 00:17:12.880
this capacity of Aurora serverless being able to scale up and down. And it's something that can be

201
00:17:12.880 --> 00:17:17.200
useful in some circumstances, especially for instance, when you have very variable traffic,

202
00:17:17.200 --> 00:17:21.520
it's something that can remove some of the headaches about planning, for instance,

203
00:17:21.520 --> 00:17:26.960
the capacity of your database. So in those cases, even if it's not really a serverless database,

204
00:17:26.960 --> 00:17:31.920
this product can be beneficial as opposed to just going for the traditional Aurora or

205
00:17:31.920 --> 00:17:37.360
RDS standard. But I mentioned that there are two versions, V1 and V2. Eoin, do you want to try to

206
00:17:37.360 --> 00:17:42.800
explain what is it all about?

207
00:17:42.800 --> 00:17:48.400
Yeah, V1 was around for a good few years. I'm not sure exactly when it was announced, but V2 now has been, it was in beta for a while, and I think it's been at least

208
00:17:48.400 --> 00:17:53.120
a year generally available. They announced it started this year that V1 is no longer going to

209
00:17:53.120 --> 00:17:57.520
be supported from the end of 2024. And this is quite disappointing for some people because

210
00:17:57.520 --> 00:18:01.840
version one actually did scale to zero. So that's something as you said, Luciano correctly, you

211
00:18:01.840 --> 00:18:07.280
can't do it with version two. But V2, when they announced it, they did add some big advantages.

212
00:18:07.280 --> 00:18:12.160
So scale up time is faster. With V1, this could be quite slow, could be like seconds or minutes.

213
00:18:12.160 --> 00:18:16.880
Now you can scale up in milliseconds, but the speed you scale up at actually depends on your

214
00:18:16.880 --> 00:18:21.600
baseline capacity. So the number of ACUs you're scaling from. So the more ACUs you have, the faster

215
00:18:21.600 --> 00:18:27.920
you'll scale up. In V1, it could take minutes and it only actually scaled in double increments.

216
00:18:27.920 --> 00:18:33.680
So you could go from two ACUs to four, then to eight, and then to 16. Now you can just scale by

217
00:18:33.680 --> 00:18:39.440
0.5 ACUs all the time. Version two now supports global databases, where version one did not,

218
00:18:39.440 --> 00:18:44.320
and version two supports read replicas where version two did not. So version one was really

219
00:18:44.320 --> 00:18:49.360
just a single instance database, so you couldn't really regard it as a serious production ready

220
00:18:49.360 --> 00:18:54.000
database for the enterprise. So I think now it's probably worthwhile thinking, OK,

221
00:18:54.000 --> 00:18:59.040
when should you consider Aurora Serverless version two instead of provisioned Aurora?

222
00:18:59.040 --> 00:19:03.360
And the primary difference is that scaling you mentioned. Aurora Serverless means you can scale

223
00:19:03.360 --> 00:19:08.240
vertically without having any failover. And that's really one of the sweet spots here. Because

224
00:19:08.240 --> 00:19:11.440
normally, if you've got a provisioned instance and you decide it isn't big enough for your needs

225
00:19:11.440 --> 00:19:16.640
anymore, you would have to add a larger instance size as a reader and then promote it to the

226
00:19:16.640 --> 00:19:22.160
writer and then deprovision the old one. And that takes time, and you might have outage time on the

227
00:19:22.160 --> 00:19:27.280
right instance while you do that. Otherwise, the management overhead between Aurora Serverless and

228
00:19:27.280 --> 00:19:31.440
provisioned Aurora isn't really that different. As he said, you still have maintenance windows,

229
00:19:31.440 --> 00:19:36.240
you can reboot the instance. It doesn't really seem like a serverless product. It has a serverless

230
00:19:36.240 --> 00:19:41.760
badge, but I think it's a little bit of a mask it's wearing, to be honest. It might be a good

231
00:19:41.840 --> 00:19:46.880
fit for your pre-production or development databases where you might have lots of idle time

232
00:19:46.880 --> 00:19:50.720
and then you just want to scale them up as you deploy and run test workloads. So that might be

233
00:19:50.720 --> 00:19:56.320
one of the cases where you can actually make use of the cost difference. Because generally,

234
00:19:56.320 --> 00:20:02.000
Aurora Serverless will cost you more if you're comparing gigabyte for gigabyte. And it will only

235
00:20:02.000 --> 00:20:06.560
really start becoming cheaper if you've got that really variable traffic pattern and you spend a

236
00:20:06.560 --> 00:20:11.120
lot of time scaling down from peak capacity. So we mentioned cost a few times. So let's go into

237
00:20:11.120 --> 00:20:17.200
cost a little bit. I've done some calculations on this. Maybe we can share the link to this cost

238
00:20:17.200 --> 00:20:22.640
calculator, the AWS pricing calculator in the show notes. And if you look at the cheapest possible

239
00:20:22.640 --> 00:20:28.960
serverless V2 instance, so 0.5 ACUs, you're talking about around $50 a month. Whereas the

240
00:20:28.960 --> 00:20:35.040
cheapest Aurora standard that I could find at least was just a little bit more expensive,

241
00:20:35.040 --> 00:20:41.280
closer to $60. But that was for a much bigger instance. So I think it was, I don't have it

242
00:20:41.280 --> 00:20:45.360
two hands right now, but I think it was eight or 16 gigabytes of RAM. So you're already getting

243
00:20:45.360 --> 00:20:49.920
far more compute and memory than you would for the serverless version. Now, if you compare that to

244
00:20:49.920 --> 00:20:54.640
the cheapest possible one you can get on RDS, I could pick one there that costs $15 a month.

245
00:20:55.360 --> 00:20:59.120
Of course, all of this, you have to try it and measure it yourself. There's no way of saying

246
00:20:59.120 --> 00:21:03.040
there's absolute price comparisons between all of these options. It depends on your storage,

247
00:21:03.040 --> 00:21:06.960
your traffic and everything. So you really just have to give it a go.

248
00:21:06.960 --> 00:21:14.800
If you were to look at an R6G large, this is a Graviton memory optimized instance, I think 10

249
00:21:14.800 --> 00:21:19.280
gigabytes. So that's kind of entry level when it comes to Aurora standard. You're looking at

250
00:21:19.280 --> 00:21:26.480
provisioned cost of over $200 a month. But if you wanted Aurora serverless as a primary in your

251
00:21:26.480 --> 00:21:30.720
cluster, you're going to need ACUs like you mentioned, that's going to cost you $400 a month.

252
00:21:31.360 --> 00:21:37.520
So if you're like a startup bootstrapped solopreneur, you might be looking at some

253
00:21:37.520 --> 00:21:40.400
of these costs thinking this isn't going to work for me. And you might be better off starting with

254
00:21:40.400 --> 00:21:45.520
something like neon or one of the other services. Or you could just say, okay, well, look, the

255
00:21:45.520 --> 00:21:49.280
database is a serious part of my infrastructure. I'm going to have to spend a serious amount on

256
00:21:49.280 --> 00:21:54.880
this. I don't think that production grade, enterprise grade databases come for cheap,

257
00:21:54.880 --> 00:22:01.440
unfortunately. So that's our two cents on cost, but there's a lot of other features. We don't have

258
00:22:01.440 --> 00:22:05.680
time to cover them all. In fact, I think we should probably do a few more episodes on Aurora

259
00:22:05.680 --> 00:22:11.040
architecture, maybe setting up and managing Aurora, but what other topics should we run

260
00:22:11.040 --> 00:22:14.960
through this channel before we finish up?

261
00:22:14.960 --> 00:22:19.360
Yeah, let's do a quick list of other things that might be interesting to know, but we'll leave it to you the task of like doing a deep down and

262
00:22:19.360 --> 00:22:22.960
really trying to understand all of the details. So the first thing to mention is that there is

263
00:22:22.960 --> 00:22:28.080
a data API, which right now exists only for Aurora Postgres. MySQL was interesting enough

264
00:22:28.080 --> 00:22:33.520
supported in Aurora server as V1, but it's not there yet, at least in V2. So if you're planning

265
00:22:33.520 --> 00:22:40.320
to go from V1 to V2 and you were relying on this MySQL data API, just be aware that it's not there

266
00:22:40.320 --> 00:22:46.000
for the V2, at least not yet. Hopefully it's going to come soon. But what is the point of this data

267
00:22:46.000 --> 00:22:50.800
API? So the idea is that with the database, you generally connect through kind of a raw TCP

268
00:22:50.800 --> 00:22:55.920
connection that uses a protocol that is specific to the database system. While with this data API,

269
00:22:55.920 --> 00:23:02.160
there is effectively an HTTP API that replaces all of that. And why is this convenient? Because

270
00:23:03.120 --> 00:23:07.280
it's a little bit easier, for instance, to call if you are in a Lambda, you don't necessarily need to

271
00:23:07.280 --> 00:23:13.280
install specific drivers for your own database. So it can make things a little bit easier in terms of

272
00:23:13.280 --> 00:23:17.920
connectivity from different environments. Now, should you use it? Again, if you are in a server

273
00:23:18.000 --> 00:23:24.080
environment, serverless environment probably makes things easier. But if you are in other context,

274
00:23:24.080 --> 00:23:29.840
maybe you have a more traditional application with maybe using an ORM, a standard framework,

275
00:23:29.840 --> 00:23:33.280
like, I don't know, Spring Boot or something like that, it's going to be probably much easier to

276
00:23:33.280 --> 00:23:37.200
just use the tools that you are already familiar with and just do things in the classic way.

277
00:23:37.200 --> 00:23:43.200
Another interesting thing is that there is an RDS query editor. So you can finally run queries

278
00:23:43.200 --> 00:23:48.480
in the AWS console. This is something that for traditional RDS, I was looking for for a long

279
00:23:48.480 --> 00:23:54.080
time. It's good to know that with Aurora, you have that option. And it is based on the data API,

280
00:23:54.080 --> 00:23:58.560
so you need to enable the data API for it to work. So just be aware of that small detail.

281
00:23:58.560 --> 00:24:02.560
And there are some limitations that we have observed using it. But if you just need to run

282
00:24:02.560 --> 00:24:06.480
a quick query just to try to validate some assumption, it can be a really useful tool,

283
00:24:06.480 --> 00:24:10.480
and it might save you a lot of time. Now, it's not necessarily the main tool you should be using

284
00:24:10.480 --> 00:24:14.480
for doing all your data modeling with your database. But again, if you just need to use

285
00:24:14.480 --> 00:24:20.160
it for some debugging, it can be very beneficial. And the other thing is RDS proxy. It's probably

286
00:24:20.160 --> 00:24:24.880
a better solution for Lambda compared to data API. It's an additional resource that you need to

287
00:24:24.880 --> 00:24:29.920
provision for each regional cluster. And the idea is that because when you run Lambdas, you might

288
00:24:29.920 --> 00:24:36.000
end up having really, really quick spinning up thousands of Lambdas. And every single Lambda is

289
00:24:36.000 --> 00:24:40.320
going to try to establish its own connection. So if you try to do that in the traditional way,

290
00:24:40.320 --> 00:24:45.120
where you try to just establish a TCP connection directly against the database, you might very

291
00:24:45.120 --> 00:24:50.960
easily saturate the pool of connections available in the database. So this proxy tries to manage all

292
00:24:50.960 --> 00:24:55.440
of that, tries to provide some kind of share pool and manage all of this stuff so that you don't end

293
00:24:55.440 --> 00:24:59.600
up overloading your database in the case where you're spinning up thousands of Lambdas at the

294
00:24:59.600 --> 00:25:03.920
same time. So it keeps your database a little bit leaner and manages all of these things,

295
00:25:03.920 --> 00:25:09.440
and also gives you faster failover because it's aware of the cluster topology. So you don't have

296
00:25:09.440 --> 00:25:15.520
to rely on DNS. And with DNS, oftentimes you might have problems because maybe you have a TTL,

297
00:25:15.520 --> 00:25:19.200
and then your DNS doesn't get refreshed fast enough. So you might be failing for a while

298
00:25:19.200 --> 00:25:24.240
before you figure out that there is a new DNS record, and then you can easily connect to the

299
00:25:24.240 --> 00:25:29.600
correct instance. Another interesting point is that allows you to enforce IAM authentication.

300
00:25:29.600 --> 00:25:34.080
So this can be useful if you have, for instance, to share secrets with the application directly.

301
00:25:34.080 --> 00:25:38.400
The small problem is that, of course, because it's an additional resource, there is an additional

302
00:25:38.400 --> 00:25:44.960
cost. So something that you have to consider is $25 a month, more or less. So it's not a massive

303
00:25:44.960 --> 00:25:49.520
cost, but depending what you are trying to do and what is your budget, it can be something

304
00:25:49.520 --> 00:25:53.600
significant and is worth considering that. So these three things I wanted to mention,

305
00:25:53.600 --> 00:25:58.880
Data API, RDS query editor, and RDS proxy, somewhat interesting. So if you end up using our

306
00:25:58.880 --> 00:26:02.800
Aurora or seriously considering Aurora, check them out a little bit better in the documentation.

307
00:26:02.800 --> 00:26:06.560
We'll have links in the show notes if you really want to understand why those additional

308
00:26:06.560 --> 00:26:11.200
three things can be really beneficial for you. I guess this is time now to jump to the conclusions.

309
00:26:18.240 --> 00:26:22.400
Yeah, while we were talking about v1 and v2, I was reminded that the Cloudanut podcast and blog, they had a good analysis of the differences between v1 and v2 because I think they were

310
00:26:22.400 --> 00:26:27.760
using v1 and were a bit disappointed to realize that the migration path from v1 to v2 isn't great.

311
00:26:27.760 --> 00:26:32.640
Essentially, you have to take a snapshot and then copy it across, create a new v2 cluster from it.

312
00:26:32.640 --> 00:26:36.960
It's worth checking out, but maybe we should finish up with some advice on when you should

313
00:26:36.960 --> 00:26:41.440
use Aurora from our perspective. I think it's really for serious enterprise use cases.

314
00:26:42.400 --> 00:26:46.000
And I can see Amazon basically aiming at people who are paying a lot of money for commercial

315
00:26:46.000 --> 00:26:50.720
databases with high license costs and lower performance. And they're saying,

316
00:26:50.720 --> 00:26:55.120
this is going to be cheaper and faster, even though it's still a significant cost for the

317
00:26:55.120 --> 00:27:02.400
average user like us from our perspective. For enterprises, they can definitely make some savings.

318
00:27:02.400 --> 00:27:07.840
But it's also good for single instance, low config, serverless type cases that need relational database

319
00:27:07.840 --> 00:27:12.320
rather than no SQL. So if you're somewhere in between those two extremes, you might just use

320
00:27:12.320 --> 00:27:18.160
RDS or another vendor, especially if you are cost conscious. So just to summarize everything we

321
00:27:18.160 --> 00:27:23.280
talked about today, Aurora, its relational database solution on AWS, we talked about some of its unique

322
00:27:23.280 --> 00:27:28.400
capabilities, intricacies and trade offs, and how it'll give you MySQL and Postgres compatibility

323
00:27:28.400 --> 00:27:33.760
with faster performance. But the most important thing maybe to take away is its distinct storage

324
00:27:33.760 --> 00:27:38.080
layer that gives you that better performance and durability and faster recovery. And then bear in

325
00:27:38.080 --> 00:27:43.680
mind as well the concepts of Aurora clusters, reader and writers, endpoints, instances, and

326
00:27:43.680 --> 00:27:48.640
global databases as well. When it comes to Aurora serverless, comparing its two versions and their

327
00:27:48.640 --> 00:27:54.720
features, V2 is definitely more enterprise grade, but V1 is not going to be supported from the end

328
00:27:54.720 --> 00:28:00.560
of this year anyway. And while it definitely does not reach the gold standard of serverlessness

329
00:28:00.560 --> 00:28:05.360
set by DynamoDB, it does have its uses, particularly for variable traffic use cases,

330
00:28:05.360 --> 00:28:11.120
and maybe pre-production workloads as well. And we also touched on billing aspects and things like

331
00:28:11.120 --> 00:28:17.040
the data API, RDS query editor, and RDS proxy as well. So overall, I think it is a really powerful

332
00:28:17.040 --> 00:28:23.360
and scalable solution. It's not trivial to use, especially when it comes to global scale, but

333
00:28:23.360 --> 00:28:28.080
still way more trivial than the alternative because when you're dealing with clusters of

334
00:28:28.080 --> 00:28:33.360
relational databases, at least as of yet, there is no silver bullet, ultimately simple solution.

335
00:28:34.160 --> 00:28:39.120
So thanks very much for joining us and join us in the upcoming episode for more on Aurora and

336
00:28:39.120 --> 00:28:43.200
a whole load of other AWS topics.
