{
  "speakers": {
    "spk_0": "Eoin",
    "spk_1": "Luciano"
  },
  "segments": [
    {
      "speakerLabel": "spk_0",
      "start": 0,
      "end": 3.68,
      "text": " Hello, today we are going to answer the question, how do you use SQS?"
    },
    {
      "speakerLabel": "spk_0",
      "start": 3.68,
      "end": 8.48,
      "text": " And so by the end of this episode, you will know when to use an SQS queue and we'll give"
    },
    {
      "speakerLabel": "spk_0",
      "start": 8.48,
      "end": 13.76,
      "text": " some example use cases. We'll talk about the main features of SQS, how to send and receive messages,"
    },
    {
      "speakerLabel": "spk_0",
      "start": 14.4,
      "end": 18.48,
      "text": " how to customize the configuration of a queue, and we'll also talk a lot about the integration"
    },
    {
      "speakerLabel": "spk_0",
      "start": 18.48,
      "end": 30.16,
      "text": " between SQS and Lambda. My name is Eoin and I'm joined by Luciano and this is the AWS Bites podcast."
    },
    {
      "speakerLabel": "spk_0",
      "start": 33.04,
      "end": 37.28,
      "text": " In the last episode, we talked about all the different AWS event services you have"
    },
    {
      "speakerLabel": "spk_0",
      "start": 37.84,
      "end": 44.400000000000006,
      "text": " and today we're going to do a deep dive on SQS. So I think we had a classification of event systems"
    },
    {
      "speakerLabel": "spk_0",
      "start": 44.4,
      "end": 49.92,
      "text": " the last time Luciano, we had point-to-point systems, we had PubSub and we had streaming."
    },
    {
      "speakerLabel": "spk_0",
      "start": 49.92,
      "end": 54.56,
      "text": " So SQS is a point-to-point system. What is it good for?"
    },
    {
      "speakerLabel": "spk_0",
      "start": 55.6,
      "end": 62.32,
      "text": " Yeah, so in the last episode we gave a few high-level details about SQS, so let's deep dive."
    },
    {
      "speakerLabel": "spk_1",
      "start": 62.32,
      "end": 67.84,
      "text": " We mentioned that decoupling producers and consumers is generally a good use case for SQS."
    },
    {
      "speakerLabel": "spk_1",
      "start": 67.84,
      "end": 75.52000000000001,
      "text": " Also, it's a good service to add reliability because basically when you add SQS, you have an"
    },
    {
      "speakerLabel": "spk_1",
      "start": 75.52000000000001,
      "end": 81.68,
      "text": " easy way to store messages persistently, so you can consume them later and this is good for"
    },
    {
      "speakerLabel": "spk_1",
      "start": 81.68,
      "end": 87.2,
      "text": " instance in cases where your consumer might not be immediately available or it might be overloaded."
    },
    {
      "speakerLabel": "spk_1",
      "start": 87.2,
      "end": 93.2,
      "text": " You can have a queue in between and that allows you to be able to manage these kind of situations"
    },
    {
      "speakerLabel": "spk_1",
      "start": 93.2,
      "end": 101.2,
      "text": " in a more reliable way. The other thing is that a characteristic of SQS is that each message is"
    },
    {
      "speakerLabel": "spk_1",
      "start": 101.2,
      "end": 108.8,
      "text": " expected to be processed by one consumer and that will have implications that we'll discuss later"
    },
    {
      "speakerLabel": "spk_1",
      "start": 108.8,
      "end": 117.04,
      "text": " with some of the examples. Also, multiple consumers allows you to scale highly. For instance, if you"
    },
    {
      "speakerLabel": "spk_1",
      "start": 117.04,
      "end": 121.68,
      "text": " are producing many, many messages and for some reason your application is not working, you can"
    },
    {
      "speakerLabel": "spk_1",
      "start": 121.68,
      "end": 125.76,
      "text": " for some reason your application is more and more successful, so the number of messages grows"
    },
    {
      "speakerLabel": "spk_1",
      "start": 125.76,
      "end": 130.32,
      "text": " exponentially, you can keep allocating more and more consumers and you will just get all the"
    },
    {
      "speakerLabel": "spk_1",
      "start": 130.32,
      "end": 138.24,
      "text": " messages being distributed and you can compute in a more parallelized way. So that let's say SQS is"
    },
    {
      "speakerLabel": "spk_1",
      "start": 138.24,
      "end": 143.92000000000002,
      "text": " generally a good way to scale workloads when the number of items to process increases over time."
    },
    {
      "speakerLabel": "spk_1",
      "start": 144.8,
      "end": 149.84,
      "text": " And the other thing is that it can be used even for cross-region or cross-account communication"
    },
    {
      "speakerLabel": "spk_1",
      "start": 149.84,
      "end": 156.08,
      "text": " because from one region you can publish messages in another region or even from one account you"
    },
    {
      "speakerLabel": "spk_1",
      "start": 156.08,
      "end": 163.44,
      "text": " can publish messages in another account. So it can be used for communicating that way across"
    },
    {
      "speakerLabel": "spk_1",
      "start": 163.44,
      "end": 169.44,
      "text": " regions and accounts. Is there any example use case that you want to mention to try to clarify"
    },
    {
      "speakerLabel": "spk_1",
      "start": 170.96,
      "end": 176.4,
      "text": " these points we just mentioned?"
    },
    {
      "speakerLabel": "spk_0",
      "start": 176.4,
      "end": 181.36,
      "text": " There are loads of use cases where you can really make great use of SQS but I suppose some of the simple ones we talked about the last time were you want to send"
    },
    {
      "speakerLabel": "spk_0",
      "start": 181.36,
      "end": 188.88,
      "text": " an email so you could have a service that consumes email sending requests and SQS is ideal for that"
    },
    {
      "speakerLabel": "spk_0",
      "start": 188.88,
      "end": 195.84,
      "text": " or if you have some sort of batch processing like a service to process picture resizing requests."
    },
    {
      "speakerLabel": "spk_0",
      "start": 196.96,
      "end": 202,
      "text": " That's a typical example and you can imagine the same thing being applied to a lot of enterprise"
    },
    {
      "speakerLabel": "spk_0",
      "start": 202,
      "end": 207.28,
      "text": " batch processing workloads as well like if you're doing some sort of calculation or modeling an"
    },
    {
      "speakerLabel": "spk_0",
      "start": 207.28,
      "end": 213.28,
      "text": " aggregation task these are all jobs that you can put on an SQS queue and then have one or many"
    },
    {
      "speakerLabel": "spk_0",
      "start": 213.28,
      "end": 219.12,
      "text": " many workers that pull from that queue. It could be an AI modeling workload as well so you can just"
    },
    {
      "speakerLabel": "spk_0",
      "start": 219.12,
      "end": 224.88,
      "text": " imagine having a pool of workers and that pool can scale auto scale according to the queue depth the"
    },
    {
      "speakerLabel": "spk_0",
      "start": 224.88,
      "end": 231.92,
      "text": " number of messages in your queue. That's a pretty typical pattern. You've also got I suppose thinking"
    },
    {
      "speakerLabel": "spk_0",
      "start": 231.92,
      "end": 238.32,
      "text": " like about enterprise architecture or event driven microservices the architecture and decoupling"
    },
    {
      "speakerLabel": "spk_0",
      "start": 238.32,
      "end": 244.48,
      "text": " systems SQS is really useful in all of those situations so decoupling within systems at a"
    },
    {
      "speakerLabel": "spk_0",
      "start": 244.48,
      "end": 249.68,
      "text": " finer grain or at a macro level across a big enterprise full of applications."
    },
    {
      "speakerLabel": "spk_0",
      "start": 249.68,
      "end": 255.36,
      "text": " So yeah that's that's particularly useful you could also use it as an SNS subscription so"
    },
    {
      "speakerLabel": "spk_0",
      "start": 255.36,
      "end": 259.52,
      "text": " we mentioned that it's a point-to-point channel but you can also use it with PubSub"
    },
    {
      "speakerLabel": "spk_0",
      "start": 260.16,
      "end": 264.96000000000004,
      "text": " and together you get point-to-point with reliability or sorry PubSub with reliability."
    },
    {
      "speakerLabel": "spk_0",
      "start": 266.56,
      "end": 273.44,
      "text": " You also have DLQs so DLQs there's lots of enterprise integration patterns and DLQ is"
    },
    {
      "speakerLabel": "spk_0",
      "start": 273.44,
      "end": 279.76,
      "text": " one of the most well known and that's essentially a dead letter queue which so it's a queue where"
    },
    {
      "speakerLabel": "spk_0",
      "start": 279.76,
      "end": 285.12,
      "text": " if you have messages that have failed to be processed repeatedly you can put them into"
    },
    {
      "speakerLabel": "spk_0",
      "start": 285.12,
      "end": 290.4,
      "text": " a dead letter queue and then manually re-inspect them and schedule them for redelivery later."
    },
    {
      "speakerLabel": "spk_0",
      "start": 291.28,
      "end": 299.12,
      "text": " So SQS queues can be used as DLQs in their own right with any system but SQS also has a feature"
    },
    {
      "speakerLabel": "spk_0",
      "start": 299.12,
      "end": 306,
      "text": " but SQS also has a feature which allows you to send failed messages to another queue which is a DLQ."
    },
    {
      "speakerLabel": "spk_0",
      "start": 306.72,
      "end": 312.32,
      "text": " So that's one of the one of the cool features of SQS. Should we go through and run through the"
    },
    {
      "speakerLabel": "spk_0",
      "start": 312.32,
      "end": 319.36,
      "text": " highlight features of SQS quickly? Where would you start? Yeah I think so."
    },
    {
      "speakerLabel": "spk_1",
      "start": 319.36,
      "end": 324.56,
      "text": " So yeah the first thing that we also mentioned in the previous episode is that we have two different types of queues in SQS."
    },
    {
      "speakerLabel": "spk_1",
      "start": 324.56,
      "end": 331.76,
      "text": " One type is called regular queues I guess for lack of better naming and the other type is FIFO queues."
    },
    {
      "speakerLabel": "spk_1",
      "start": 331.76,
      "end": 340.4,
      "text": " So with regular queues you get different types of guarantees and the idea is that a queue will do"
    },
    {
      "speakerLabel": "spk_1",
      "start": 340.4,
      "end": 347.36,
      "text": " like a best effort delivery in terms of ordering so you are not guaranteed to have messages"
    },
    {
      "speakerLabel": "spk_1",
      "start": 347.36,
      "end": 353.92,
      "text": " strictly ordered when you consume them and the other thing is that you get at least once delivery"
    },
    {
      "speakerLabel": "spk_1",
      "start": 353.92,
      "end": 358.16,
      "text": " which basically means that when you receive the messages it might happen that you get the same"
    },
    {
      "speakerLabel": "spk_1",
      "start": 358.16,
      "end": 365.36,
      "text": " message more than once. When you need a little bit more strict guarantees you can use FIFO queues"
    },
    {
      "speakerLabel": "spk_1",
      "start": 365.36,
      "end": 371.28000000000003,
      "text": " and FIFO queues will give you ordering guarantees so if you produce messages with a certain order"
    },
    {
      "speakerLabel": "spk_1",
      "start": 371.28000000000003,
      "end": 377.6,
      "text": " those messages are consumed in the same order and also get exactly once delivery so FIFO queues have"
    },
    {
      "speakerLabel": "spk_1",
      "start": 377.6,
      "end": 384,
      "text": " a mechanism to remove potentially duplicated messages coming in again into the queue"
    },
    {
      "speakerLabel": "spk_1",
      "start": 384.88,
      "end": 389.68,
      "text": " and we'll probably give you a few more details about that later on during this episode."
    },
    {
      "speakerLabel": "spk_1",
      "start": 390.32000000000005,
      "end": 395.36,
      "text": " Another interesting feature is DLQ. We already mentioned it. It's something that needs to be"
    },
    {
      "speakerLabel": "spk_1",
      "start": 395.36,
      "end": 401.28000000000003,
      "text": " enabled and we'll discuss a little bit more how to enable that but it's very easy to have it"
    },
    {
      "speakerLabel": "spk_1",
      "start": 401.28,
      "end": 407.91999999999996,
      "text": " built in and this is very convenient because it's very common that you define a number of messages"
    },
    {
      "speakerLabel": "spk_1",
      "start": 407.91999999999996,
      "end": 414.08,
      "text": " types in your application then your code evolves eventually you might be introducing a bug in the"
    },
    {
      "speakerLabel": "spk_1",
      "start": 414.08,
      "end": 420.32,
      "text": " code that is processing a job and what happens is that if your job if your worker is always crashing"
    },
    {
      "speakerLabel": "spk_1",
      "start": 420.88,
      "end": 425.2,
      "text": " then you're not going to be able to process that message ever so rather than keep retrying it"
    },
    {
      "speakerLabel": "spk_1",
      "start": 425.2,
      "end": 430.79999999999995,
      "text": " indefinitely it will eventually be moved to a DLQ somebody can investigate and then when you"
    },
    {
      "speakerLabel": "spk_1",
      "start": 430.8,
      "end": 436.48,
      "text": " realize what's the problem you fix the bug you can easily reingest from the DLQ and actually process"
    },
    {
      "speakerLabel": "spk_1",
      "start": 436.48,
      "end": 442.16,
      "text": " the message so this is actually a very critical feature that I think most applications using"
    },
    {
      "speakerLabel": "spk_1",
      "start": 442.16,
      "end": 451.76,
      "text": " IQ should avail of. Another interesting detail is that the protocol of Sqs is not one of the common"
    },
    {
      "speakerLabel": "spk_1",
      "start": 451.76,
      "end": 460,
      "text": " protocols generally seen in other queuing systems like RabbitMQ or ActiveMQ that uses protocol like"
    },
    {
      "speakerLabel": "spk_1",
      "start": 460,
      "end": 470.88,
      "text": " AMQP or MQTT. In the case of Sqs the protocol is HTTP. I don't think it makes a huge difference at"
    },
    {
      "speakerLabel": "spk_1",
      "start": 470.88,
      "end": 476,
      "text": " the end of the day because the way you interact is through the SDK so you don't get to really work at"
    },
    {
      "speakerLabel": "spk_1",
      "start": 476,
      "end": 482.88,
      "text": " the protocol level but there might be different features and different characteristics in terms"
    },
    {
      "speakerLabel": "spk_1",
      "start": 482.88,
      "end": 487.92,
      "text": " of performance because of the underlying protocol so that that might be interesting to know for some"
    },
    {
      "speakerLabel": "spk_1",
      "start": 487.92,
      "end": 496.48,
      "text": " people that are coming from other queuing systems. Then we also have a server-side encryption so"
    },
    {
      "speakerLabel": "spk_1",
      "start": 497.12,
      "end": 505.12,
      "text": " messages are encrypted in transit and I suppose also they are stored encrypted."
    },
    {
      "speakerLabel": "spk_1",
      "start": 508.48,
      "end": 511.52000000000004,
      "text": " We have message delays which basically allows us to"
    },
    {
      "speakerLabel": "spk_1",
      "start": 511.52,
      "end": 519.92,
      "text": " configure in different ways how and when the message should appear in the queue. We'll mention"
    },
    {
      "speakerLabel": "spk_1",
      "start": 519.92,
      "end": 527.28,
      "text": " a few examples later on. The other very interesting thing is that Sqs is durable and available pretty"
    },
    {
      "speakerLabel": "spk_1",
      "start": 527.28,
      "end": 535.76,
      "text": " much by default, also scalable. That means for instance if we look in contrast Kinesis, with"
    },
    {
      "speakerLabel": "spk_1",
      "start": 535.76,
      "end": 541.6,
      "text": " Kinesis you need to do a little bit of capacity planning. You need to understand how many shards"
    },
    {
      "speakerLabel": "spk_1",
      "start": 541.6,
      "end": 547.76,
      "text": " you need to provision and that's generally based on what is the throughput that you want to achieve."
    },
    {
      "speakerLabel": "spk_1",
      "start": 547.76,
      "end": 552.72,
      "text": " With Sqs you don't have to worry about all the stuff. Queues will automatically scale for you"
    },
    {
      "speakerLabel": "spk_1",
      "start": 552.72,
      "end": 558.72,
      "text": " and you don't need to pre-provision any of that stuff. In general I would say that the biggest"
    },
    {
      "speakerLabel": "spk_1",
      "start": 558.72,
      "end": 565.76,
      "text": " feature of Sqs is that it is a very simple, true to its name, a very simple queuing system"
    },
    {
      "speakerLabel": "spk_1",
      "start": 566.4,
      "end": 573.6,
      "text": " and therefore it's very easy to integrate in most applications and you get very good performance"
    },
    {
      "speakerLabel": "spk_1",
      "start": 574.24,
      "end": 577.76,
      "text": " basically straight away without having to go crazy with configuration."
    },
    {
      "speakerLabel": "spk_1",
      "start": 579.52,
      "end": 584.4,
      "text": " Is there anything else worth mentioning? Maybe, I don't know, some interesting integrations with"
    },
    {
      "speakerLabel": "spk_1",
      "start": 584.4,
      "end": 592.72,
      "text": " other services. What do you think? Yeah, for sure."
    },
    {
      "speakerLabel": "spk_0",
      "start": 592.72,
      "end": 597.4399999999999,
      "text": " On the integration with other services side we can think of I suppose about the producer side and the consumer side. So when you're producing messages"
    },
    {
      "speakerLabel": "spk_0",
      "start": 598.72,
      "end": 603.92,
      "text": " a lot of services are there that target Sqs already. So if you've got an API gateway you can"
    },
    {
      "speakerLabel": "spk_0",
      "start": 604.64,
      "end": 608,
      "text": " back that with a queue. So you can send messages from API gateway directly to a queue."
    },
    {
      "speakerLabel": "spk_0",
      "start": 608,
      "end": 615.12,
      "text": " We already mentioned SNS subscriptions so SNS and Sqs play very nicely together. EventBridge too,"
    },
    {
      "speakerLabel": "spk_0",
      "start": 615.12,
      "end": 620.56,
      "text": " in the same way and you can also integrate it into step functions. So it's pretty well integrated on"
    },
    {
      "speakerLabel": "spk_0",
      "start": 620.56,
      "end": 627.76,
      "text": " the production side. Of course we could talk about the consumption side but for both consumption and"
    },
    {
      "speakerLabel": "spk_0",
      "start": 627.76,
      "end": 633.28,
      "text": " production you can also use it programmatically. So let's talk about how do you send a message and"
    },
    {
      "speakerLabel": "spk_0",
      "start": 633.28,
      "end": 638.56,
      "text": " how do you receive a message. So on the sending side there's a send message API and there's also"
    },
    {
      "speakerLabel": "spk_0",
      "start": 638.56,
      "end": 643.36,
      "text": " a send message batch API. So you can send a single message or you can send up to 10 in a batch."
    },
    {
      "speakerLabel": "spk_0",
      "start": 643.36,
      "end": 650.0799999999999,
      "text": " So that's the limit in a batch. Then when you receive you call on the consumption side"
    },
    {
      "speakerLabel": "spk_0",
      "start": 651.28,
      "end": 657.1999999999999,
      "text": " it's essentially a pull mode. So you have an SDK or an API that you use to call receive message and"
    },
    {
      "speakerLabel": "spk_0",
      "start": 657.1999999999999,
      "end": 662.4,
      "text": " receive message and it also allows you to receive up to 10 messages at a time. So you can choose"
    },
    {
      "speakerLabel": "spk_0",
      "start": 662.4,
      "end": 669.12,
      "text": " to receive one or up to 10. And that operates in two modes. You've got short polling mode and long"
    },
    {
      "speakerLabel": "spk_0",
      "start": 669.12,
      "end": 674.88,
      "text": " polling mode. So short polling is basically saying give me a message if one is available"
    },
    {
      "speakerLabel": "spk_0",
      "start": 674.88,
      "end": 680.0799999999999,
      "text": " but if no message is available just return. So that's essentially a zero seconds wait time."
    },
    {
      "speakerLabel": "spk_0",
      "start": 680.0799999999999,
      "end": 684.56,
      "text": " But you can also do long polling where you can say wait up to 20 seconds for messages to appear"
    },
    {
      "speakerLabel": "spk_0",
      "start": 684.56,
      "end": 690.16,
      "text": " and then return. So the difference there is it depends on the volume of messages you're"
    },
    {
      "speakerLabel": "spk_0",
      "start": 690.16,
      "end": 695.76,
      "text": " expecting and the nature of your system. I suppose it's important to kind of bear in mind that if"
    },
    {
      "speakerLabel": "spk_0",
      "start": 695.76,
      "end": 701.52,
      "text": " you're polling more frequently that's an extra request. SQS is priced essentially on the number"
    },
    {
      "speakerLabel": "spk_0",
      "start": 701.52,
      "end": 707.1999999999999,
      "text": " of requests. There's also data transfer but it's fundamentally about the number of requests so you"
    },
    {
      "speakerLabel": "spk_0",
      "start": 707.1999999999999,
      "end": 710.8,
      "text": " can bear that in mind. So once you've called receive message then you can do your message"
    },
    {
      "speakerLabel": "spk_0",
      "start": 710.8,
      "end": 717.1999999999999,
      "text": " processing and then delete. So it's essentially like you're starting a job and then you're"
    },
    {
      "speakerLabel": "spk_0",
      "start": 717.2,
      "end": 722.4000000000001,
      "text": " committing to the fact that you've processed the job by calling delete message at the end."
    },
    {
      "speakerLabel": "spk_0",
      "start": 722.4000000000001,
      "end": 728.48,
      "text": " So there's three steps essentially when you're a consumer. So the interesting thing there is"
    },
    {
      "speakerLabel": "spk_0",
      "start": 728.48,
      "end": 736.1600000000001,
      "text": " what happens when you forget to delete and yeah that's really important. So can you describe that"
    },
    {
      "speakerLabel": "spk_0",
      "start": 736.1600000000001,
      "end": 741.36,
      "text": " Luciano? What would you expect to happen if you forget to delete a message from a queue after"
    },
    {
      "speakerLabel": "spk_0",
      "start": 741.36,
      "end": 747.76,
      "text": " you've processed it? Yeah so I'm gonna try to give a brief description of that."
    },
    {
      "speakerLabel": "spk_1",
      "start": 747.76,
      "end": 753.6,
      "text": " I think we will understand more how that really works when we deep dive into the actual configuration. But in"
    },
    {
      "speakerLabel": "spk_1",
      "start": 753.6,
      "end": 761.6800000000001,
      "text": " general SQS never really deletes messages that have been delivered to a consumer because it's"
    },
    {
      "speakerLabel": "spk_1",
      "start": 761.6800000000001,
      "end": 767.84,
      "text": " waiting for the consumer to acknowledge that the job was completed and that's done through"
    },
    {
      "speakerLabel": "spk_1",
      "start": 767.84,
      "end": 774.48,
      "text": " an explicit call to the delete message API. And so if that doesn't happen because either you"
    },
    {
      "speakerLabel": "spk_1",
      "start": 774.48,
      "end": 779.6800000000001,
      "text": " forget to do that in your code or maybe there is a bug and the worker crashes before is actually"
    },
    {
      "speakerLabel": "spk_1",
      "start": 779.6800000000001,
      "end": 785.2,
      "text": " able to delete the message, the only thing that SQS can do is assume that something went wrong."
    },
    {
      "speakerLabel": "spk_1",
      "start": 785.2,
      "end": 790.32,
      "text": " Maybe the message was not delivered, maybe the job was not processed correctly, so it's gonna"
    },
    {
      "speakerLabel": "spk_1",
      "start": 790.32,
      "end": 795.44,
      "text": " make the job eventually reappear in the queue so that it can be processed again. So it's kind of"
    },
    {
      "speakerLabel": "spk_1",
      "start": 795.44,
      "end": 801.36,
      "text": " taking a sane default to make sure that you have a chance to process that message again in case"
    },
    {
      "speakerLabel": "spk_1",
      "start": 802.08,
      "end": 809.36,
      "text": " something went wrong. So yeah make sure to delete the message when you completed processing it,"
    },
    {
      "speakerLabel": "spk_1",
      "start": 809.36,
      "end": 816.24,
      "text": " otherwise you'll end up reprocessing the same job over and over again. And of course your queue"
    },
    {
      "speakerLabel": "spk_1",
      "start": 816.24,
      "end": 821.2800000000001,
      "text": " will grow indefinitely because you keep accumulating more and more messages that will"
    },
    {
      "speakerLabel": "spk_1",
      "start": 821.28,
      "end": 827.52,
      "text": " always reappear in the queue until they are completely expired because of the direction of a"
    },
    {
      "speakerLabel": "spk_1",
      "start": 827.52,
      "end": 835.6,
      "text": " message in the queue. So given that we are starting to talk more and more about the different"
    },
    {
      "speakerLabel": "spk_1",
      "start": 835.6,
      "end": 842.9599999999999,
      "text": " configuration options, should we deep dive into that? Let's do that."
    },
    {
      "speakerLabel": "spk_0",
      "start": 842.9599999999999,
      "end": 847.6,
      "text": " You mentioned around the deletion, it's all down to visibility. You mentioned this thing about messages,"
    },
    {
      "speakerLabel": "spk_0",
      "start": 847.6,
      "end": 853.6800000000001,
      "text": " they're not deleted, they just become invisible. So then my understanding of message visibility,"
    },
    {
      "speakerLabel": "spk_0",
      "start": 853.6800000000001,
      "end": 859.44,
      "text": " maybe you can chime in here, but if you receive a message, it remains in the queue,"
    },
    {
      "speakerLabel": "spk_0",
      "start": 859.44,
      "end": 864.72,
      "text": " so we said that prevents other consumers from seeing it. So it gives you, the first"
    },
    {
      "speakerLabel": "spk_0",
      "start": 864.72,
      "end": 870,
      "text": " consumer, a chance to process it. There's a visibility timeout, so the clock is ticking"
    },
    {
      "speakerLabel": "spk_0",
      "start": 870,
      "end": 876.1600000000001,
      "text": " and the consumer has to process it within this visibility timeout. And after that timeout has"
    },
    {
      "speakerLabel": "spk_0",
      "start": 876.16,
      "end": 882.88,
      "text": " elapsed, if it hasn't been explicitly deleted, it's going to reappear. So this is a configuration"
    },
    {
      "speakerLabel": "spk_0",
      "start": 882.88,
      "end": 888.7199999999999,
      "text": " setting then you can set a queue level, but you can also set it at an individual message level"
    },
    {
      "speakerLabel": "spk_0",
      "start": 888.7199999999999,
      "end": 894.88,
      "text": " when you call receive message. So it can be zero seconds, it can be up to 12 hours,"
    },
    {
      "speakerLabel": "spk_0",
      "start": 894.88,
      "end": 900.64,
      "text": " but the default is 30 seconds."
    },
    {
      "speakerLabel": "spk_1",
      "start": 900.64,
      "end": 906,
      "text": " Yeah, I guess one case where this can be important is if you have a job that you know is going to take you a long time to process, make sure to find the"
    },
    {
      "speakerLabel": "spk_1",
      "start": 906,
      "end": 910.8,
      "text": " fine tune this visibility timeout, because if it's too low, while you are still processing"
    },
    {
      "speakerLabel": "spk_1",
      "start": 910.8,
      "end": 917.04,
      "text": " that message, it will already reappear in the queue. So you end up with duplicated processing"
    },
    {
      "speakerLabel": "spk_1",
      "start": 917.04,
      "end": 921.12,
      "text": " because of that. So that can be another issue that can happen when you have long running"
    },
    {
      "speakerLabel": "spk_1",
      "start": 921.12,
      "end": 926.24,
      "text": " processing jobs. Yeah, that's a good one."
    },
    {
      "speakerLabel": "spk_0",
      "start": 926.24,
      "end": 931.44,
      "text": " And we're going to talk about Lambda later, but Lambda has its own timeout and you want to make sure that they align the SQS timeout and"
    },
    {
      "speakerLabel": "spk_0",
      "start": 931.44,
      "end": 937.2,
      "text": " the Lambda timeout because it doesn't make sense for your Lambda to take longer than your visibility"
    },
    {
      "speakerLabel": "spk_0",
      "start": 937.2,
      "end": 942.72,
      "text": " timeout because you'll end up with that situation. Another configuration option I think worth"
    },
    {
      "speakerLabel": "spk_0",
      "start": 942.72,
      "end": 949.2800000000001,
      "text": " mentioning before we kind of move on is message groups because we talked about FIFO queues and the"
    },
    {
      "speakerLabel": "spk_0",
      "start": 949.2800000000001,
      "end": 954.1600000000001,
      "text": " ordering guarantees that you get. So those ordering guarantees aren't per for the whole"
    },
    {
      "speakerLabel": "spk_0",
      "start": 954.1600000000001,
      "end": 960.08,
      "text": " queue, you can actually partition it into ordered streams using message groups. It's a bit like"
    },
    {
      "speakerLabel": "spk_0",
      "start": 960.08,
      "end": 966.88,
      "text": " the way ordering works with Kinesis shards except different, but the concept is the same, right?"
    },
    {
      "speakerLabel": "spk_0",
      "start": 966.88,
      "end": 972.64,
      "text": " Because it means that you can say define multiple groups and then you can still get parallel"
    },
    {
      "speakerLabel": "spk_0",
      "start": 972.64,
      "end": 979.76,
      "text": " processing with ordering. So it's a nice way to balance that. But then the order guarantees and"
    },
    {
      "speakerLabel": "spk_0",
      "start": 979.76,
      "end": 985.36,
      "text": " the delivery guarantees are per message group ID. So that's interesting to know. There's a whole"
    },
    {
      "speakerLabel": "spk_0",
      "start": 985.36,
      "end": 990,
      "text": " set of other configuration options like you can set up message delay, you can set up the queue"
    },
    {
      "speakerLabel": "spk_0",
      "start": 990,
      "end": 998.4,
      "text": " retention up to 14 days, you could put a specific resource policy in there for security, a redrive"
    },
    {
      "speakerLabel": "spk_0",
      "start": 998.4,
      "end": 1004.48,
      "text": " policy for DLQs, we mentioned that already. And on FIFO queues actually you can also do"
    },
    {
      "speakerLabel": "spk_0",
      "start": 1004.48,
      "end": 1011.12,
      "text": " deduplication. So you can ensure that you got the exactly once delivery semantics by making sure"
    },
    {
      "speakerLabel": "spk_0",
      "start": 1011.12,
      "end": 1020,
      "text": " SQS can recognize when you've got a duplicate. These FIFO queues also support high throughput"
    },
    {
      "speakerLabel": "spk_0",
      "start": 1020,
      "end": 1028.48,
      "text": " mode, which is interesting because when you do those FIFO queues, because you've got ordering,"
    },
    {
      "speakerLabel": "spk_0",
      "start": 1029.12,
      "end": 1032.56,
      "text": " by its very nature, you're limiting throughput because you have to process them in order."
    },
    {
      "speakerLabel": "spk_0",
      "start": 1033.92,
      "end": 1039.84,
      "text": " So there's a number of settings like setting the FIFO throughput limit and stuff that you can use"
    },
    {
      "speakerLabel": "spk_0",
      "start": 1039.84,
      "end": 1046.1599999999999,
      "text": " to make sure you get the maximum throughput for FIFO queues. Throughput for standard queues,"
    },
    {
      "speakerLabel": "spk_0",
      "start": 1046.1599999999999,
      "end": 1052.8,
      "text": " it's essentially unlimited. So those are the configuration options. Are there any kind of"
    },
    {
      "speakerLabel": "spk_0",
      "start": 1052.8,
      "end": 1057.36,
      "text": " constraints, limitations, a lot of AWS services, you know, you have to understand all the quotas"
    },
    {
      "speakerLabel": "spk_0",
      "start": 1057.36,
      "end": 1061.76,
      "text": " and limitations. What's the soft limit? What's the hard limit? There aren't a lot with SQS, are there?"
    },
    {
      "speakerLabel": "spk_0",
      "start": 1062.48,
      "end": 1067.9199999999998,
      "text": " Yeah, there aren't."
    },
    {
      "speakerLabel": "spk_1",
      "start": 1067.92,
      "end": 1074.88,
      "text": " I think the main ones is that there is a limit on the message sides, which is 256 kilobytes. But a common pattern that I've seen is you can use, for instance, S3 and"
    },
    {
      "speakerLabel": "spk_1",
      "start": 1074.88,
      "end": 1081.52,
      "text": " just put a reference to the file in S3 in the message when you need to use more data."
    },
    {
      "speakerLabel": "spk_1",
      "start": 1083.44,
      "end": 1088.16,
      "text": " Then it's interesting to see that there are no limits in terms of the number of messages that"
    },
    {
      "speakerLabel": "spk_1",
      "start": 1088.16,
      "end": 1094,
      "text": " can be stored in a queue. So you can keep pushing more and more messages and you don't have a limit"
    },
    {
      "speakerLabel": "spk_1",
      "start": 1094,
      "end": 1102.4,
      "text": " there. And there aren't API limits in terms of requests except in the FIFO queues where you have,"
    },
    {
      "speakerLabel": "spk_1",
      "start": 1102.4,
      "end": 1106.96,
      "text": " I think, 300 API calls per second. Is that right? Yep."
    },
    {
      "speakerLabel": "spk_1",
      "start": 1106.96,
      "end": 1112.4,
      "text": " And 3,000 if you use batching because you can do 10 at a time, basically."
    },
    {
      "speakerLabel": "spk_1",
      "start": 1114.96,
      "end": 1120.24,
      "text": " And also there is another interesting limit, which is the number of messages that can be in-flight."
    },
    {
      "speakerLabel": "spk_1",
      "start": 1120.24,
      "end": 1125.76,
      "text": " We didn't... I don't think we explained what in-flight means, but basically it's those"
    },
    {
      "speakerLabel": "spk_1",
      "start": 1125.76,
      "end": 1130,
      "text": " messages that are currently being processed by workers on the other side."
    },
    {
      "speakerLabel": "spk_0",
      "start": 1130.64,
      "end": 1132.96,
      "text": " Received but not deleted. Exactly."
    },
    {
      "speakerLabel": "spk_1",
      "start": 1132.96,
      "end": 1139.68,
      "text": " Yeah. And the visibility time out hasn't expired yet, so they haven't reappeared in the queue."
    },
    {
      "speakerLabel": "spk_1",
      "start": 1140.24,
      "end": 1148.88,
      "text": " Yep. And there is a limit of 120,000 for regular queues and 20,000 for FIFO queues."
    },
    {
      "speakerLabel": "spk_1",
      "start": 1148.88,
      "end": 1153.68,
      "text": " Now, this is something I wanted to mention because one of the tools that we have mentioned also in"
    },
    {
      "speakerLabel": "spk_1",
      "start": 1153.68,
      "end": 1159.3600000000001,
      "text": " previous episodes called SlickWatch, which allows you to easily get observability in serverless"
    },
    {
      "speakerLabel": "spk_1",
      "start": 1159.3600000000001,
      "end": 1165.92,
      "text": " projects if you're using the serverless framework. In that serverless plugin that we built,"
    },
    {
      "speakerLabel": "spk_1",
      "start": 1165.92,
      "end": 1174.5600000000002,
      "text": " we already give you a pre-configured alarm and dashboard that you can have in your application"
    },
    {
      "speakerLabel": "spk_1",
      "start": 1174.56,
      "end": 1179.12,
      "text": " in your application to monitor if you are actually reaching this threshold"
    },
    {
      "speakerLabel": "spk_1",
      "start": 1179.12,
      "end": 1183.84,
      "text": " of too many in-flight requests. So if you want to check that out,"
    },
    {
      "speakerLabel": "spk_1",
      "start": 1183.84,
      "end": 1190.56,
      "text": " we'll put the link in the description. Yeah, that's good."
    },
    {
      "speakerLabel": "spk_0",
      "start": 1190.56,
      "end": 1193.76,
      "text": " It's a bit of a shameless self-promotion, but it's definitely worthwhile because those are the kinds of things you"
    },
    {
      "speakerLabel": "spk_0",
      "start": 1193.76,
      "end": 1198,
      "text": " never think about. And then in the rare situation where you've got a problem and your number of"
    },
    {
      "speakerLabel": "spk_0",
      "start": 1198,
      "end": 1204.72,
      "text": " in-flight messages goes through the roof, you'll get an alarm with it. I think it's worthwhile"
    },
    {
      "speakerLabel": "spk_0",
      "start": 1204.72,
      "end": 1210.32,
      "text": " talking about AWS Lambda because AWS Lambda works really well with SQS, but it has a whole set of"
    },
    {
      "speakerLabel": "spk_0",
      "start": 1210.32,
      "end": 1215.52,
      "text": " different considerations. So I think it's worthwhile talking about it. When you've got EC2 or ECS"
    },
    {
      "speakerLabel": "spk_0",
      "start": 1215.52,
      "end": 1221.76,
      "text": " consumers, containers somewhere, the operation model for consumers is relatively straightforward"
    },
    {
      "speakerLabel": "spk_0",
      "start": 1221.76,
      "end": 1225.44,
      "text": " because you're in control and you have to build all the infrastructure and scale it out yourself."
    },
    {
      "speakerLabel": "spk_0",
      "start": 1225.44,
      "end": 1232.24,
      "text": " With Lambda, there's something called an event source mapping. It's the same part of the Lambda"
    },
    {
      "speakerLabel": "spk_0",
      "start": 1232.24,
      "end": 1240.3200000000002,
      "text": " service that's also used with Kinesis and Kafka sources and DynamoDB streams. But event source"
    },
    {
      "speakerLabel": "spk_0",
      "start": 1240.3200000000002,
      "end": 1246.8,
      "text": " mapping is essentially a consumer for SQS that is managed for you within the Lambda service,"
    },
    {
      "speakerLabel": "spk_0",
      "start": 1246.8,
      "end": 1253.8400000000001,
      "text": " and it pulls those messages for you. So we mentioned how SQS integrates with other"
    },
    {
      "speakerLabel": "spk_0",
      "start": 1253.84,
      "end": 1258.8799999999999,
      "text": " services on the producer side. On the consumer side, it basically doesn't integrate with anything"
    },
    {
      "speakerLabel": "spk_0",
      "start": 1258.8799999999999,
      "end": 1264.1599999999999,
      "text": " because you have to pull messages out of it. But the exception is Lambda because it does that for"
    },
    {
      "speakerLabel": "spk_0",
      "start": 1264.1599999999999,
      "end": 1270.8,
      "text": " you. So one of the interesting things that I came across with Lambda and SQS is how it scales"
    },
    {
      "speakerLabel": "spk_0",
      "start": 1270.8,
      "end": 1277.84,
      "text": " differently than other Lambda sources. So if you're expecting that if you've got, we talked"
    },
    {
      "speakerLabel": "spk_0",
      "start": 1277.84,
      "end": 1283.4399999999998,
      "text": " about the batch processing workload, if you've got many, many containers or many Lambda instances"
    },
    {
      "speakerLabel": "spk_0",
      "start": 1283.44,
      "end": 1289.76,
      "text": " running and they're taking a long time to process SQS messages, some type of machine learning workload"
    },
    {
      "speakerLabel": "spk_0",
      "start": 1289.76,
      "end": 1297.52,
      "text": " running in Lambda might take 90 seconds to process an event, for example. The event source mapping is"
    },
    {
      "speakerLabel": "spk_0",
      "start": 1297.52,
      "end": 1302.8,
      "text": " only going to scale to 60 concurrent instances per minute. And this is dramatically different"
    },
    {
      "speakerLabel": "spk_0",
      "start": 1302.8,
      "end": 1307.2,
      "text": " to other event sources where you, I mean, if you call invoke Lambda, you can get a thousand"
    },
    {
      "speakerLabel": "spk_0",
      "start": 1307.2,
      "end": 1315.2,
      "text": " running instantly and you can get another thousand every minute. And that scales really fast. But"
    },
    {
      "speakerLabel": "spk_0",
      "start": 1315.2,
      "end": 1321.6000000000001,
      "text": " with SQS, you can't scale that way. And even if you use provision concurrency, which I tried,"
    },
    {
      "speakerLabel": "spk_0",
      "start": 1321.6000000000001,
      "end": 1327.52,
      "text": " it's still 60 per second to consume your SQS messages. So that can be a limit, but it depends"
    },
    {
      "speakerLabel": "spk_0",
      "start": 1327.52,
      "end": 1330.72,
      "text": " on how long it takes to process your messages. Obviously, if your messages are going to be"
    },
    {
      "speakerLabel": "spk_0",
      "start": 1330.72,
      "end": 1336.0800000000002,
      "text": " processed in seconds or hundreds of milliseconds, you're still going to be able to process"
    },
    {
      "speakerLabel": "spk_0",
      "start": 1336.08,
      "end": 1340.56,
      "text": " thousands of messages or thousands of batches of messages very quickly. But it's just important"
    },
    {
      "speakerLabel": "spk_0",
      "start": 1340.56,
      "end": 1347.4399999999998,
      "text": " to be aware of that. Well, if you've got FIFO queues then as well, you get one batch at a time"
    },
    {
      "speakerLabel": "spk_0",
      "start": 1347.4399999999998,
      "end": 1354.3999999999999,
      "text": " per message group ID. So that's, I suppose that's probably intuitive, but if you've got five"
    },
    {
      "speakerLabel": "spk_0",
      "start": 1354.3999999999999,
      "end": 1357.28,
      "text": " different message group IDs, then you're going to have a maximum of five consumers."
    },
    {
      "speakerLabel": "spk_0",
      "start": 1359.28,
      "end": 1364,
      "text": " There's also some interesting configuration options like the batching. So you can configure"
    },
    {
      "speakerLabel": "spk_0",
      "start": 1364,
      "end": 1371.12,
      "text": " if it should invoke your Lambda after a predefined number of seconds,"
    },
    {
      "speakerLabel": "spk_0",
      "start": 1371.12,
      "end": 1376.8,
      "text": " like every six seconds, for example, or if it had received a certain threshold number of messages,"
    },
    {
      "speakerLabel": "spk_0",
      "start": 1377.6,
      "end": 1382.48,
      "text": " or also just based on the payload size. So the number of megabytes that it has accumulated."
    },
    {
      "speakerLabel": "spk_0",
      "start": 1384.56,
      "end": 1388.96,
      "text": " So that's a whole set of configuration that you get with the Lambda service in SQS."
    },
    {
      "speakerLabel": "spk_0",
      "start": 1388.96,
      "end": 1392.64,
      "text": " And a really new one is the event filtering, which came out just late last year."
    },
    {
      "speakerLabel": "spk_0",
      "start": 1392.64,
      "end": 1396.48,
      "text": " And this is kind of interesting because you can filter at the event source mapping level and say,"
    },
    {
      "speakerLabel": "spk_0",
      "start": 1396.48,
      "end": 1400.24,
      "text": " I only want to filter messages matching this pattern. And you can do, you know,"
    },
    {
      "speakerLabel": "spk_0",
      "start": 1400.24,
      "end": 1405.3600000000001,
      "text": " JSON filter or a string filter. What that actually means sometimes is that if your consumer"
    },
    {
      "speakerLabel": "spk_0",
      "start": 1406.24,
      "end": 1411.76,
      "text": " doesn't match a filter, you can still end up losing messages because they've been processed"
    },
    {
      "speakerLabel": "spk_0",
      "start": 1411.76,
      "end": 1416.3200000000002,
      "text": " by the event source mapping, but they just haven't been sent onto your Lambda because"
    },
    {
      "speakerLabel": "spk_0",
      "start": 1416.3200000000002,
      "end": 1422.16,
      "text": " you filter them out. So you have to really think about the semantics there and whether you can"
    },
    {
      "speakerLabel": "spk_0",
      "start": 1422.16,
      "end": 1426.16,
      "text": " and if you want another consumer to be able to pick up that message, you might need to"
    },
    {
      "speakerLabel": "spk_0",
      "start": 1426.16,
      "end": 1433.1200000000001,
      "text": " re-architect the message delivery setup. And the last thing I'd say about Lambda is"
    },
    {
      "speakerLabel": "spk_0",
      "start": 1433.1200000000001,
      "end": 1438.72,
      "text": " just that cross account Lambdas with an SQS in a different account are also possible,"
    },
    {
      "speakerLabel": "spk_0",
      "start": 1438.72,
      "end": 1443.6000000000001,
      "text": " which is really helpful. I wish that was available for all the services, including Kinesis,"
    },
    {
      "speakerLabel": "spk_0",
      "start": 1443.6000000000001,
      "end": 1447.44,
      "text": " but that's really helpful for integration across multiple applications when you've got a multi"
    },
    {
      "speakerLabel": "spk_0",
      "start": 1447.44,
      "end": 1453.28,
      "text": " account set up, which is best practice these days, you know, separate account per application,"
    },
    {
      "speakerLabel": "spk_0",
      "start": 1453.28,
      "end": 1458.16,
      "text": " per environment. So if you want to communicate across applications, it's a really good way to do"
    },
    {
      "speakerLabel": "spk_0",
      "start": 1458.16,
      "end": 1463.2,
      "text": " it."
    },
    {
      "speakerLabel": "spk_1",
      "start": 1463.2,
      "end": 1469.2,
      "text": " Yeah, I think the way you described the integration with Lambda, it feels like there is a lot of magic that AWS does for you. So you have, you can basically build something quicker,"
    },
    {
      "speakerLabel": "spk_1",
      "start": 1469.2,
      "end": 1474.64,
      "text": " but I think it's interesting to understand what's really going on under the hood. So you don't have"
    },
    {
      "speakerLabel": "spk_1",
      "start": 1474.64,
      "end": 1477.92,
      "text": " surprises there. So I think that that was a good one to cover."
    },
    {
      "speakerLabel": "spk_1",
      "start": 1479.92,
      "end": 1484.16,
      "text": " Yeah. Yeah."
    },
    {
      "speakerLabel": "spk_0",
      "start": 1484.16,
      "end": 1487.2800000000002,
      "text": " It's an interesting one because Lambda is simple, SQS is simple, but they've got, they're building more and more configuration options to make it more powerful."
    },
    {
      "speakerLabel": "spk_0",
      "start": 1488.0800000000002,
      "end": 1491.6000000000001,
      "text": " So, you know, you sacrifice some of that simplicity with the power then you get."
    },
    {
      "speakerLabel": "spk_0",
      "start": 1494.16,
      "end": 1499.6000000000001,
      "text": " I think that Lambda kind of concludes a lot of the topics around SQS, but I did want to call out"
    },
    {
      "speakerLabel": "spk_0",
      "start": 1499.6,
      "end": 1505.52,
      "text": " a couple of talks that came up at reInvent last year, some really good new talks all around the"
    },
    {
      "speakerLabel": "spk_0",
      "start": 1505.52,
      "end": 1510.56,
      "text": " idea of enterprise integration patterns and message driven architectures, and it covers SQS,"
    },
    {
      "speakerLabel": "spk_0",
      "start": 1510.56,
      "end": 1513.6,
      "text": " but also all the other services that we're going to talk about in this series."
    },
    {
      "speakerLabel": "spk_0",
      "start": 1514.8,
      "end": 1519.28,
      "text": " And one of them was by Gregor Hopa, who was one of the authors of the enterprise integrations"
    },
    {
      "speakerLabel": "spk_0",
      "start": 1519.28,
      "end": 1524.24,
      "text": " patterns book, a book I read a long time ago, which is very good for understanding all the"
    },
    {
      "speakerLabel": "spk_0",
      "start": 1524.24,
      "end": 1529.52,
      "text": " different types of message driven workflows you can have in applications. So there's one by him,"
    },
    {
      "speakerLabel": "spk_0",
      "start": 1529.52,
      "end": 1534.32,
      "text": " and there's a couple of others that we're going to put in the show notes. And if people are"
    },
    {
      "speakerLabel": "spk_0",
      "start": 1534.32,
      "end": 1540.16,
      "text": " interested in event driven architectures and how you can build really powerful architectures with"
    },
    {
      "speakerLabel": "spk_0",
      "start": 1540.16,
      "end": 1544,
      "text": " very simple services without having to build a whole lot of infrastructure, I think these"
    },
    {
      "speakerLabel": "spk_0",
      "start": 1544,
      "end": 1550.32,
      "text": " are really, really worthwhile. So really strong recommendations on those. And with that, I think"
    },
    {
      "speakerLabel": "spk_0",
      "start": 1550.32,
      "end": 1556.48,
      "text": " we'll leave it for this episode, but please follow us, especially if you want to hear more about the"
    },
    {
      "speakerLabel": "spk_0",
      "start": 1556.48,
      "end": 1561.68,
      "text": " event driven architecture series, we're going to cover the SNS in the next episode. So thanks very"
    },
    {
      "speakerLabel": "spk_0",
      "start": 1561.68,
      "end": 1587.2,
      "text": " much for being with us and we'll talk to you then."
    }
  ]
}