WEBVTT

1
00:00:00.000 --> 00:00:03.760
Should I use CloudFormation or should they use Terraform instead?

2
00:00:03.760 --> 00:00:07.440
If you are just starting to do infrastructure as code, you probably have this question.

3
00:00:07.440 --> 00:00:11.040
And in today's episode, we'll try to cover these two technologies and highlight some

4
00:00:11.040 --> 00:00:16.720
similarities and differences. We will also try to give you our opinions on which one is best

5
00:00:16.720 --> 00:00:20.640
and which one you should use, but get ready for some debate because I think here we have

6
00:00:20.640 --> 00:00:25.440
a difference of opinion. My name is Luciano and today I'm joined by Eoin and this is AWS Bites

7
00:00:25.440 --> 00:00:41.120
Podcast. So let's start by maybe recapping what both CloudFormation and Terraforms are useful

8
00:00:41.120 --> 00:00:45.600
for and maybe what infrastructure as code is. What do you think there?

9
00:00:52.160 --> 00:00:57.680
When you're using infrastructure as code, what you're talking about is declaring the state of everything you want to be in AWS and you use some sort of tooling. It could be Terraform or

10
00:00:57.680 --> 00:01:02.240
CloudFormation and that tooling will perform a set of actions to get you from your current state

11
00:01:02.240 --> 00:01:06.400
into the target state that you've declared in code. And so why would you do that? Well,

12
00:01:07.280 --> 00:01:11.280
we've covered this in previous episodes, but with infrastructure as code, what you want is to

13
00:01:12.160 --> 00:01:15.920
make sure you've got a predictable deployment so you know exactly where you're coming from

14
00:01:15.920 --> 00:01:20.400
and where you're going to, and you want to get some safety around what's in there and you don't

15
00:01:20.400 --> 00:01:25.600
want to have any kind of unpredictability there. So you can do things like code review, so you can

16
00:01:25.600 --> 00:01:30.800
have pull requests on your infrastructure as code and traceability, you know, you have a branch with

17
00:01:30.800 --> 00:01:36.000
your resource code changes as well as your application code changes. So what it gives you

18
00:01:36.000 --> 00:01:40.000
is the ability to be able to deploy your infrastructure in multiple environments and make

19
00:01:40.000 --> 00:01:47.600
sure that it's exactly the same in each one. So given that, I guess, yeah, that's we could

20
00:01:47.600 --> 00:01:53.280
that we could probably go into the two tools then. So we're talking today about CloudFormation

21
00:01:53.280 --> 00:01:56.080
and Terraform. Would you like to talk about Terraform first? Yeah, I can start with Terraform.

22
00:01:56.080 --> 00:02:02.480
So Terraform is a tool that was not created by AWS, but by another company called HashiCorp.

23
00:02:03.280 --> 00:02:09.120
And basically it's, yeah, it's an open source product. So you can just go on GitHub and look

24
00:02:09.120 --> 00:02:13.600
at the source code, even contribute yourself. But of course, Terraform being a company as

25
00:02:13.600 --> 00:02:18.480
also a commercial offering and specifically in relationship to Terraform, they have something

26
00:02:18.480 --> 00:02:23.600
called Terraform Cloud and Terraform Enterprise, which are tools that allow you to automate,

27
00:02:23.600 --> 00:02:27.680
I suppose, some of the manual work that you'll need to do yourself around if you're just using

28
00:02:27.680 --> 00:02:33.920
that, the bare bone open source Terraform. It supports, of course, infrastructure as code,

29
00:02:33.920 --> 00:02:39.680
but not just for AWS, but also for many other cloud providers. And by the way, not just the

30
00:02:39.680 --> 00:02:45.440
main ones, like Google Cloud or Azure, there is a very long list and you can even support,

31
00:02:45.440 --> 00:02:51.200
I don't know, smaller DNS providers. So you can really get very granular. There is a huge variety

32
00:02:51.200 --> 00:02:55.440
of providers, I guess is the technical terminology supported by Terraform.

33
00:02:56.640 --> 00:03:02.400
One interesting thing, which is very distinctive from other tools like Terraform is that they use,

34
00:03:03.600 --> 00:03:07.600
it's not really a proprietary language, but it's something that came out of Terraform itself. So

35
00:03:07.600 --> 00:03:12.080
it's kind of a bespoke language to define infrastructure as code. And this language is

36
00:03:12.080 --> 00:03:34.360
called HCL, which stands for HashiCorp Language

37
00:03:34.360 --> 00:03:44.400
HCL. And the CLI allows you to, once you have defined your own infrastructure as code using HCL,

38
00:03:44.400 --> 00:03:50.560
allows you to create a plan, which basically means if I want to apply this particular configuration

39
00:03:50.560 --> 00:03:56.000
to remote deployment, what's going to happen? And Terraform is basically going to give you a plan of

40
00:03:56.000 --> 00:04:00.720
the different things that will change. So this is something very visible that you can see and

41
00:04:00.720 --> 00:04:05.760
decide, okay, this looks correct. At that point, you can decide to execute that plan and actually

42
00:04:05.760 --> 00:04:11.600
apply all the changes. Another interesting thing in Terraform is the concept of state.

43
00:04:11.600 --> 00:04:18.560
And by state, the way I like to think about it is basically the view that Terraform has of your

44
00:04:18.560 --> 00:04:23.760
current deployment in production or whatever other environment that is. And that is important

45
00:04:23.760 --> 00:04:29.040
because every time you need to reapply something, like you want to change resources, Terraform will

46
00:04:29.040 --> 00:04:34.560
look into the last state, the last known state, and use that to decide what to do next. So this

47
00:04:34.560 --> 00:04:38.400
is another interesting thing because basically Terraform doesn't really go into the infrastructure

48
00:04:38.400 --> 00:04:44.000
itself and try to assess the current state, but uses the previous representation of the state. So

49
00:04:44.000 --> 00:04:48.880
very careful there because if you change things manually in between, Terraform is not going to

50
00:04:48.880 --> 00:04:55.200
see your manual changes. It only remembers the last state managed by Terraform. Now, by default,

51
00:04:55.200 --> 00:05:00.000
the state is just a JSON file that ends up in your file system when you run Terraform locally.

52
00:05:00.560 --> 00:05:04.400
But of course, this is not ideal because if you're working on a team, you might want to have that

53
00:05:04.400 --> 00:05:10.080
shared so that everyone deploying will have the same view of the world. So there are ways that

54
00:05:10.080 --> 00:05:17.440
you can store that state in S3 or in DynamoDB or in some other shared storage. And this leads

55
00:05:17.440 --> 00:05:22.400
to another interesting feature of Terraform, which is we can say it's a client server model,

56
00:05:22.400 --> 00:05:28.320
where you are running these changes from a client. It could be like your own development machine,

57
00:05:28.320 --> 00:05:34.400
it could be a CI CD pipeline. But what happens is that once you try to run the CLI, the CLI itself

58
00:05:34.400 --> 00:05:40.080
will do all the changes on your infrastructure by calling AWS APIs directly. At least this is in the

59
00:05:40.080 --> 00:05:45.920
case of AWS. Of course, if you use other providers, it will interact with the APIs of those providers.

60
00:05:45.920 --> 00:05:52.000
So this is kind of the idea that Terraform will call the APIs for you as if you were calling your

61
00:05:52.000 --> 00:05:57.360
APIs directly from the CLI or maybe if you were running CLI commands against AWS.

62
00:05:58.080 --> 00:06:04.160
So just to recap, the main feature is that you can write your infrastructure as code using HCL,

63
00:06:04.160 --> 00:06:10.160
then you can plan what happens if you want to apply those changes. You can actually apply the

64
00:06:10.160 --> 00:06:15.440
changes or execute the plan. You also have rollbacks. So basically you can decide to go back

65
00:06:15.440 --> 00:06:20.240
in case something went wrong. But there are also other interesting extensibility features like

66
00:06:20.240 --> 00:06:26.480
plugins and modules that we can probably discuss a little bit more later. And you can deploy to

67
00:06:26.480 --> 00:06:32.000
multiple cloud providers. And finally, you can also query existing resources. So for instance,

68
00:06:32.000 --> 00:06:37.120
if you want to use things that are already online as part of your definition of infrastructure as

69
00:06:37.120 --> 00:06:41.120
code, like I don't know, you want to reference a bucket that was already provisioned before,

70
00:06:41.760 --> 00:06:46.560
you can do that as part of the HCL language. There are constructs that allow you to do that.

71
00:06:46.560 --> 00:06:51.360
I hope that there was a comprehensive view, but yeah, what about CloudFormation at this point?

72
00:06:53.360 --> 00:06:57.840
Yeah, I think that sets it up nicely for a comparison.

73
00:06:57.840 --> 00:07:03.760
So I would describe CloudFormation as the primary difference really is that while Terraform is a tool that operates in that client

74
00:07:03.760 --> 00:07:10.720
server mode you described, CloudFormation is an AWS service. So it has a client, but

75
00:07:11.280 --> 00:07:16.080
the main features of CloudFormation happen and the AWS managed service. And that's the fun part

76
00:07:16.080 --> 00:07:20.800
and that's the fundamental difference. And it's quite an important one as well. So what you're

77
00:07:20.800 --> 00:07:24.880
doing essentially is you're declaring the state of all of your cloud resources and you're giving

78
00:07:24.880 --> 00:07:32.000
the templates to AWS and asking AWS CloudFormation service to apply the differences for you. So it

79
00:07:32.000 --> 00:07:37.120
all happens then cloud side rather than this client server model. So in terms of how, what

80
00:07:37.120 --> 00:07:43.280
the templates look like, it uses JSON or YAML. So it's not the language that CloudFormation gives

81
00:07:43.280 --> 00:07:48.960
you out of the box is not as powerful as what you get with HCL, but there's additional tools

82
00:07:48.960 --> 00:07:54.080
you can use to overcome some of the limitations of JSON or YAML. So there's a lot of features in

83
00:07:54.080 --> 00:07:57.360
CloudFormation. It's actually growing even in the last year, we've had a lot of new features,

84
00:07:58.560 --> 00:08:02.560
but fundamentally the state in CloudFormation is stored in something called a stack. And that

85
00:08:02.560 --> 00:08:06.240
state is something that AWS manages for you. So you don't have to think about where that state is.

86
00:08:06.960 --> 00:08:09.680
So a stack is essentially a collection of resources with its own state.

87
00:08:09.680 --> 00:08:14.400
And there's also something called stack sets, which is essentially the same stack applied across

88
00:08:14.400 --> 00:08:19.440
multiple accounts or regions. You also have things like nested stacks. So you can have a hierarchy

89
00:08:19.440 --> 00:08:24.800
of CloudFormation templates. And when you mentioned Terraform plan, there's a similar idea in Cloud

90
00:08:24.800 --> 00:08:30.160
formation called a change set. So you can create a change set and that's also created on the cloud

91
00:08:30.160 --> 00:08:34.160
side. And it's essentially a list of changes that will be applied. And then you can decide whether

92
00:08:34.160 --> 00:08:40.320
to execute that change set or not. You also mentioned rollbacks. So one of the things I

93
00:08:40.320 --> 00:08:46.240
like about CloudFormation is that it has automated rollbacks. So I think about more like when you're

94
00:08:46.240 --> 00:08:50.000
interacting with a database, you've got a transaction and within that transaction, you've

95
00:08:50.000 --> 00:08:54.960
got a series of changes and a CloudFormation update is very much like a transaction. And if

96
00:08:54.960 --> 00:09:00.240
one of those updates fails, CloudFormation will manage the rollback for you. And for that reason,

97
00:09:00.240 --> 00:09:05.680
it feels safer using CloudFormation because it's kind of AWS's responsibility to fulfill that

98
00:09:05.680 --> 00:09:12.640
rollback. Recently, you actually have support for removing or disabling rollbacks in development as

99
00:09:12.640 --> 00:09:18.000
well. So that makes the development process a bit handier, a bit faster. And you also mentioned one

100
00:09:18.000 --> 00:09:23.600
of the things that can happen with any of these tools is that manual changes, people can go in and

101
00:09:23.600 --> 00:09:28.080
make changes that aren't reflected in the stored state. And one of the newer features of CloudFormation

102
00:09:28.080 --> 00:09:34.400
is drift detection. So it'll let you know and track the state of resources against the template.

103
00:09:34.400 --> 00:09:38.400
So you can see what's changed compared to that state. That can be useful. It doesn't support all

104
00:09:38.400 --> 00:09:43.520
the resource types, but I think there's a growing set. There is support for information as well for

105
00:09:43.520 --> 00:09:48.160
importing existing resources. It's not something I would like to have to do very often because it's

106
00:09:48.160 --> 00:09:53.040
a little bit of a laborious process, but it's also a reasonably new feature where if you've got some

107
00:09:53.040 --> 00:09:57.200
resources that you created manually in the console, you can kind of adopt them into your CloudFormation

108
00:09:57.200 --> 00:10:03.920
stack. There's a lot of other new features as well, like hooks. So you can execute arbitrary

109
00:10:03.920 --> 00:10:08.720
code at different stages in the deployment life cycle. And there's this kind of other stuff as

110
00:10:08.720 --> 00:10:12.240
well. Like if you've got an auto scaling group, CloudFormation integrates with that as well and

111
00:10:12.240 --> 00:10:18.400
can do rolling deployments. I think one of the kind of last features I'd call out is that

112
00:10:18.400 --> 00:10:22.880
CloudFormation gives you very good secrets management. So it's well integrated with SSM,

113
00:10:22.880 --> 00:10:28.000
parameter store for secure secrets and also secrets manager. So you don't have to pass those

114
00:10:28.800 --> 00:10:36.240
around. They can be imported securely within the cloud side, within the CloudFormation service for

115
00:10:36.240 --> 00:10:42.160
you. And again, because it's JSON or YAML, it's fairly flat and declarative and not very dynamic.

116
00:10:42.160 --> 00:10:46.640
And that can be a benefit, but also a drawback. I know in Terraform, you have like loops. You can

117
00:10:46.640 --> 00:10:51.520
do count, loops up to account, like a for loop essentially. In CloudFormation, you don't have

118
00:10:51.520 --> 00:10:55.280
loops, but you do have conditions. So you can decide whether to include something or not based

119
00:10:55.280 --> 00:10:59.360
on the value of a parameter. And that parameter could come from inputs to the template, or it

120
00:10:59.360 --> 00:11:05.200
could come from a SSM parameter for you.

121
00:11:05.200 --> 00:11:11.360
On that one, we have an article that we wrote some time ago with examples that we'll put it in the show description. Yeah, definitely. That's a good chat.

122
00:11:12.560 --> 00:11:15.840
Because it's an AWS service as well, I suppose it's worth calling out some of the integrations

123
00:11:15.840 --> 00:11:19.920
that CloudFormation already has with other AWS services. So if you're into code deploy for

124
00:11:19.920 --> 00:11:24.400
deploying to EC2 or Lambda, CloudFormation integrates well with that. So you can do rolling

125
00:11:24.400 --> 00:11:30.560
deployments there. Of course, it's integrated with IAM. So your CloudFormation actions are going to

126
00:11:30.560 --> 00:11:35.200
be done under a role that you can specify and control. And if you want to be able to deploy

127
00:11:35.200 --> 00:11:41.680
CloudFormation templates, give users the capability to deploy stuff from the console on demand,

128
00:11:41.680 --> 00:11:46.480
like if they need a bucket or whatever application you might want to deploy on demand, there's a

129
00:11:46.480 --> 00:11:50.240
service called Service Catalog that uses CloudFormation under the hood for that. So those

130
00:11:50.240 --> 00:11:55.360
are some integrations of note. And of course, you also have the tooling that's built on top of

131
00:11:55.360 --> 00:12:00.880
CloudFormation. I think I read somewhere recently that like 70% of CloudFormation is deployed using

132
00:12:00.880 --> 00:12:09.600
the serverless framework. Don't quote me on that. Something pretty high. Yeah. And AWS SAM is a

133
00:12:09.600 --> 00:12:14.640
similar tool that's also built on CloudFormation. And since we mentioned that with YAML and JSON,

134
00:12:14.640 --> 00:12:19.280
it's not very dynamic. Of course, you have the CDK, which we have covered in a previous episode

135
00:12:19.280 --> 00:12:24.720
in a lot of depth. And that's a programmatic imperative way of generating CloudFormation

136
00:12:24.720 --> 00:12:32.800
in your language of choice. There are some limitations in quotas because it's an AWS service.

137
00:12:33.760 --> 00:12:39.040
In terms of numbers, you can put 500 resources in a stack and you can have up to like 2000 stacks,

138
00:12:39.040 --> 00:12:46.160
which should be plenty for a given account. That number of resources was increased a couple of years

139
00:12:46.160 --> 00:12:52.240
ago, maybe even last year, but I've never, I definitely haven't reached the 500 resource limit

140
00:12:53.360 --> 00:12:59.120
because I tend to use small stacks. I prefer things that way. The template size itself can be

141
00:12:59.120 --> 00:13:04.240
50K, but you can put it up on S3 and then you can use a template size of up to a megabyte.

142
00:13:04.240 --> 00:13:07.680
Which considering that's- One of the other important limitations, actually,

143
00:13:07.680 --> 00:13:13.120
just to mention it quickly, is that with CloudFormation, you cannot modify a resource

144
00:13:13.120 --> 00:13:16.400
that isn't within the stack. And that's an important one to be aware of. So if you've

145
00:13:16.400 --> 00:13:22.160
got an existing bucket and you wanted to add, like previously it was quite common, you'd want to

146
00:13:22.160 --> 00:13:26.560
create an application, but you wanted it to be a Lambda function to be triggered by a notification

147
00:13:26.560 --> 00:13:31.200
in S3 bucket. If you were trying to modify the bucket's notification configuration, you couldn't

148
00:13:31.200 --> 00:13:35.840
do that in a different stack. So you had all these workarounds in serverless framework that would

149
00:13:35.840 --> 00:13:42.080
create custom resources to fulfill that for you.

150
00:13:42.080 --> 00:13:47.440
But you can also import something into a stack, right?

151
00:13:47.440 --> 00:13:51.920
Yeah, you could, you can import that, but you couldn't say have a shared bucket and then have lots of different other stacks that create notification configurations in that bucket.

152
00:13:54.720 --> 00:13:58.160
So that's it. Should we talk about some of the differences then?

153
00:13:58.160 --> 00:14:01.840
Yeah, let's try to- CloudFormation Terraform, let's try and pick a winner here.

154
00:14:01.840 --> 00:14:05.200
Let's try to summarize the differences first.

155
00:14:05.200 --> 00:14:10.720
We already mentioned some of them, but I think it's good to highlight them into a little bit more detail. So probably the first one,

156
00:14:10.720 --> 00:14:16.320
again, is that with Terraform, you have this client-side mode where everything is happening

157
00:14:16.320 --> 00:14:21.920
in the machine that uses the Terraform CLI. So that machine is responsible for calling all the

158
00:14:21.920 --> 00:14:28.080
APIs and make sure that all the changes are applied through API calls. While in CloudFormation,

159
00:14:28.080 --> 00:14:34.240
it's a managed service by AWS, you just submit your YAML or JSON, and then AWS will take care

160
00:14:34.240 --> 00:14:38.240
of applying all the changes for you. So you could even disconnect the machine at that point,

161
00:14:38.240 --> 00:14:44.960
all the changes will still go on. So in that sense, probably plus one to CloudFormation for me,

162
00:14:44.960 --> 00:14:49.760
because of course it gives you a little bit more of peace of mind because you don't have to think,

163
00:14:49.760 --> 00:14:54.800
what's going to happen to this machine while the changes are happening? So AWS will take

164
00:14:54.800 --> 00:14:59.120
care of all of that for you if you use CloudFormation. Do you agree with that?

165
00:14:59.120 --> 00:15:07.680
Yeah, I agree. It's just a managed service idea, right?

166
00:15:07.680 --> 00:15:14.800
It's taking more of the responsibility away from you, which is always a good thing in my book. I can cite Ben Quijo's tweet on the matter

167
00:15:14.800 --> 00:15:21.360
there. I know he's a big fan of CloudFormation and that Cloud-side model. I think that I stole

168
00:15:21.360 --> 00:15:27.280
that term, Cloud-side from him. But he mentioned in a tweet there, which we can link in as well

169
00:15:27.280 --> 00:15:30.240
in the show notes, he said, going from CloudFormation to Terraform because of

170
00:15:30.880 --> 00:15:35.360
CloudFormation's shortcomings is like getting frustrated with Lambda and going to Kubernetes.

171
00:15:35.360 --> 00:15:39.920
Sure, you can accomplish what you want there, but with a bigger TCO. So your total cost of ownership

172
00:15:39.920 --> 00:15:44.400
might be higher because you're adopting a tooling that isn't a managed service from the cloud

173
00:15:44.400 --> 00:15:50.400
provider. It's probably an opinionated view, but I would lean towards that side of the argument.

174
00:15:50.400 --> 00:15:54.960
Absolutely.

175
00:15:54.960 --> 00:15:59.200
And if you want something like that, I think you can use one of the commercial offerings from Ashgore. But of course, at that point, you have to pay another provider and set up that

176
00:15:59.200 --> 00:16:05.280
account and manage that account. So maybe you have less responsibility at that point, but it comes

177
00:16:05.280 --> 00:16:11.280
with the additional cost of paying the provider, but also starting to use all new tools there.

178
00:16:13.040 --> 00:16:13.920
For sure.

179
00:16:13.920 --> 00:16:17.680
Yeah.

180
00:16:17.680 --> 00:16:23.440
Another interesting thing, and again, this is maybe a little bit opinionated, that Terraform feels a little bit more modular and extensible if you want, because

181
00:16:23.440 --> 00:16:27.680
there is a concept of modules, which is literally with the same syntax you use to define,

182
00:16:28.240 --> 00:16:34.560
I suppose we can call it a stack in Terraform. You can say, this is not a stack I want to

183
00:16:34.560 --> 00:16:39.920
apply right now to an actual deployment, but it's just like a prototype. And I'm going to accept

184
00:16:39.920 --> 00:16:44.560
some generic inputs, produce some outputs, and that becomes a module that at that point you can

185
00:16:44.560 --> 00:16:50.400
import in different stacks and just provide the different inputs that are expected. And it will

186
00:16:50.400 --> 00:16:56.560
do the same things as if you were writing that same code copy-based into your actual ACL code.

187
00:16:56.560 --> 00:17:01.520
So that's a nice feature because basically by using the exact same syntax, there are very

188
00:17:01.520 --> 00:17:06.640
small differences, you get that modularity and it feels like importing functions in a programming

189
00:17:06.640 --> 00:17:11.440
language and just calling the functions. So that's something I really like from Terraform.

190
00:17:12.160 --> 00:17:17.440
But also there are other ways to extend Terraform. There is already a concept of provider. There are

191
00:17:17.440 --> 00:17:22.640
a lot of built-in providers like AWS, Azure, and all sorts of different providers. But of course,

192
00:17:22.640 --> 00:17:28.160
you can also create your own if you want to support, I don't know, any provider or any cloud

193
00:17:28.160 --> 00:17:33.600
service that is not natively supported. Or if you just want to do custom things to interact even

194
00:17:33.600 --> 00:17:38.000
with providers that are supported, but maybe using features that are not currently existing in the

195
00:17:38.000 --> 00:17:43.280
actual built-in providers. And another interesting thing that I used in the past and I think is not

196
00:17:43.280 --> 00:17:50.400
that uncommon is this idea of null resource, which is basically a way to say I'm not really defining

197
00:17:50.400 --> 00:17:56.480
a resource that Terraform itself needs to manage. It's more I want to have a hook in my provisioning

198
00:17:56.480 --> 00:18:02.160
steps to say this is kind of a virtual resource and I can define conditions like, I don't know,

199
00:18:02.160 --> 00:18:06.560
maybe when something else changes. And then with that condition, you can attach, for instance,

200
00:18:06.560 --> 00:18:12.080
a script or something else. And that way you can create mechanisms to say, okay, maybe before

201
00:18:12.080 --> 00:18:17.680
every deployment, if this particular condition happens, run a script that, I don't know, maybe

202
00:18:17.680 --> 00:18:22.720
tries to get an SSL certificate from somewhere and then use that certificate as part of your stack.

203
00:18:23.920 --> 00:18:28.640
So that's another, I suppose, easy enough way that you can create custom hooks into your

204
00:18:28.640 --> 00:18:38.560
Terraform deployments. In that term, how do we compare extensibility from Terraform to

205
00:18:38.560 --> 00:18:45.600
CloudFormation?

206
00:18:45.600 --> 00:18:50.080
Yeah, this is an interesting one because it used to be difficult when you had, if you had a gap in the supported resource types in CloudFormation, you were quite limited,

207
00:18:50.080 --> 00:18:55.680
but now there's so many options, there are almost too many. So the simplest one is probably custom

208
00:18:55.680 --> 00:19:00.960
resources where you can fairly quickly create a custom resource and you use AWS Lambda to

209
00:19:00.960 --> 00:19:06.080
fulfill the creation update or delete of that resource in your account. And that's reasonably

210
00:19:06.080 --> 00:19:11.360
straightforward to create. It can be a little bit difficult to troubleshoot, but it's fairly easy

211
00:19:11.360 --> 00:19:15.360
to get started if you find that there's a gap in functionality or you want to create something

212
00:19:15.360 --> 00:19:21.040
unique to you in CloudFormation. Now you also have support for CloudFormation modules now.

213
00:19:21.040 --> 00:19:27.520
So you can create either like a single resource or multiple resources. And it's a bit like a CDK

214
00:19:27.520 --> 00:19:33.200
construct, but you're just doing it with declarative CloudFormation. There's a new

215
00:19:33.200 --> 00:19:38.080
thing called the CloudFormation registry, where you can then register those modules publicly.

216
00:19:39.280 --> 00:19:43.760
And another thing you can put into the CloudFormation registry is a CloudFormation

217
00:19:43.760 --> 00:19:48.880
resource type. And this is where you're going all full in on creating your own CloudFormation

218
00:19:48.880 --> 00:19:54.880
resource type. And it's a much more involved process. There is some tooling, there's this

219
00:19:54.880 --> 00:19:58.720
CloudFormation command line tool that you can use to bootstrap this and to publish it to the

220
00:19:58.720 --> 00:20:04.240
CloudFormation registry. But it's essentially like you're adding a feature into CloudFormation

221
00:20:04.240 --> 00:20:09.040
properly. So it includes validation, progress updates, all of the features you get with any

222
00:20:09.040 --> 00:20:13.600
CloudFormation resource type. I believe it's the same mechanism that CloudFormation internally

223
00:20:13.600 --> 00:20:19.200
uses for creating resources. And the difference between it and CloudFormation customer resources

224
00:20:19.840 --> 00:20:27.360
is that it's not running in your own Lambda, in your own AWS account. It's running in AWS,

225
00:20:27.360 --> 00:20:32.880
in their managed service. And there's something else called CloudFormation Macros, which allows

226
00:20:32.880 --> 00:20:38.880
you to do transformations and templating essentially. So people who have used AWS Sam

227
00:20:38.880 --> 00:20:45.200
might be familiar with the serverless transform, which allows you to create a Lambda function with

228
00:20:45.200 --> 00:20:50.160
just a few lines of code that actually uses the CloudFormation macro feature under the hood.

229
00:20:50.800 --> 00:20:55.680
And there's also another popular one called CloudFormation include, which is just for doing

230
00:20:55.680 --> 00:21:01.760
includes in your templates. And that's also using macros. But if I would recommend, if anyone is

231
00:21:01.760 --> 00:21:07.520
interested in learning more about creating custom things in CloudFormation and extending

232
00:21:07.520 --> 00:21:12.960
CloudFormation support where there's missing resources, then the Cloudanaut blog, we've

233
00:21:12.960 --> 00:21:18.880
mentioned them on the podcast before. You guys know a lot about CloudFormation and they've

234
00:21:18.880 --> 00:21:22.320
created, they've a really good podcast called Three and a Half Ways to Work Around Missing

235
00:21:22.320 --> 00:21:25.840
CloudFormation Support, which talks about all this stuff and more in depth.

236
00:21:27.520 --> 00:21:34.000
Yeah. So at this point, another topic that comes to mind is what about multi-account deployments?

237
00:21:34.560 --> 00:21:40.880
Does any of these tools out of the box allow you to start a deployment that actually is

238
00:21:40.880 --> 00:21:45.200
going to deploy resources, not just in one account, but in a few different AWS accounts?

239
00:21:45.200 --> 00:21:52.640
Yeah.

240
00:21:52.640 --> 00:21:58.560
So when you talk about multiple accounts, Luciano, I guess one of the things you think about is AWS organizations and you can create an AWS organization accounts using either CloudFormation

241
00:21:58.560 --> 00:22:08.720
or, sorry, using Terraform, or you can also create them with the AWS SDK. But what I found is that

242
00:22:08.720 --> 00:22:13.200
there's quite a lot of missing support across both of these ecosystems when it comes to

243
00:22:13.200 --> 00:22:17.280
multiple accounts. Now, CloudFormation does give you stack sets. We mentioned that already.

244
00:22:17.280 --> 00:22:22.560
So you can deploy the same stack to multiple accounts, but another tool which really fills in

245
00:22:22.560 --> 00:22:29.840
all of the gaps here is organization formation or org formation. And this is just a really great

246
00:22:29.840 --> 00:22:34.480
bit of open source tooling that uses CloudFormation syntax, but extends it with lots of really,

247
00:22:34.480 --> 00:22:39.760
really great multiple account deployment capability. So it allows you to create your

248
00:22:39.760 --> 00:22:46.240
accounts, but also decide what accounts you want to, sorry, what stacks you want to deploy into

249
00:22:46.240 --> 00:22:50.320
different accounts and perform tasks in each of those accounts and manage all of your organizations

250
00:22:50.320 --> 00:22:55.520
cross account infrastructure as code. Terraform does have some support, so you can create accounts,

251
00:22:55.520 --> 00:23:01.680
like I said, but it's not as powerful as org formation. I don't think there's a really a

252
00:23:01.680 --> 00:23:06.640
good replacement for org formations, org formations capabilities. There was something called

253
00:23:06.640 --> 00:23:12.800
Controlled Terra Account Factory for Terraform. And I know that AWS and HashiCorp have put a lot

254
00:23:12.800 --> 00:23:17.920
of effort into that experience to make it easy for people to manage accounts and all the resources

255
00:23:17.920 --> 00:23:23.680
across a large organization. But I think it's still fairly new. It's been a long time in

256
00:23:23.680 --> 00:23:28.000
development and it's not yet widely adopted. So I haven't used it. I don't have personal experience

257
00:23:28.000 --> 00:23:32.560
of it. So your mileage may vary with it, but it's probably one to watch.

258
00:23:32.560 --> 00:23:37.200
Yeah, absolutely. I never had to do cross account or multi-account deployments.

259
00:23:37.760 --> 00:23:42.160
So I've seen these tools, but I never had the first-hand experience with them. So I

260
00:23:42.160 --> 00:23:47.520
wouldn't be able to compare them or give an opinion on those. Okay.

261
00:23:52.560 --> 00:23:59.040
So one of the nice things we can do actually on that topic is AWS just announced the ability to close an AWS account via an API. So it kind of opens up a lot of new possibilities for people to

262
00:23:59.040 --> 00:24:03.200
do kind of ephemeral account deployments with infrastructure as code.

263
00:24:03.200 --> 00:24:06.640
Yeah.

264
00:24:06.640 --> 00:24:12.160
Or even just to experiment with these features because you don't have to be worried about, I just created a new account just for testing out why I close it and that manual

265
00:24:12.160 --> 00:24:13.920
process. A lot of pain.

266
00:24:13.920 --> 00:24:20.880
Okay. So just to try to wrap this up. So who is the winner? Let's start with when do you use

267
00:24:20.880 --> 00:24:26.240
CloudFormesh? I'll leave this to you because you are on the CloudFormesh camp.

268
00:24:26.240 --> 00:24:31.440
Yeah. Yeah.

269
00:24:31.440 --> 00:24:36.080
The managed service aspect of it and the fact that AWS is managing your state for you is a big advantage for me. But of course that advantage only applies if you're only

270
00:24:36.080 --> 00:24:41.520
talking about AWS. So I would say use CloudFormesh if you're just talking about deployments to AWS,

271
00:24:41.520 --> 00:24:46.960
you're not dealing with multi-cloud deployments or other third-party resources. Then you'll get

272
00:24:46.960 --> 00:24:50.720
the benefit of automated rollbacks. You have lots of good tooling like the serverless framework.

273
00:24:50.720 --> 00:24:54.640
So if you're doing serverless applications, you're going to be able to do that.

274
00:24:54.640 --> 00:25:00.480
If you're doing serverless applications, I would say embrace cloud formation and one of the tools

275
00:25:00.480 --> 00:25:04.400
that allows you to build on top of it like SAM or serverless framework, it makes it a lot, lot

276
00:25:04.400 --> 00:25:12.000
easier. So I would say my decision tree for infrastructure as code is use CloudFormesh.

277
00:25:12.000 --> 00:25:16.800
If it's good tooling, obviously it depends on the organization you're working with and what

278
00:25:16.800 --> 00:25:21.040
skills people have. These are really important considerations. I'm not going to go in and try

279
00:25:21.040 --> 00:25:24.800
to convert everybody to CloudFormation if they're already using Terraform. That doesn't make sense.

280
00:25:25.360 --> 00:25:29.120
But I would have a bias towards CloudFormation, especially if you're AWS only.

281
00:25:29.680 --> 00:25:34.320
So what's the case for Terraform, the channel? Yeah.

282
00:25:34.320 --> 00:25:38.400
So at this point, I think it's clear that I'm more on the Terraform camp, even though I've been using CloudFormation more and more in the

283
00:25:38.400 --> 00:25:44.400
last few years. But I still think that Terraform gives you a little bit of a better user experience

284
00:25:44.400 --> 00:25:49.120
still today. Like, yes, it's true that you need to learn a new custom language, but also that

285
00:25:49.120 --> 00:25:54.720
custom language, I feel that gives you... It's a lot more expressive and you will not feel stuck

286
00:25:54.720 --> 00:26:00.240
about just limitations of trying to express certain concept in JSON or YAML. So I definitely

287
00:26:00.240 --> 00:26:06.240
like that. And I also like how clear it is the diff of when you do a plan in Terraform, it's

288
00:26:06.240 --> 00:26:12.000
very clear to see what's changing, what not. And also Terraform has a very good documentation and

289
00:26:12.000 --> 00:26:17.680
very good ID integration. So you get a lot of auto-complete and it's easy to figure out what

290
00:26:17.680 --> 00:26:22.960
are the right properties and resources of what you're trying to do. So in general, and of course,

291
00:26:22.960 --> 00:26:28.000
this is opinionated, feel free to call me out if you think otherwise, I had a better user experience

292
00:26:28.000 --> 00:26:34.080
by using Terraform rather than CloudFormation. So that's maybe one data point to keep in mind.

293
00:26:34.080 --> 00:26:37.760
But of course, if you are a company that is already heavily invested in Terraform,

294
00:26:38.560 --> 00:26:42.800
go with that. You don't need to change just because you think CloudFormation could be better.

295
00:26:42.800 --> 00:26:49.360
They are almost the same to some extent. The only win that I'm going to give to CloudFormation is

296
00:26:49.360 --> 00:26:54.480
that with Terraform, you are a little bit on your own in figuring out how to manage deployment,

297
00:26:54.480 --> 00:26:58.640
meaning which machine is going to actually do the deployment and where are you going to keep the

298
00:26:58.640 --> 00:27:03.520
state so that it's consistent across deployments. And that it's always a little bit of a pain, but

299
00:27:04.480 --> 00:27:09.920
there are ways to automate all of that through CI-CD and by keeping the state in shared places

300
00:27:09.920 --> 00:27:16.400
like S3, Dynamo or other shared storages. And of course, one final point in favor of Terraform

301
00:27:16.400 --> 00:27:21.600
is that if you are building applications and those applications need to live in different

302
00:27:21.600 --> 00:27:27.280
cloud providers, or maybe your application uses resources in different cloud providers,

303
00:27:27.280 --> 00:27:31.760
Terraform can give you a lot more control there because it supports out of the box a bunch of

304
00:27:31.760 --> 00:27:36.720
different cloud providers. Now, that doesn't mean that it's doing some magic translation for you.

305
00:27:36.720 --> 00:27:42.720
You still need to explicitly say, I want to use this resource with this provider. So if you use,

306
00:27:42.720 --> 00:27:46.640
I don't know, an Azure function compared to a Lambda, there isn't any abstraction for you,

307
00:27:46.640 --> 00:27:51.200
but you can reuse the same HGL syntax and the same Terraform concept to provision both.

308
00:27:52.000 --> 00:27:55.360
It's going to be different code, but you have the same user experience.

309
00:27:56.880 --> 00:28:02.000
I hope that that summarizes my opinion and maybe to finish off with this episode,

310
00:28:02.000 --> 00:28:06.240
what we can do is give a quick mention to other tools that I personally haven't used,

311
00:28:06.240 --> 00:28:11.760
but I've heard them coming up more and more in conversation. And I think the main one is Pulumi,

312
00:28:11.760 --> 00:28:19.200
which is kind of a crossover between CDK and Terraform. And by that, I mean that it's like

313
00:28:19.200 --> 00:28:24.000
CDK, meaning that you use programming languages to actually define that infrastructure as code.

314
00:28:24.000 --> 00:28:28.720
So you get something a lot more dynamic and well integrated with your idea of choice.

315
00:28:28.720 --> 00:28:33.600
You don't need to learn a new language, but at the same time, it's multi-cloud. So where CDK

316
00:28:33.600 --> 00:28:39.280
is targeting only AWS, in quotes, because I think that that's going to be changing in the near

317
00:28:39.280 --> 00:28:45.600
future, but right now is really well-built only for AWS. Pulumi is already aiming to target a

318
00:28:45.600 --> 00:28:51.280
bunch of different cloud providers. And we already mentioned CDK as an alternative, but also SAM

319
00:28:51.280 --> 00:28:55.600
and serverless, which are built on top of cloud formation. So sometimes it can be convenient for

320
00:28:55.600 --> 00:29:00.720
you to use these higher level abstractions rather than just going straight to cloud formation, which

321
00:29:00.720 --> 00:29:05.440
might be a lot more lower level and verbose than using these other tools.

322
00:29:06.960 --> 00:29:11.440
And I think that concludes this episode. Do you have any final remark, Eoin?

323
00:29:14.880 --> 00:29:19.360
I guess I'm really interested to hear what people think of it. And if we've got any

324
00:29:19.360 --> 00:29:25.360
strongly held opinions that cite any reasons for using one over the other, we haven't covered here.

325
00:29:25.360 --> 00:29:29.200
Because it does tend to be a battle of camps sometimes when you're discussing cloud formation

326
00:29:29.200 --> 00:29:33.360
versus Terraform. I think the main thing is that you use infrastructure as code. If you're doing,

327
00:29:33.360 --> 00:29:37.520
no matter what tool you're using, you're already in a good place if you have infrastructure as code.

328
00:29:37.520 --> 00:29:42.720
And if not, it's time to pick one and move forward. Yeah.

329
00:29:42.720 --> 00:29:47.120
And I'm also really curious to know if there is any other tool, maybe something older that I haven't seen, or maybe something really, really

330
00:29:47.120 --> 00:29:51.840
new that we haven't seen yet. So definitely let us know if there is any other tool that you think

331
00:29:51.840 --> 00:29:57.200
should be part of this type of conversation and people should consider. So thank you very much

332
00:29:57.200 --> 00:30:02.480
for following and please give us a thumbs up, a like, share, whatever, if you are getting value

333
00:30:02.480 --> 00:30:30.320
from this episode. See you the next time.
