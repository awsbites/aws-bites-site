WEBVTT

1
00:00:00.000 --> 00:00:03.400
When it comes to choosing compute services on AWS,

2
00:00:03.400 --> 00:00:08.400
there are a lot of options including EC2, ECS, Lambda, EKS,

3
00:00:09.300 --> 00:00:11.480
and new ones keep emerging all the time.

4
00:00:11.480 --> 00:00:13.360
So selecting the right one for each application

5
00:00:13.360 --> 00:00:14.980
is no longer an easy choice.

6
00:00:14.980 --> 00:00:16.960
So today we want to talk about

7
00:00:16.960 --> 00:00:18.100
why do you need compute services

8
00:00:18.100 --> 00:00:18.960
and what kind of problems

9
00:00:18.960 --> 00:00:20.300
should you actually be offloading

10
00:00:20.300 --> 00:00:22.140
to something else entirely?

11
00:00:22.140 --> 00:00:24.280
We're gonna talk about creating a methodology

12
00:00:24.280 --> 00:00:28.260
to make the selection process easier and less biased.

13
00:00:28.260 --> 00:00:30.320
We'll talk about the different compute options available

14
00:00:30.320 --> 00:00:33.860
in AWS and we'll give some example use cases

15
00:00:33.860 --> 00:00:36.520
and how you make the right choice in each case.

16
00:00:36.520 --> 00:00:38.960
My name is Eoin, I'm joined by Luciano

17
00:00:38.960 --> 00:00:41.620
and this is the AWS Bites podcast.

18
00:00:41.620 --> 00:00:46.620
In the previous episode,

19
00:00:49.800 --> 00:00:52.160
we talked about migrating a monolith to AWS.

20
00:00:52.160 --> 00:00:54.480
And in that case, we talked about considering data,

21
00:00:54.480 --> 00:00:56.200
compute and networking.

22
00:00:56.200 --> 00:00:58.080
For compute in that case, we chose EC2

23
00:00:58.080 --> 00:01:00.040
because it made sense for the team.

24
00:01:00.040 --> 00:01:02.440
This time we want to talk about different options for compute

25
00:01:02.440 --> 00:01:04.520
and how to have a system for choosing one over the other

26
00:01:04.520 --> 00:01:05.760
in different use cases.

27
00:01:05.760 --> 00:01:07.760
But we should probably start with the basics.

28
00:01:07.760 --> 00:01:09.380
It might seem obvious Luciano,

29
00:01:09.380 --> 00:01:11.440
but what do we mean when we say compute?

30
00:01:12.340 --> 00:01:14.440
Yeah, I think it's actually not obvious at all.

31
00:01:14.440 --> 00:01:17.800
I think historically I will describe compute

32
00:01:17.800 --> 00:01:19.680
as you get a virtual machine

33
00:01:19.680 --> 00:01:21.760
and you can do whatever you want with it.

34
00:01:21.760 --> 00:01:24.540
And that's used to be literally everything

35
00:01:24.540 --> 00:01:27.040
from your application code,

36
00:01:27.040 --> 00:01:30.240
like maybe a web server or even a database

37
00:01:30.240 --> 00:01:33.840
or even an event bus and everything,

38
00:01:33.840 --> 00:01:35.520
including services and business logic,

39
00:01:35.520 --> 00:01:38.000
we're living together in this one virtual machine.

40
00:01:38.000 --> 00:01:41.600
So I would describe that as a compute layer of its own.

41
00:01:42.680 --> 00:01:43.680
But I don't know,

42
00:01:43.680 --> 00:01:45.520
if we want to be a little bit more specific,

43
00:01:45.520 --> 00:01:49.320
maybe we can try to isolate the everything else

44
00:01:49.320 --> 00:01:52.000
and focus more on actual business logic.

45
00:01:52.000 --> 00:01:55.480
So what do we mean in general by business logic?

46
00:01:55.480 --> 00:01:58.000
And there are different use cases that we should consider.

47
00:01:58.000 --> 00:01:59.400
For instance, I don't know,

48
00:01:59.400 --> 00:02:01.320
if you have to run specific algorithms

49
00:02:01.320 --> 00:02:03.000
or if you have differentiating,

50
00:02:04.760 --> 00:02:07.400
parts of your businesses require custom code to be run

51
00:02:07.400 --> 00:02:09.240
to actually make something happen.

52
00:02:09.240 --> 00:02:11.440
This is definitely one category that we can describe

53
00:02:11.440 --> 00:02:14.200
as something that can be fulfilled with compute.

54
00:02:16.080 --> 00:02:18.780
Other common things are when you need to run,

55
00:02:18.780 --> 00:02:23.340
for instance, control flow or some sort of orchestration.

56
00:02:23.340 --> 00:02:25.880
So you basically have some data maybe coming in

57
00:02:25.880 --> 00:02:28.120
and you need to decide what to do with that data

58
00:02:28.120 --> 00:02:31.960
and then produce some output based on rules of some sort.

59
00:02:31.960 --> 00:02:33.760
That's definitely another category

60
00:02:33.760 --> 00:02:35.440
where you can have a compute layer

61
00:02:35.440 --> 00:02:38.520
that is dedicated to that particular kind of use case.

62
00:02:38.520 --> 00:02:41.180
And very similarly, there is a concept of integration.

63
00:02:41.180 --> 00:02:43.520
So maybe you are trying to connect to different systems,

64
00:02:43.520 --> 00:02:45.560
maybe using different types of APIs.

65
00:02:45.560 --> 00:02:47.400
And again, that might be something event-based.

66
00:02:47.400 --> 00:02:50.120
So an event comes in, you need to deal with that event

67
00:02:50.120 --> 00:02:53.200
maybe by sending the data to another system

68
00:02:53.200 --> 00:02:55.480
and this way you can connect multiple parts

69
00:02:55.480 --> 00:02:57.240
of your application.

70
00:02:57.240 --> 00:03:00.240
And finally, another interesting use case is data access,

71
00:03:00.240 --> 00:03:03.240
which is the idea that you might have a data layer

72
00:03:03.240 --> 00:03:05.640
and you need to run specific code

73
00:03:05.640 --> 00:03:08.280
to allow the access to that data layer.

74
00:03:08.280 --> 00:03:09.600
And you can imagine, I don't know,

75
00:03:09.600 --> 00:03:10.940
if you have a web application,

76
00:03:10.940 --> 00:03:13.080
maybe you have an ORM layer that allows you

77
00:03:13.080 --> 00:03:15.740
to execute query against the database.

78
00:03:16.840 --> 00:03:19.000
That can be transactional or not,

79
00:03:19.000 --> 00:03:23.840
or you can have other maybe background processes

80
00:03:23.840 --> 00:03:26.760
where you use them to do like data gathering,

81
00:03:26.760 --> 00:03:29.120
data mining, or even data processing.

82
00:03:29.120 --> 00:03:30.960
Like for instance, if you have big data workloads

83
00:03:30.960 --> 00:03:34.280
and you need to enrich data, manipulate data.

84
00:03:34.280 --> 00:03:37.400
So in all these cases, you can find, I suppose,

85
00:03:37.400 --> 00:03:39.560
some degree of compute.

86
00:03:39.560 --> 00:03:41.300
And the idea is again,

87
00:03:41.300 --> 00:03:44.720
that your business will have certain needs

88
00:03:44.720 --> 00:03:46.640
and to express all these needs,

89
00:03:46.640 --> 00:03:48.520
you probably need to write some code

90
00:03:48.520 --> 00:03:51.520
and this code needs to run somewhere to satisfy those needs.

91
00:03:52.440 --> 00:03:54.560
The interesting thing is that I have a feeling

92
00:03:54.560 --> 00:03:57.160
that in modern architectures,

93
00:03:57.160 --> 00:03:58.560
especially if we think more and more

94
00:03:58.560 --> 00:04:00.320
about the concept of serverless

95
00:04:00.320 --> 00:04:03.620
or the concept of low code architectures,

96
00:04:03.620 --> 00:04:07.720
it feels like there is a goal of trying to reduce

97
00:04:07.720 --> 00:04:10.680
that level of custom compute as much as possible.

98
00:04:12.260 --> 00:04:16.320
And the alternative is to use services that are managed

99
00:04:16.320 --> 00:04:18.880
and given to you by some third-party provider

100
00:04:18.880 --> 00:04:22.080
like AWS or other cloud vendors.

101
00:04:22.080 --> 00:04:23.760
I don't know if you agree with this view,

102
00:04:23.760 --> 00:04:26.900
but this is like what I feel about where the world is going.

103
00:04:28.260 --> 00:04:29.720
That's definitely the direction of travel.

104
00:04:29.720 --> 00:04:32.800
Yeah, this whole, if you ask what does serverless mean,

105
00:04:32.800 --> 00:04:34.760
it's not about functions or Lambda really,

106
00:04:34.760 --> 00:04:38.600
it's about removing compute as much as possible.

107
00:04:38.600 --> 00:04:40.640
And do you even have people using this term,

108
00:04:40.640 --> 00:04:43.360
service, serverless service full applications now

109
00:04:43.360 --> 00:04:46.240
where you're talking about composing really

110
00:04:46.240 --> 00:04:47.200
just doing integrations

111
00:04:47.200 --> 00:04:49.280
and composing these third-party services together

112
00:04:49.280 --> 00:04:50.860
and trying to remove that code.

113
00:04:50.860 --> 00:04:53.200
I think it's a good practice actually.

114
00:04:53.200 --> 00:04:56.540
So in an AWS context, maybe some examples of that

115
00:04:56.540 --> 00:04:59.280
would be using step functions for orchestration

116
00:04:59.280 --> 00:05:01.840
instead of imperative reams of code

117
00:05:01.840 --> 00:05:03.760
and trying to figure out how do you handle errors?

118
00:05:03.760 --> 00:05:05.240
How do you handle the delays?

119
00:05:05.240 --> 00:05:07.880
How do you handle back off and retry

120
00:05:07.880 --> 00:05:10.580
and circuit breakers and all that stuff?

121
00:05:10.580 --> 00:05:13.760
So now you don't need Lambda for a lot of those things

122
00:05:13.760 --> 00:05:14.660
and step functions even.

123
00:05:14.660 --> 00:05:17.240
So you can do direct SDK integrations

124
00:05:17.240 --> 00:05:19.960
and talk to SQS or EventBridge or S3

125
00:05:19.960 --> 00:05:21.880
directly from step function states.

126
00:05:21.880 --> 00:05:23.940
So you can see the potential to remove

127
00:05:24.840 --> 00:05:26.920
traditional imperative code running in a function

128
00:05:26.920 --> 00:05:30.360
or on a container is getting better all the time.

129
00:05:30.360 --> 00:05:31.320
Then you also have other examples

130
00:05:31.320 --> 00:05:33.600
like when you're integrating things together,

131
00:05:33.600 --> 00:05:36.640
you can use event services like EventBridge, SQS,

132
00:05:36.640 --> 00:05:38.760
SNS, Kinesis, and you can combine them

133
00:05:38.760 --> 00:05:40.380
with API Gateway or AppSync.

134
00:05:40.380 --> 00:05:43.040
So you can integrate APIs inbound

135
00:05:43.040 --> 00:05:45.360
and also third-party webhooks together

136
00:05:45.360 --> 00:05:47.120
without having to write a lot of custom logic.

137
00:05:47.120 --> 00:05:49.640
Yeah, it's interesting that some of the services

138
00:05:49.640 --> 00:05:51.640
you mentioned, like in the last few years,

139
00:05:51.640 --> 00:05:53.440
we have seen more and more features

140
00:05:53.440 --> 00:05:55.240
that actually looks like they're trying

141
00:05:55.240 --> 00:05:56.640
to reduce the amount of custom code,

142
00:05:56.640 --> 00:05:59.200
like the opportunity to filter certain type of events

143
00:05:59.200 --> 00:06:01.040
or to remap the structure of an event

144
00:06:01.040 --> 00:06:02.940
before it's forwarded somewhere else.

145
00:06:02.940 --> 00:06:04.840
Like you can do today all this stuff

146
00:06:04.840 --> 00:06:06.840
with just configuration rather than writing

147
00:06:06.840 --> 00:06:10.320
your own custom code that takes the data as an input,

148
00:06:10.320 --> 00:06:12.360
change the data, and send it back somewhere else.

149
00:06:12.360 --> 00:06:14.720
I was just about to mention AppSync and API Gateway

150
00:06:14.720 --> 00:06:17.160
and directly integrating with DynamoDB

151
00:06:17.160 --> 00:06:19.680
or other backend services or APIs.

152
00:06:19.680 --> 00:06:20.880
And exactly, you could do that.

153
00:06:20.880 --> 00:06:23.840
You can use input transformers for some services

154
00:06:23.840 --> 00:06:25.120
or with AppSync and API Gateway,

155
00:06:25.120 --> 00:06:27.880
you can use a lot of VTL velocity language

156
00:06:27.880 --> 00:06:29.400
to do those mappings.

157
00:06:29.400 --> 00:06:30.840
And it really becomes then a choice of,

158
00:06:30.840 --> 00:06:33.880
do you want to use VTL or do you want to use Lambda

159
00:06:33.880 --> 00:06:35.120
for that translation there?

160
00:06:35.120 --> 00:06:37.280
And in that case, you're just using Lambda

161
00:06:37.280 --> 00:06:41.400
as a slightly more powerful data transformation there

162
00:06:41.400 --> 00:06:43.720
in some cases using the language of your choice.

163
00:06:43.720 --> 00:06:46.400
So it's less compute and more data transformation.

164
00:06:46.400 --> 00:06:48.960
Yeah, this kind of architecture can be very beneficial.

165
00:06:48.960 --> 00:06:50.280
It can remove a lot of effort.

166
00:06:50.280 --> 00:06:52.440
It can push a lot more responsibility to AWS

167
00:06:52.440 --> 00:06:55.360
or someone else, but it does require like specific skills.

168
00:06:55.360 --> 00:06:56.480
We've mentioned this before.

169
00:06:56.480 --> 00:06:57.940
There is a mindset shift.

170
00:06:57.940 --> 00:07:00.060
It's not as suitable for everybody.

171
00:07:00.060 --> 00:07:01.760
And you also might have existing software

172
00:07:01.760 --> 00:07:03.960
that relies on specific containers, sorry,

173
00:07:03.960 --> 00:07:07.080
specific frameworks running in containers or on instances.

174
00:07:07.080 --> 00:07:09.920
So we can't pretend that this is the way everybody

175
00:07:09.920 --> 00:07:11.360
should be going right now.

176
00:07:12.280 --> 00:07:13.760
So it's not always a simple choice

177
00:07:13.760 --> 00:07:15.160
and it depends on your context.

178
00:07:15.160 --> 00:07:17.600
So I think what we'd recommend is having

179
00:07:17.600 --> 00:07:21.200
a technology selection methodology to help your team

180
00:07:21.200 --> 00:07:23.160
or your organization choose a good solution

181
00:07:23.160 --> 00:07:24.880
depending on each context.

182
00:07:24.880 --> 00:07:27.760
Yeah, I think I agree because it's,

183
00:07:27.760 --> 00:07:30.400
I think there are two extreme scenarios.

184
00:07:30.400 --> 00:07:32.680
One is that you always stick with what you know,

185
00:07:32.680 --> 00:07:34.520
and then there is the kind of no evolution.

186
00:07:34.520 --> 00:07:37.580
And then eventually you will have a huge technical depth

187
00:07:37.580 --> 00:07:40.280
and it's very hard to move on from there.

188
00:07:40.280 --> 00:07:42.560
The other opposite extreme is when you always try

189
00:07:42.560 --> 00:07:46.280
to the newest shiny things, just because you want to have fun

190
00:07:46.280 --> 00:07:47.920
and you want to try the new things.

191
00:07:47.920 --> 00:07:49.400
And maybe you end up in situations

192
00:07:49.400 --> 00:07:51.840
where you rely on technology that is gonna fade away

193
00:07:51.840 --> 00:07:54.360
because maybe there wasn't enough adoption

194
00:07:54.360 --> 00:07:57.440
as was initially expected, or maybe you run into cases

195
00:07:57.440 --> 00:07:59.720
where there isn't a lot of documentation and community

196
00:07:59.720 --> 00:08:00.960
and use cases and examples.

197
00:08:00.960 --> 00:08:04.240
So you are left on your own to really reinvent the wheel

198
00:08:04.240 --> 00:08:05.880
with this new technology.

199
00:08:05.880 --> 00:08:08.360
So I think those are two very extreme use cases.

200
00:08:08.360 --> 00:08:11.320
So we need to find, I suppose, a balance

201
00:08:11.320 --> 00:08:16.320
between those two extreme cases and having like a methodology

202
00:08:16.660 --> 00:08:19.000
that you can rely on and is somewhat objective,

203
00:08:19.000 --> 00:08:21.120
I think can be very beneficial for a team

204
00:08:21.120 --> 00:08:23.480
to find the right trade off for them.

205
00:08:23.480 --> 00:08:26.800
Yeah, I think we can maybe mention a few pillars there.

206
00:08:26.800 --> 00:08:29.920
I don't know if we will come up with a very like

207
00:08:29.920 --> 00:08:32.520
step-by-step methodology, but I think we can give people

208
00:08:32.520 --> 00:08:35.100
insights on how to build their own methodology,

209
00:08:35.100 --> 00:08:37.600
maybe better than some common ideas.

210
00:08:37.600 --> 00:08:38.880
We can all be very emotional

211
00:08:38.880 --> 00:08:40.720
when making technology decisions.

212
00:08:40.720 --> 00:08:42.040
And when you have a group of large people

213
00:08:42.040 --> 00:08:43.480
with different perspectives,

214
00:08:43.480 --> 00:08:47.600
it can become sometimes even bitter or suboptimal

215
00:08:47.600 --> 00:08:50.480
or you end up with some regrets or feelings

216
00:08:50.480 --> 00:08:55.040
of somebody else forced their way in technology selection.

217
00:08:55.040 --> 00:08:56.900
But you also just want to, for your own benefit,

218
00:08:56.900 --> 00:08:58.880
remove your own biases.

219
00:08:58.880 --> 00:09:01.520
So I think having the idea of having a methodology

220
00:09:01.520 --> 00:09:03.960
is great just for removing that and allowing everybody

221
00:09:03.960 --> 00:09:06.360
to move on together with a sense of shared consensus

222
00:09:06.360 --> 00:09:08.520
and that you've made a good decision for everybody.

223
00:09:08.520 --> 00:09:10.920
Yeah, I actually hate when in some companies

224
00:09:10.920 --> 00:09:13.200
there is a phrase that comes up that is,

225
00:09:13.200 --> 00:09:16.880
we are a company, technology X, like no matter what,

226
00:09:16.880 --> 00:09:20.040
we always use technology X, like we intentionally committed

227
00:09:20.040 --> 00:09:22.000
to use this technology forever.

228
00:09:22.000 --> 00:09:24.200
And I think that can have its own benefits

229
00:09:24.200 --> 00:09:25.640
because maybe you structure training

230
00:09:25.640 --> 00:09:27.460
and hiring around that technology,

231
00:09:27.460 --> 00:09:28.620
but at the same time in the long run

232
00:09:28.620 --> 00:09:31.640
can become very dangerous because it kind of blocks

233
00:09:31.640 --> 00:09:34.760
any opportunity for evolving the combat itself,

234
00:09:34.760 --> 00:09:37.920
the technology, maybe leveraging some new opportunities

235
00:09:37.920 --> 00:09:39.960
that are available in the market.

236
00:09:39.960 --> 00:09:43.000
So that's another case where you can be emotional

237
00:09:43.000 --> 00:09:47.120
in a dangerous way and maybe lose opportunities

238
00:09:47.120 --> 00:09:49.320
to do something different that can be more beneficial

239
00:09:49.320 --> 00:09:50.240
for your business.

240
00:09:50.240 --> 00:09:51.720
So where do we start?

241
00:09:51.720 --> 00:09:54.360
What kind of suggestions can we give to people

242
00:09:54.360 --> 00:09:56.040
for building this methodology?

243
00:09:56.040 --> 00:09:57.680
So I've done this a few different times

244
00:09:57.680 --> 00:10:00.520
and different times I kind of adjust the selection criteria,

245
00:10:00.520 --> 00:10:03.320
but the one I always include is try to put in place

246
00:10:03.320 --> 00:10:04.760
a measure of simplicity.

247
00:10:04.760 --> 00:10:06.040
And this can be a difficult one,

248
00:10:06.040 --> 00:10:07.240
but it's really the number one factor.

249
00:10:07.240 --> 00:10:08.840
And the idea is that you don't end up

250
00:10:08.840 --> 00:10:12.240
with lots of unnecessary complexity that's hard to foresee.

251
00:10:12.240 --> 00:10:14.720
So you think about shifting more of the responsibility

252
00:10:14.720 --> 00:10:17.780
to your vendor and away from your team.

253
00:10:17.780 --> 00:10:21.040
So there's different like operational complexity,

254
00:10:21.040 --> 00:10:23.780
difficult troubleshooting, but it's up to you

255
00:10:23.780 --> 00:10:26.420
to kind of define what the criteria for simplicity are.

256
00:10:26.420 --> 00:10:27.840
But simplicity is a really big one, right?

257
00:10:27.840 --> 00:10:30.600
Because any small piece of complexity

258
00:10:30.600 --> 00:10:32.760
will be compounded over time as you go into production

259
00:10:32.760 --> 00:10:34.120
and the rubber hits the road.

260
00:10:34.120 --> 00:10:37.400
So simplicity is always a good one to try and score.

261
00:10:37.400 --> 00:10:40.060
Another one is like a lot more practical and quantitative,

262
00:10:40.060 --> 00:10:41.840
which is performance and scalability.

263
00:10:41.840 --> 00:10:46.200
So I find this is something that people either overthink

264
00:10:46.200 --> 00:10:48.080
in the beginning, like overestimating

265
00:10:48.080 --> 00:10:49.920
the performance characteristics they need

266
00:10:49.920 --> 00:10:52.200
or else they dismiss it entirely until it's too late.

267
00:10:52.200 --> 00:10:53.740
There's never a happy ground.

268
00:10:53.740 --> 00:10:56.080
But you can also, you can very quickly

269
00:10:56.080 --> 00:10:58.320
just put some numbers together on what your usage

270
00:10:58.320 --> 00:11:00.920
is expected to be like based on historical data

271
00:11:00.920 --> 00:11:03.760
or market data or whatever your growth projections are,

272
00:11:03.760 --> 00:11:04.880
put in some performance criteria

273
00:11:04.880 --> 00:11:06.840
and just use that for your, to make sure,

274
00:11:06.840 --> 00:11:09.680
does the service I'm choosing fit within that?

275
00:11:09.680 --> 00:11:11.680
And then it makes it a very easy decision.

276
00:11:12.800 --> 00:11:15.840
Yeah, it needs to be more of a sanity check, I suppose,

277
00:11:15.840 --> 00:11:19.120
rather than, I don't know, artificial goals

278
00:11:19.120 --> 00:11:21.080
that you want to achieve just to prove

279
00:11:21.080 --> 00:11:22.880
that that technology is the best one.

280
00:11:22.880 --> 00:11:23.780
Yeah, for sure.

281
00:11:23.780 --> 00:11:25.080
And remember as well, that this is something

282
00:11:25.080 --> 00:11:26.920
you can revisit over time.

283
00:11:26.920 --> 00:11:29.840
Because you expect your architecture to evolve

284
00:11:29.840 --> 00:11:32.600
and your compute options can change as well over time.

285
00:11:32.600 --> 00:11:34.920
And this is another reason to go with the simple option,

286
00:11:34.920 --> 00:11:37.680
because simplicity often implies what I think

287
00:11:37.680 --> 00:11:40.000
Werner Fokkel's once called evolvability,

288
00:11:40.000 --> 00:11:41.580
which is that if you don't have a lot,

289
00:11:41.580 --> 00:11:42.600
if it's a simple service,

290
00:11:42.600 --> 00:11:44.660
you don't have a lot of upfront investment in it.

291
00:11:44.660 --> 00:11:46.600
So you can actually back out and reverse the decision

292
00:11:46.600 --> 00:11:48.980
very quickly as well, and it doesn't hurt you very much.

293
00:11:48.980 --> 00:11:51.240
So a couple of other criteria you could put

294
00:11:51.240 --> 00:11:53.640
in your methodology are like reliability,

295
00:11:53.640 --> 00:11:55.440
resilience and security.

296
00:11:55.440 --> 00:11:57.400
Again, going with managed services should help you there,

297
00:11:57.400 --> 00:12:00.480
but you should try and have a measure of that.

298
00:12:00.480 --> 00:12:02.720
Some of the less quantitative ones

299
00:12:02.720 --> 00:12:04.440
are like developer experience.

300
00:12:04.440 --> 00:12:06.440
So that's a really important one.

301
00:12:06.440 --> 00:12:08.220
We often think about how,

302
00:12:08.220 --> 00:12:10.020
look at how things will work in production,

303
00:12:10.020 --> 00:12:12.080
but we forget that most of the time developers

304
00:12:12.080 --> 00:12:14.080
are working on the development environment,

305
00:12:14.080 --> 00:12:15.440
not the production environment.

306
00:12:15.440 --> 00:12:17.960
So how easy it is to get your development environment

307
00:12:17.960 --> 00:12:19.920
up and running, onboarding new developers,

308
00:12:19.920 --> 00:12:21.180
all of that is really important.

309
00:12:21.180 --> 00:12:23.720
Do you have any other ideas for some other factors

310
00:12:23.720 --> 00:12:26.260
we can include in this selection methodology?

311
00:12:26.260 --> 00:12:31.260
Yeah, one that I will suggest is like skills related to,

312
00:12:32.120 --> 00:12:35.720
like how does what you know already in your team

313
00:12:35.720 --> 00:12:39.200
helps you to adopt a specific compute layer, right?

314
00:12:39.200 --> 00:12:41.040
Do you need to learn something entirely new

315
00:12:41.040 --> 00:12:44.760
or the model that is being offered

316
00:12:44.760 --> 00:12:46.160
with that particular compute layer

317
00:12:46.160 --> 00:12:48.460
actually fits very well your current skills?

318
00:12:48.460 --> 00:12:50.180
So this is something that you need to keep in mind,

319
00:12:50.180 --> 00:12:51.960
because of course, if you need to learn a lot,

320
00:12:51.960 --> 00:12:56.320
that means time invested in giving people,

321
00:12:56.320 --> 00:12:58.640
I don't know, space to learn and experiment,

322
00:12:58.640 --> 00:13:01.720
and also to fail, because probably you're gonna be

323
00:13:01.720 --> 00:13:02.960
doing something wrong at the beginning

324
00:13:02.960 --> 00:13:04.240
before you learn all the patterns

325
00:13:04.240 --> 00:13:06.640
and all the right ways of using the technology.

326
00:13:06.640 --> 00:13:09.000
So all the stuff is something you need to account for

327
00:13:09.000 --> 00:13:11.080
if you're going to learn something new.

328
00:13:11.080 --> 00:13:14.560
So it might not always be desirable to do that

329
00:13:14.560 --> 00:13:17.120
if you maybe have very strict timelines,

330
00:13:17.120 --> 00:13:19.400
or maybe if you don't necessarily need

331
00:13:19.400 --> 00:13:22.600
the characteristic of a specific compute layer.

332
00:13:22.600 --> 00:13:24.740
So that's a good trade off to keep in mind.

333
00:13:24.740 --> 00:13:27.880
The other one is cost, because of course,

334
00:13:27.880 --> 00:13:30.440
it's another dimension that is always worth considering.

335
00:13:30.440 --> 00:13:33.340
Different services have very different cost factors,

336
00:13:33.340 --> 00:13:35.740
even different cost formulas if you want.

337
00:13:35.740 --> 00:13:38.840
So depending on how you intend to use that service,

338
00:13:38.840 --> 00:13:41.240
it might be much more convenient for you to use

339
00:13:41.240 --> 00:13:43.240
one or another compute service.

340
00:13:43.240 --> 00:13:46.680
So keep in mind, again, maybe take some figure,

341
00:13:46.680 --> 00:13:51.160
use it on your expected use cases, historical data,

342
00:13:51.160 --> 00:13:53.720
whatever you can think of in terms of giving you

343
00:13:53.720 --> 00:13:55.960
a guarantee that you know what's gonna be

344
00:13:55.960 --> 00:13:58.280
the trajectory of your usage,

345
00:13:58.280 --> 00:14:00.760
and try to put some data in and figure out,

346
00:14:00.760 --> 00:14:03.320
okay, how much more expensive is this solution

347
00:14:03.320 --> 00:14:05.280
going to be compared to this other one,

348
00:14:05.280 --> 00:14:08.080
and try to evaluate on that metric as well.

349
00:14:08.080 --> 00:14:10.040
These criteria are beginning to sound like

350
00:14:10.040 --> 00:14:12.300
list of pillars from the well-architected framework,

351
00:14:12.300 --> 00:14:14.080
with like some of the softer ones added in,

352
00:14:14.080 --> 00:14:17.600
like developer experience and skills suitability

353
00:14:17.600 --> 00:14:18.440
for your team.

354
00:14:18.440 --> 00:14:19.760
Yeah, the other one I wanted to mention,

355
00:14:19.760 --> 00:14:21.680
you kind of mentioned it already to some extent,

356
00:14:21.680 --> 00:14:25.080
is the ease of deployment, which is more like

357
00:14:25.080 --> 00:14:27.600
how much effort is gonna require you to actually

358
00:14:27.600 --> 00:14:29.840
put something in production, and then once it's

359
00:14:29.840 --> 00:14:32.520
in production, to keep it running,

360
00:14:32.520 --> 00:14:34.240
and every time you need to do updates,

361
00:14:34.240 --> 00:14:36.080
make sure you are in a position that it's easy enough

362
00:14:36.080 --> 00:14:37.960
for you to update the system.

363
00:14:37.960 --> 00:14:41.460
So that's another metric that is definitely worth considering

364
00:14:41.460 --> 00:14:44.160
depending on the kind of application you're trying to build.

365
00:14:44.160 --> 00:14:45.660
Yeah, so with all those factors then,

366
00:14:45.660 --> 00:14:48.980
I think you can, the idea is we're taking something

367
00:14:48.980 --> 00:14:50.200
that's very subjective process,

368
00:14:50.200 --> 00:14:53.120
and we're trying to make it a little bit quantitative.

369
00:14:53.120 --> 00:14:54.760
So for each of those criteria,

370
00:14:54.760 --> 00:14:57.760
you can give every one of your computer options a score,

371
00:14:57.760 --> 00:14:59.960
like from one to five, and you can get everybody

372
00:14:59.960 --> 00:15:01.680
on the team to give a score,

373
00:15:01.680 --> 00:15:04.360
and if there's widely diverging opinions,

374
00:15:04.360 --> 00:15:07.060
you can discuss that and form a consensus, right?

375
00:15:07.060 --> 00:15:10.040
But the idea is to try and be as objective as possible.

376
00:15:10.040 --> 00:15:12.960
What I found is that by employing this process,

377
00:15:12.960 --> 00:15:15.960
you end up with quite a good shared consensus on the team,

378
00:15:15.960 --> 00:15:18.600
and much more of an understanding of different perspectives.

379
00:15:18.600 --> 00:15:20.620
And once you go forward with those decisions,

380
00:15:20.620 --> 00:15:22.600
you actually end up with, well, you know,

381
00:15:22.600 --> 00:15:24.760
we've got some very close scores here,

382
00:15:24.760 --> 00:15:28.040
but let's pick this one, and we also have optionality.

383
00:15:28.040 --> 00:15:30.660
You know, we can switch down the line

384
00:15:30.660 --> 00:15:32.300
if we architect this in the right way,

385
00:15:32.300 --> 00:15:33.840
and we know exactly what we're dealing with

386
00:15:33.840 --> 00:15:35.920
because we've put a lot of effort into understanding

387
00:15:35.920 --> 00:15:37.400
exactly what the pros and cons are.

388
00:15:37.400 --> 00:15:39.780
So it tends to remove all of that emotional baggage

389
00:15:39.780 --> 00:15:41.720
that comes with, you know,

390
00:15:41.720 --> 00:15:44.440
opinions-based technology selection.

391
00:15:44.440 --> 00:15:45.800
Yeah, and I think it makes also

392
00:15:45.800 --> 00:15:47.840
every team member more involved,

393
00:15:47.840 --> 00:15:49.980
or at least they feel more involved in the decision,

394
00:15:49.980 --> 00:15:51.720
which will make a big difference

395
00:15:51.720 --> 00:15:55.080
rather than having a decision being imposed from above,

396
00:15:55.080 --> 00:15:57.340
and maybe you end up not agreeing with it,

397
00:15:57.340 --> 00:16:01.200
and then because of that, you actually kind of resist

398
00:16:01.200 --> 00:16:03.960
in trying to adopt the technology as much as possible

399
00:16:03.960 --> 00:16:05.680
or as best as you can.

400
00:16:05.680 --> 00:16:07.140
I think when you have this process in place,

401
00:16:07.140 --> 00:16:09.200
it's much easier to get everyone on board too,

402
00:16:09.200 --> 00:16:10.360
even if it's an experiment,

403
00:16:10.360 --> 00:16:12.020
but at least to go ahead with the experiment

404
00:16:12.020 --> 00:16:14.520
and very honestly try to see how it plays out

405
00:16:14.520 --> 00:16:15.820
in the context of the team.

406
00:16:16.740 --> 00:16:18.400
But I have one question at this point

407
00:16:18.400 --> 00:16:21.640
because we are defining this process,

408
00:16:21.640 --> 00:16:25.020
and it feels like once you do this experiment,

409
00:16:25.020 --> 00:16:27.020
eventually you have one result, which is like,

410
00:16:27.020 --> 00:16:29.360
okay, for our particular need,

411
00:16:29.360 --> 00:16:31.560
this is the technology of choice.

412
00:16:31.560 --> 00:16:34.100
Does it mean that you end up picking only one,

413
00:16:34.100 --> 00:16:37.680
or is there room for different parts of the application

414
00:16:37.680 --> 00:16:40.220
picking different layers of compute?

415
00:16:40.220 --> 00:16:41.180
Yeah, that's a good point.

416
00:16:41.180 --> 00:16:42.720
It's definitely not the idea that you say,

417
00:16:42.720 --> 00:16:44.640
okay, now we go with Fargate for everything,

418
00:16:44.640 --> 00:16:47.080
or now we go with Lambda for everything.

419
00:16:47.080 --> 00:16:52.080
It's a bit like the way the database selection practice

420
00:16:52.460 --> 00:16:55.240
has evolved in a lot of companies now.

421
00:16:55.240 --> 00:16:57.080
Previously, you would pick one database

422
00:16:57.080 --> 00:16:59.320
that you would put at the heart of every system,

423
00:16:59.320 --> 00:17:00.800
probably ended up growing very large.

424
00:17:00.800 --> 00:17:05.160
Nowadays, people are more used to the polyglot database idea

425
00:17:05.160 --> 00:17:07.880
where you have different data stores for different purposes.

426
00:17:07.880 --> 00:17:09.460
You might have NoSQL for some data

427
00:17:09.460 --> 00:17:11.960
and different relational databases for others,

428
00:17:11.960 --> 00:17:13.320
maybe a data lake as well.

429
00:17:13.320 --> 00:17:15.840
So with compute, it's the same thing I would suggest.

430
00:17:15.840 --> 00:17:19.200
So for different applications or use cases,

431
00:17:19.200 --> 00:17:20.320
different processes,

432
00:17:20.320 --> 00:17:22.320
you can apply this process independently.

433
00:17:22.320 --> 00:17:23.980
So you end up with a mix of compute types,

434
00:17:23.980 --> 00:17:26.920
and that's completely okay because you're picking options

435
00:17:26.920 --> 00:17:29.640
that are optimized for the particular application

436
00:17:29.640 --> 00:17:31.000
and scalability.

437
00:17:31.000 --> 00:17:33.840
Yeah, I like that because I think the analogy

438
00:17:33.840 --> 00:17:36.360
fits really well today is very well accepted

439
00:17:36.360 --> 00:17:39.480
that you're not gonna use one database for everything.

440
00:17:39.480 --> 00:17:40.400
I mean, if you do that,

441
00:17:40.400 --> 00:17:43.240
you probably gonna end up in a suboptimal place.

442
00:17:43.240 --> 00:17:45.440
So I think it works also for compute

443
00:17:45.440 --> 00:17:48.960
that if you try to find the parts

444
00:17:48.960 --> 00:17:50.800
that fits best the particular problem,

445
00:17:50.800 --> 00:17:52.960
then probably you end up in a position

446
00:17:52.960 --> 00:17:55.340
where things are glued together in a better way

447
00:17:55.340 --> 00:17:59.220
and work better than just like one generic thing

448
00:17:59.220 --> 00:18:00.320
trying to do everything.

449
00:18:00.320 --> 00:18:02.580
So should we talk about the compute options

450
00:18:02.580 --> 00:18:04.640
that are actually available on AWS now?

451
00:18:04.640 --> 00:18:06.680
Yeah, I think the most obvious is EC2

452
00:18:06.680 --> 00:18:10.300
is probably the one that has been around the longest, right?

453
00:18:10.300 --> 00:18:11.880
And it's the most generic.

454
00:18:11.880 --> 00:18:13.200
You just been a virtual machines

455
00:18:13.200 --> 00:18:15.520
and you're free to do whatever you want with them.

456
00:18:16.900 --> 00:18:19.960
Probably also the one that requires more like maintenance

457
00:18:19.960 --> 00:18:21.880
and management on your side.

458
00:18:21.880 --> 00:18:24.360
So it's worth thinking it that way.

459
00:18:24.360 --> 00:18:27.440
It's like, yeah, the most generic, the most,

460
00:18:27.440 --> 00:18:30.980
I don't know usable for the largest variety of use cases,

461
00:18:30.980 --> 00:18:33.280
but also the one that would require a lot of investment

462
00:18:33.280 --> 00:18:35.120
in terms of non-differentiating things

463
00:18:35.120 --> 00:18:37.440
like which operative system do I use?

464
00:18:37.440 --> 00:18:39.520
How do I keep it up to date?

465
00:18:39.520 --> 00:18:41.880
Security and all that kind of stuff.

466
00:18:41.880 --> 00:18:44.120
All of that is it's on you.

467
00:18:44.120 --> 00:18:46.000
So keep that in mind.

468
00:18:46.000 --> 00:18:48.440
And I think we can move down the line

469
00:18:48.440 --> 00:18:51.520
of more and more managed and we from EC2,

470
00:18:51.520 --> 00:18:53.240
we can go to kind of containers.

471
00:18:53.240 --> 00:18:57.560
So we have Fargate, ECS, EKS are all compute options

472
00:18:57.560 --> 00:19:00.280
that you can use where you start to offload a lot more

473
00:19:00.280 --> 00:19:05.280
to AWS the amount of operational stuff that yeah,

474
00:19:05.560 --> 00:19:06.960
AWS will take care on for you

475
00:19:06.960 --> 00:19:09.120
rather than you having to do it yourself.

476
00:19:09.120 --> 00:19:12.800
Yeah, I think it's interesting to assign a simplicity score

477
00:19:12.800 --> 00:19:16.120
maybe in your head too, for each of those options.

478
00:19:16.120 --> 00:19:17.920
Cause I would have certain view on that,

479
00:19:17.920 --> 00:19:20.800
but it's a good thing to explore with your team.

480
00:19:20.800 --> 00:19:23.600
Exactly how much complexity you're getting into

481
00:19:23.600 --> 00:19:25.320
and the difference for different container options

482
00:19:25.320 --> 00:19:28.040
you can end up with very different scorings.

483
00:19:28.040 --> 00:19:30.240
Absolutely and we already mentioned this in the previous

484
00:19:30.240 --> 00:19:33.300
episode where in that particular use case,

485
00:19:33.300 --> 00:19:36.840
we decided to go with EC2 rather than using containers,

486
00:19:36.840 --> 00:19:39.800
just because the team didn't have any previous knowledge

487
00:19:39.800 --> 00:19:42.240
about containers, not because containers

488
00:19:42.240 --> 00:19:43.640
wouldn't have been beneficial for them.

489
00:19:43.640 --> 00:19:47.040
It's more how much load do we put into the team

490
00:19:47.040 --> 00:19:48.240
to learn new things.

491
00:19:48.240 --> 00:19:50.080
And we decided at that point in time,

492
00:19:50.080 --> 00:19:53.940
just switching to AWS was already enough cognitive overload.

493
00:19:53.940 --> 00:19:56.040
So that could be maybe a next transition

494
00:19:56.040 --> 00:19:57.560
when the team is confident with AWS,

495
00:19:57.560 --> 00:19:59.920
they can start to get more confident with containers

496
00:19:59.920 --> 00:20:03.840
and then switch to ECS, EKS or Fargate

497
00:20:03.840 --> 00:20:05.720
and start to upload more and more to AWS.

498
00:20:05.720 --> 00:20:08.720
So I think you need to also keep in mind as we said,

499
00:20:08.720 --> 00:20:12.500
the kind of knowledge bias and decide how much more knowledge

500
00:20:12.500 --> 00:20:15.600
do you want to gain in one go rather than

501
00:20:15.600 --> 00:20:17.120
sticking with what you know.

502
00:20:17.120 --> 00:20:18.100
That makes a lot of sense.

503
00:20:18.100 --> 00:20:20.320
Yeah, in that case, I suppose you just put an increased

504
00:20:20.320 --> 00:20:23.480
weight on the skills match than on the simplicity factor,

505
00:20:23.480 --> 00:20:26.560
which is completely okay as long as that's an agreed

506
00:20:26.560 --> 00:20:27.920
approach by everybody.

507
00:20:30.020 --> 00:20:33.800
Yeah, and if we keep moving into more and more managed,

508
00:20:33.800 --> 00:20:37.800
I think that the next ones are uprunner, light sale

509
00:20:37.800 --> 00:20:41.520
or Beanstalk, which is probably the most traditional

510
00:20:41.520 --> 00:20:44.240
older version of light sale and uprunner,

511
00:20:44.240 --> 00:20:47.320
but also things like SageMaker or AWS batch,

512
00:20:47.320 --> 00:20:49.000
which are a little bit more specialized.

513
00:20:49.000 --> 00:20:50.920
But again, you kind of,

514
00:20:50.920 --> 00:20:52.640
you still can run your own custom computers

515
00:20:52.640 --> 00:20:54.400
just in a more constrained fashion

516
00:20:54.400 --> 00:20:57.920
and you offload a lot more into AWS.

517
00:20:57.920 --> 00:21:00.640
Yeah, AWS batch can be very useful in some cases.

518
00:21:00.640 --> 00:21:02.900
It runs on top of ECS really,

519
00:21:02.900 --> 00:21:06.160
but it can make the process a lot simpler as you say, yeah.

520
00:21:07.760 --> 00:21:08.600
Then what do we have?

521
00:21:08.600 --> 00:21:11.360
I think we can also consider code build as part of compute.

522
00:21:11.360 --> 00:21:12.520
Maybe it's a little bit of a stretch,

523
00:21:12.520 --> 00:21:13.360
but at the end of the day,

524
00:21:13.360 --> 00:21:15.800
you are in control of what kind of code

525
00:21:15.800 --> 00:21:17.440
is used to build something.

526
00:21:17.440 --> 00:21:20.200
So it can become a little bit more general purpose

527
00:21:20.200 --> 00:21:22.520
than you might want to think about it.

528
00:21:22.520 --> 00:21:26.680
So yeah, you can have your own totally custom build processes

529
00:21:26.680 --> 00:21:29.520
and write them in any language or any technology

530
00:21:29.520 --> 00:21:30.400
that you really want to.

531
00:21:30.400 --> 00:21:33.480
And you just run it on that code build compute layer.

532
00:21:33.480 --> 00:21:34.320
Quick and dirty approach,

533
00:21:34.320 --> 00:21:36.920
but it works really well in some cases, yeah, for sure.

534
00:21:38.360 --> 00:21:40.440
And then we have, I guess,

535
00:21:40.440 --> 00:21:42.880
AWS Glue spoken of that one or EMR,

536
00:21:42.880 --> 00:21:45.880
where you are using this kind of bespoke compute layer

537
00:21:45.880 --> 00:21:49.040
more for data management and data processing.

538
00:21:49.040 --> 00:21:51.360
And finally, the last one is Lambda,

539
00:21:51.360 --> 00:21:53.600
which is probably the most generic,

540
00:21:53.600 --> 00:21:56.440
but also very lightweight in terms of,

541
00:21:56.440 --> 00:21:58.760
like it's as pure compute as it gets.

542
00:21:58.760 --> 00:22:01.120
And you just write one function with your business logic

543
00:22:01.120 --> 00:22:02.880
and that's it, you generally don't have to worry

544
00:22:02.880 --> 00:22:05.760
about almost anything else.

545
00:22:05.760 --> 00:22:06.680
Did I miss anything?

546
00:22:06.680 --> 00:22:09.880
Is there any other service worth mentioning?

547
00:22:09.880 --> 00:22:12.680
There are probably others you could shoehorn in there,

548
00:22:12.680 --> 00:22:14.080
but I think that's a pretty good picture.

549
00:22:14.080 --> 00:22:17.640
I think somebody said there's 19 different ways

550
00:22:17.640 --> 00:22:19.840
to run containers on AWS.

551
00:22:19.840 --> 00:22:21.680
But look, I think we've covered enough

552
00:22:21.680 --> 00:22:23.560
and people get the general idea.

553
00:22:23.560 --> 00:22:26.520
Maybe we should start to conclude by talking about

554
00:22:26.520 --> 00:22:28.040
some of those example case studies

555
00:22:28.040 --> 00:22:29.520
and real world scenarios.

556
00:22:29.520 --> 00:22:32.760
So you already alluded to the legal,

557
00:22:32.760 --> 00:22:35.040
EGLE application from your article

558
00:22:35.040 --> 00:22:36.120
and from the last episode,

559
00:22:36.120 --> 00:22:37.320
which we'll link in the show notes.

560
00:22:37.320 --> 00:22:38.320
Yes, yeah, on that one,

561
00:22:38.320 --> 00:22:40.280
I think the most relevant thing was

562
00:22:40.280 --> 00:22:42.360
there were a bunch of different trade-offs

563
00:22:42.360 --> 00:22:44.480
that were made in that case study

564
00:22:44.480 --> 00:22:47.440
that are very relevant, not just to the technology itself,

565
00:22:47.440 --> 00:22:50.320
but also the team and the stage of the project.

566
00:22:50.320 --> 00:22:53.560
So I think we recommend you to watch that episode

567
00:22:53.560 --> 00:22:56.280
or read the article to kind of get the full context,

568
00:22:56.280 --> 00:22:57.840
because there we go with EC2,

569
00:22:57.840 --> 00:23:00.560
which seems a little bit of a counterintuitive choice

570
00:23:00.560 --> 00:23:02.760
based on what we just said so far.

571
00:23:02.760 --> 00:23:05.040
So I think it's interesting to get the full context

572
00:23:05.040 --> 00:23:07.080
to understand why that was the suggestion

573
00:23:07.080 --> 00:23:08.520
for that particular use case.

574
00:23:10.560 --> 00:23:12.920
Another one I'd like to throw in here is a couple of machine learning cases.

575
00:23:12.920 --> 00:23:14.800
In a few different projects, I've come across examples

576
00:23:14.800 --> 00:23:16.880
where people had a pre-trained model,

577
00:23:16.880 --> 00:23:19.360
like an image recognition model or something like that,

578
00:23:19.360 --> 00:23:21.840
which has come from a team of data scientists

579
00:23:21.840 --> 00:23:25.040
working on GPU instances they had access to

580
00:23:25.040 --> 00:23:26.160
in some data center,

581
00:23:26.160 --> 00:23:28.040
and then they want to productionize it on AWS,

582
00:23:28.040 --> 00:23:29.520
and they want it to be able to scale quickly

583
00:23:29.520 --> 00:23:30.680
and work elastically,

584
00:23:30.680 --> 00:23:32.880
depending on the number of images that come in,

585
00:23:32.880 --> 00:23:34.920
and that can be very variable.

586
00:23:34.920 --> 00:23:37.440
And I've actually gone through the process

587
00:23:37.440 --> 00:23:39.080
of trying this on different platforms

588
00:23:39.080 --> 00:23:42.000
and surprised by where I eventually landed,

589
00:23:42.000 --> 00:23:45.040
because now my default kind of scoring methodology on this

590
00:23:45.040 --> 00:23:47.480
would lead me actually to AWS Lambda,

591
00:23:47.480 --> 00:23:50.040
which you wouldn't expect to be the ideal platform

592
00:23:50.040 --> 00:23:51.520
for machine learning,

593
00:23:51.520 --> 00:23:53.040
but with the meta memory you have

594
00:23:53.040 --> 00:23:54.760
and the container support now,

595
00:23:54.760 --> 00:23:56.800
and the fact that you don't really often need GPUs

596
00:23:56.800 --> 00:23:59.960
for inference when you're actually just running the model,

597
00:24:00.840 --> 00:24:02.000
Lambda scales really well,

598
00:24:02.000 --> 00:24:06.600
so you can have results in seconds or less,

599
00:24:06.600 --> 00:24:09.240
but you can also scale to thousands in an instant,

600
00:24:09.240 --> 00:24:10.880
which you can't really do with SageMaker.

601
00:24:10.880 --> 00:24:14.920
And SageMaker ended up having a lot more complexity,

602
00:24:14.920 --> 00:24:16.920
it was less common,

603
00:24:16.920 --> 00:24:18.200
so there wasn't as much documentation

604
00:24:18.200 --> 00:24:19.560
and tutorials out there,

605
00:24:19.560 --> 00:24:22.200
and the interface was a little bit non-traditional,

606
00:24:22.200 --> 00:24:23.960
you know, it was just a bit more bespoke.

607
00:24:23.960 --> 00:24:27.440
So I ended up running more applications like that on Lambda

608
00:24:27.440 --> 00:24:30.880
and orchestrating it with step functions and API gateway,

609
00:24:30.880 --> 00:24:34.560
and I found that's really nice solution in general,

610
00:24:34.560 --> 00:24:36.920
if your model works in Lambda.

611
00:24:36.920 --> 00:24:40.480
Yeah, hopefully we will also get GPUs on Lambda soon.

612
00:24:40.480 --> 00:24:41.400
Yeah.

613
00:24:41.400 --> 00:24:42.240
At some point, but I agree with you,

614
00:24:42.240 --> 00:24:45.280
it's probably a niche use case for now,

615
00:24:45.280 --> 00:24:47.120
and you can live without it

616
00:24:47.120 --> 00:24:49.880
and still reap the benefits of the simplicity of Lambda.

617
00:24:53.120 --> 00:24:58.080
Okay, is there any other example that we want to present?

618
00:24:58.080 --> 00:25:00.240
So there's one that I thought would be worth throwing in

619
00:25:00.240 --> 00:25:03.160
last, which is just in terms of batch processing.

620
00:25:03.160 --> 00:25:05.160
We mentioned AWS batch in already,

621
00:25:05.160 --> 00:25:07.440
but there's a use case,

622
00:25:07.440 --> 00:25:10.360
which is similar to projects we've worked on in the past,

623
00:25:10.360 --> 00:25:12.800
and if you consider like a financial company,

624
00:25:12.800 --> 00:25:14.880
like a pensions provider,

625
00:25:14.880 --> 00:25:16.600
and they have a lot of clients

626
00:25:16.600 --> 00:25:18.480
with different portfolios of pensions.

627
00:25:18.480 --> 00:25:20.560
So, you know, when you're choosing a pension,

628
00:25:20.560 --> 00:25:22.520
you have to say how risk averse you are,

629
00:25:22.520 --> 00:25:23.680
what your risk level is,

630
00:25:23.680 --> 00:25:26.880
and your pensions provider are supposed to purchase assets

631
00:25:26.880 --> 00:25:29.520
and invest your money in something

632
00:25:29.520 --> 00:25:31.040
that affects that risk level.

633
00:25:31.040 --> 00:25:32.440
So if you can imagine that that pensions company

634
00:25:32.440 --> 00:25:33.840
will have to calculate, okay,

635
00:25:33.840 --> 00:25:35.480
for all of the assets we invest in,

636
00:25:35.480 --> 00:25:38.480
what is the risk level and how does that change over time?

637
00:25:38.480 --> 00:25:41.080
And how does that affect individual clients

638
00:25:41.080 --> 00:25:42.600
and their portfolios?

639
00:25:42.600 --> 00:25:44.680
So on a frequent basis,

640
00:25:44.680 --> 00:25:47.120
that pensions company will want to calculate risk level

641
00:25:47.120 --> 00:25:48.880
based on all the data they get in.

642
00:25:48.880 --> 00:25:51.720
So it could be stock market data, data about their clients,

643
00:25:51.720 --> 00:25:55.080
contracts from their various different stakeholders

644
00:25:55.080 --> 00:25:55.960
they deal with,

645
00:25:55.960 --> 00:25:57.800
and they need to run some sort of statistical model

646
00:25:57.800 --> 00:25:58.760
to calculate that risk.

647
00:25:58.760 --> 00:26:00.000
The workload, the compute option there

648
00:26:00.000 --> 00:26:02.000
will depend really on the volume of data,

649
00:26:02.000 --> 00:26:04.440
the number of deals you have to calculate

650
00:26:04.440 --> 00:26:06.120
and the performance requirement, you know,

651
00:26:06.120 --> 00:26:08.160
how quickly do you need to get access to it?

652
00:26:08.160 --> 00:26:10.440
So traditionally, I think a lot of people

653
00:26:10.440 --> 00:26:13.600
would go to some sort of high performance

654
00:26:13.600 --> 00:26:16.120
compute infrastructure, like big instances

655
00:26:16.120 --> 00:26:17.720
with very rapid networking between them,

656
00:26:17.720 --> 00:26:20.320
shared state, message passing infrastructure.

657
00:26:21.720 --> 00:26:23.320
But in terms of the scoring methodology,

658
00:26:23.320 --> 00:26:25.000
we've discussed this kind of scenario,

659
00:26:25.000 --> 00:26:27.800
but again, lead me towards either something like Fargate

660
00:26:27.800 --> 00:26:28.880
or indeed Lambda.

661
00:26:28.880 --> 00:26:29.960
In the context of Lambda,

662
00:26:29.960 --> 00:26:31.600
what would actually forces you to do

663
00:26:31.600 --> 00:26:34.400
is divide all this work into small pieces

664
00:26:34.400 --> 00:26:36.320
that can run on Lambda functions.

665
00:26:36.320 --> 00:26:37.560
And then you try to make Lambda

666
00:26:37.560 --> 00:26:39.120
give you as much concurrency as possible

667
00:26:39.120 --> 00:26:41.560
so that you can get all of these little pieces

668
00:26:41.560 --> 00:26:43.040
executed as quickly as possible.

669
00:26:43.040 --> 00:26:45.120
And they're scaled in thousands of jobs in parallel.

670
00:26:45.120 --> 00:26:46.840
Just if you look at the performance factor

671
00:26:46.840 --> 00:26:49.080
in the scoring chart, it takes care of that,

672
00:26:49.080 --> 00:26:50.880
but you also get reliability, security

673
00:26:50.880 --> 00:26:53.560
and higher availability out of the box.

674
00:26:53.560 --> 00:26:55.480
And then your jobs, because they're running in Lambda,

675
00:26:55.480 --> 00:26:56.320
they're also stateless.

676
00:26:56.320 --> 00:26:58.200
So for a developer experience,

677
00:26:58.200 --> 00:27:00.720
it means that if you've got an individual job failure

678
00:27:00.720 --> 00:27:02.200
and you need to troubleshoot it,

679
00:27:02.200 --> 00:27:03.760
you can just run that job in isolation

680
00:27:03.760 --> 00:27:07.360
and it doesn't rely on some clusters shared state

681
00:27:07.360 --> 00:27:09.920
in order to be able to troubleshoot it.

682
00:27:09.920 --> 00:27:11.760
So there's lots of options there

683
00:27:11.760 --> 00:27:13.800
and there's no one right answer in any of these cases.

684
00:27:13.800 --> 00:27:16.200
But I think this was just an example I wanted to bring up

685
00:27:16.200 --> 00:27:18.920
because it's like something that traditionally

686
00:27:18.920 --> 00:27:22.480
you would have solved with high performance compute cluster,

687
00:27:22.480 --> 00:27:26.640
but now you can do it with just very scalable commodity

688
00:27:26.640 --> 00:27:29.760
cloud computing with Lambda or Fargate containers.

689
00:27:31.880 --> 00:27:35.040
Yeah, I think what you just said there at the end in terms of, because if you embrace Lambda,

690
00:27:35.040 --> 00:27:36.840
you're kind of forced to go down that path

691
00:27:36.840 --> 00:27:37.720
that you need to think, okay,

692
00:27:37.720 --> 00:27:39.200
how do we break this problem down

693
00:27:39.200 --> 00:27:42.960
into more kind of manageable pieces that run concurrently?

694
00:27:42.960 --> 00:27:45.560
I think it also forces you from an architecture perspective

695
00:27:45.560 --> 00:27:47.960
to build something that is probably closer

696
00:27:47.960 --> 00:27:49.440
to the idea of microservices,

697
00:27:49.440 --> 00:27:52.360
where you have small components that can be executed

698
00:27:52.360 --> 00:27:54.560
and tested and developed autonomously.

699
00:27:54.560 --> 00:27:56.560
And then you kind of orchestrate all of them together.

700
00:27:56.560 --> 00:27:59.680
So there could also be advantages in terms of,

701
00:27:59.680 --> 00:28:01.120
I don't know, the simplicity for the team

702
00:28:01.120 --> 00:28:02.920
to work on an individual component

703
00:28:02.920 --> 00:28:04.600
other than just troubleshooting at runtime,

704
00:28:04.600 --> 00:28:08.280
but even building it from day zero to production.

705
00:28:08.280 --> 00:28:10.320
I think you can divide a lot more of the work

706
00:28:10.320 --> 00:28:12.440
and bring everyone on board more easily

707
00:28:12.440 --> 00:28:13.840
on the different components,

708
00:28:13.840 --> 00:28:15.960
rather than having one big monolithic thing

709
00:28:15.960 --> 00:28:18.600
that could be very hard to develop and test

710
00:28:18.600 --> 00:28:19.680
and run locally.

711
00:28:19.680 --> 00:28:21.360
And I think we're seeing more and more of this,

712
00:28:21.360 --> 00:28:24.040
people realizing that you can use this commodity

713
00:28:24.040 --> 00:28:25.760
function as a service or containers

714
00:28:25.760 --> 00:28:27.280
to do like high performance computing

715
00:28:27.280 --> 00:28:29.560
or even scientific computing at scale.

716
00:28:29.560 --> 00:28:31.640
We're seeing more and more examples of that.

717
00:28:31.640 --> 00:28:34.680
So I hope these examples should explain why it's useful

718
00:28:34.680 --> 00:28:37.400
first in having a system for scoring each of the options,

719
00:28:37.400 --> 00:28:40.240
and then how you would apply that scoring system

720
00:28:40.240 --> 00:28:42.080
for different use cases in order

721
00:28:42.080 --> 00:28:44.120
to make technology decisions.

722
00:28:44.120 --> 00:28:45.400
We do have an article already on this

723
00:28:45.400 --> 00:28:47.240
on choosing AWS compute services.

724
00:28:48.400 --> 00:28:49.880
And it has a methodology just like this.

725
00:28:49.880 --> 00:28:52.480
And you can see the scores we've given to various services.

726
00:28:52.480 --> 00:28:54.600
So there's a link to this article in the show notes.

727
00:28:54.600 --> 00:28:55.640
And in upcoming episodes,

728
00:28:55.640 --> 00:28:58.240
actually we're going to dive deeper on specific applications

729
00:28:58.240 --> 00:28:59.920
that we've worked on at 4th Erem

730
00:28:59.920 --> 00:29:02.720
and show how this methodology played out in reality.

731
00:29:02.720 --> 00:29:04.200
So until then we recommend that you check out

732
00:29:04.200 --> 00:29:07.400
the previous episode on migrating a monolithic legal CMS

733
00:29:07.400 --> 00:29:10.080
application to AWS without the drama.

734
00:29:10.080 --> 00:29:11.920
And we'll see you next time.

735
00:29:11.920 --> 00:29:31.000
Smridge cataly falsehoods
