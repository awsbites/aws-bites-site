WEBVTT

1
00:00:00.000 --> 00:00:06.640
Hello, everyone, and welcome to our first live stream of AWS Bites.

2
00:00:06.640 --> 00:00:10.320
My name is Luciano, and today I'm joined by Eoin.

3
00:00:10.320 --> 00:00:12.200
So hello, everyone.

4
00:00:12.200 --> 00:00:13.200
Hello.

5
00:00:13.200 --> 00:00:20.240
Yeah, if this is the first time for you hearing or seeing AWS Bites, what AWS Bytes is is

6
00:00:20.240 --> 00:00:25.540
basically a podcast about AWS where we try to share all the things that we learn and

7
00:00:25.540 --> 00:00:27.840
discover about AWS.

8
00:00:27.840 --> 00:00:31.660
And so far we've been doing it in the form of a regular podcast.

9
00:00:31.660 --> 00:00:34.280
We have a website, awsbytes.com.

10
00:00:34.280 --> 00:00:36.500
You can go there and watch all the previous episodes.

11
00:00:36.500 --> 00:00:40.080
And in every episode, we basically try to answer different kinds of questions about

12
00:00:40.080 --> 00:00:41.080
AWS.

13
00:00:41.080 --> 00:00:45.600
For instance, we've been talking about all the things that you need to know when doing

14
00:00:45.600 --> 00:00:52.860
JavaScript with serverless on AWS, or we compare Terraform and Cloud formations.

15
00:00:52.860 --> 00:00:54.720
We have a bunch of different topics.

16
00:00:54.720 --> 00:00:58.760
And by any means, feel free to let us know which one did you like the most, which ones

17
00:00:58.760 --> 00:01:01.920
would you like to see in the future, and things like that.

18
00:01:01.920 --> 00:01:04.300
But for today, we want to try something a little bit different.

19
00:01:04.300 --> 00:01:09.620
We actually want to try to do a little bit of live coding and actually show what could

20
00:01:09.620 --> 00:01:14.240
be the experience of building a product on AWS.

21
00:01:14.240 --> 00:01:20.900
And the product that we have in mind for today is something that looks like a clone of something

22
00:01:20.900 --> 00:01:25.980
like Dropbox Transfer or maybe WeTransfer, where basically the idea is that you need

23
00:01:25.980 --> 00:01:28.800
to share a file with somebody else.

24
00:01:28.800 --> 00:01:33.020
Let's find the easiest possible way to do that, or the fastest maybe possible way to

25
00:01:33.020 --> 00:01:39.240
do that, which is basically let's upload it somewhere and then have a URL that it's somehow

26
00:01:39.240 --> 00:01:43.600
secret and we can take that URL, share it with the person we want to share the file

27
00:01:43.600 --> 00:01:49.020
with, and they can use the same URL to download the file that we just uploaded.

28
00:01:49.020 --> 00:01:55.200
So the idea is that basically we are going to build a service like that using AWS services.

29
00:01:55.200 --> 00:01:58.680
So probably we're going to be using things like S3 to store the files.

30
00:01:58.680 --> 00:02:04.840
We're probably going to be using signed URLs to be able to upload and download things.

31
00:02:04.840 --> 00:02:10.320
And we might be using API Gateway because probably we want to turn that into an API

32
00:02:10.320 --> 00:02:13.880
that then we can use from maybe a CLI, maybe a front end.

33
00:02:13.880 --> 00:02:19.220
So we have some kind of rough ideas, but it's very important for you to contribute to the

34
00:02:19.220 --> 00:02:24.580
conversation and suggest maybe different things that we could be doing.

35
00:02:24.580 --> 00:02:29.600
So for today, our goal is to, we're going to be streaming for about one hour, I think,

36
00:02:29.600 --> 00:02:34.960
and our goal is to try to get as far as we possibly can to just to build the first MVP,

37
00:02:34.960 --> 00:02:40.380
where what we expect to do is later to have one Lambda that allows us to upload to S3

38
00:02:40.380 --> 00:02:45.220
and give us back a URL that can be used to download the file.

39
00:02:45.220 --> 00:02:51.200
So yeah, anything else you want to add, Eoin?

40
00:02:51.200 --> 00:02:55.640
No, it's really good to be able to get started on this.

41
00:02:55.640 --> 00:02:57.360
And yeah, let's do this.

42
00:02:57.360 --> 00:03:01.320
Let's see how we get on, how far we get today, and then we can start talking about maybe

43
00:03:01.320 --> 00:03:03.000
where we can take it next.

44
00:03:03.000 --> 00:03:04.000
Absolutely.

45
00:03:04.000 --> 00:03:06.480
Yeah, that makes sense.

46
00:03:06.480 --> 00:03:11.480
So I'm going to start by sharing my screen.

47
00:03:11.480 --> 00:03:14.820
Actually first of all, I'm going to mention that we already set up a repository, which

48
00:03:14.820 --> 00:03:24.500
is the one we are going to be using today, and I'm going to be posting it on YouTube.

49
00:03:24.500 --> 00:03:34.360
But if you are following from Twitter or LinkedIn, you can find it at awsbytes slash weshare.click,

50
00:03:34.360 --> 00:03:37.440
which is the name we selected for this project.

51
00:03:37.440 --> 00:03:45.960
I'm actually going to see if I can show it on screen.

52
00:03:45.960 --> 00:03:49.320
So let me share my screen here.

53
00:03:49.320 --> 00:03:53.320
Okay, this is the repository.

54
00:03:53.320 --> 00:03:56.400
So this is the URL awsbytes weshare.click.

55
00:03:56.400 --> 00:03:58.840
Right now it's pretty much an empty repository.

56
00:03:58.840 --> 00:04:02.960
We only have a little bit of readme and an architecture diagram that I'm going to be

57
00:04:02.960 --> 00:04:04.920
trying to describe.

58
00:04:04.920 --> 00:04:06.240
Cool.

59
00:04:06.240 --> 00:04:11.560
Actually, let me show it here, which is a little bit bigger.

60
00:04:11.560 --> 00:04:15.600
So basically the idea is that, as we said, we want to have a quick way for Alice and

61
00:04:15.600 --> 00:04:20.000
Bob to share one particular file through the internet.

62
00:04:20.000 --> 00:04:28.640
So the idea is that we can give Alice basically a web server where she can upload the file

63
00:04:28.640 --> 00:04:34.820
and then she will get back a URL that once shared with Bob allows Bob to download that

64
00:04:34.820 --> 00:04:35.820
same file.

65
00:04:35.820 --> 00:04:40.180
Now, if we zoom in a little bit more on how we are thinking to implement all of that right

66
00:04:40.180 --> 00:04:46.640
now, at least for version one, is that we have an API gateway that gives Alice a particular

67
00:04:46.640 --> 00:04:48.240
API endpoint.

68
00:04:48.240 --> 00:04:55.040
On this API endpoint, we can do a post and this post basically, what it's going to do

69
00:04:55.040 --> 00:05:01.760
is going to trigger a Lambda and this Lambda is going to effectively create a pre-signed

70
00:05:01.760 --> 00:05:06.980
URL on S3 that is going to allow Alice to upload the file itself.

71
00:05:06.980 --> 00:05:14.880
So the first step is that basically with this request, Alice gets an S3 upload and then

72
00:05:14.880 --> 00:05:20.880
she can use that S3 upload pre-signed URL to actually put the file into the bucket.

73
00:05:20.880 --> 00:05:24.960
But at the same time with the upload URL, we also generate a download URL that is going

74
00:05:24.960 --> 00:05:28.400
to be ready to be shared as soon as the upload is completed.

75
00:05:28.400 --> 00:05:33.680
So the first step is actually giving back two things, the upload URL and the download

76
00:05:33.680 --> 00:05:34.680
URL.

77
00:05:34.680 --> 00:05:39.640
So at that point, Alice can upload the file and then just share the download URL with

78
00:05:39.640 --> 00:05:42.400
Bob.

79
00:05:42.400 --> 00:05:45.820
I think there might be different ways to implement that.

80
00:05:45.820 --> 00:05:49.180
This is just one way that we came up with and this is the way we think we are going

81
00:05:49.180 --> 00:05:50.180
to go for today.

82
00:05:50.180 --> 00:05:56.080
So if you have other ideas, definitely let us know and we are open to discuss alternatives

83
00:05:56.080 --> 00:05:59.080
and maybe pros and cons of different alternatives.

84
00:05:59.080 --> 00:06:03.120
Yeah, the URLs will not be pretty.

85
00:06:03.120 --> 00:06:05.720
Maybe we should pre-warn people, right?

86
00:06:05.720 --> 00:06:10.220
These URLs will not be very user-friendly, but don't worry, future episodes will take

87
00:06:10.220 --> 00:06:12.240
care of that.

88
00:06:12.240 --> 00:06:14.400
Yeah, absolutely.

89
00:06:14.400 --> 00:06:18.680
I see we have a comment here in the chat by Abu.

90
00:06:18.680 --> 00:06:19.880
Welcome to the stream.

91
00:06:19.880 --> 00:06:24.000
I was just discussing this idea with my colleague as a side project and now I'm seeing this.

92
00:06:24.000 --> 00:06:29.280
Sorry, we are going to spoil the side project, but I mean, if you had different ways of...

93
00:06:29.280 --> 00:06:32.800


94
00:06:32.800 --> 00:06:34.800
You were thinking about different ways to implement this by any means, chime in and we can chat about that.

95
00:06:34.800 --> 00:06:37.680
Yeah, also different features for sure.

96
00:06:37.680 --> 00:06:38.680
Yeah.

97
00:06:38.680 --> 00:06:42.480
I mean, I can imagine like we're going to build this and eventually we have the name

98
00:06:42.480 --> 00:06:43.600
we share.click.

99
00:06:43.600 --> 00:06:47.140
So this is the domain name we're going to use for this deployment, but I can imagine

100
00:06:47.140 --> 00:06:52.440
other people would maybe take this and use it as a way to store files for themselves,

101
00:06:52.440 --> 00:06:59.720
to share files between different devices and have it as their own personal Dropbox using

102
00:06:59.720 --> 00:07:02.240
their own AWS infrastructure, right?

103
00:07:02.240 --> 00:07:07.040
And avoid having to go to Google or Dropbox for their file storage.

104
00:07:07.040 --> 00:07:14.320
So yeah, it's probably an opportunity here for us to all have our own forks and customized

105
00:07:14.320 --> 00:07:16.680
deployments of this application.

106
00:07:16.680 --> 00:07:19.920
And I see that there is another comment on YouTube by Italo.

107
00:07:19.920 --> 00:07:24.840
Sorry, I cannot put this one on screen, but it's basically asking, should we try to rebuild

108
00:07:24.840 --> 00:07:27.440
this thing and then update you on the progress?

109
00:07:27.440 --> 00:07:28.440
Absolutely yes.

110
00:07:28.440 --> 00:07:36.280
Feel free to redo it, copy paste our code, try different things because again, in AWS,

111
00:07:36.280 --> 00:07:41.160
there are millions of ways to build anything and you can use different services.

112
00:07:41.160 --> 00:07:45.960
So it will be interesting to also see what other people will think about how to solve

113
00:07:45.960 --> 00:07:48.240
this particular problem.

114
00:07:48.240 --> 00:07:49.960
Okay.

115
00:07:49.960 --> 00:07:56.520
So let's maybe start to look at the code and this is a very kind of vanilla repository

116
00:07:56.520 --> 00:07:58.320
that is literally nothing.

117
00:07:58.320 --> 00:08:04.080
So maybe we can start by doing a little bit of just creating the kind of the structure

118
00:08:04.080 --> 00:08:05.560
for the project.

119
00:08:05.560 --> 00:08:11.960
So we are going to be using Node.js as a kind of runtime of choice or JavaScript.

120
00:08:11.960 --> 00:08:18.880
So let's start by doing animate of the project.

121
00:08:18.880 --> 00:08:27.420
So I just run npm init dash y, which is basically just doing like a default package JSON.

122
00:08:27.420 --> 00:08:29.580
And we can see the result here.

123
00:08:29.580 --> 00:08:33.920
It's actually taking some stuff from the repository, which is pretty cool.

124
00:08:33.920 --> 00:08:37.120
But other than that, not that special.

125
00:08:37.120 --> 00:08:43.580
One thing that we want to do is we want to start to organize this as a mono repo because

126
00:08:43.580 --> 00:08:50.460
we eventually want to create an API, the one we just described, but also some ways to interact

127
00:08:50.460 --> 00:08:56.080
with this API, probably a CLI application and maybe also front end.

128
00:08:56.080 --> 00:09:00.360
So it might be interesting to put all the same things in the same repository just for

129
00:09:00.360 --> 00:09:06.740
convenience and actually recent versions of npm make that very easy.

130
00:09:06.740 --> 00:09:12.040
Because we can just create a new folder and call it backend for instance.

131
00:09:12.040 --> 00:09:18.040
And then we can just say that that's a new workspace.

132
00:09:18.040 --> 00:09:25.780
And actually this is an array, if I remember correctly, and we just need to say backend

133
00:09:25.780 --> 00:09:30.200
is one item.

134
00:09:30.200 --> 00:09:38.240
Now at this point we can go into backend and do another npm init y and this is how we are

135
00:09:38.240 --> 00:09:43.120
creating sub projects inside our mono repo.

136
00:09:43.120 --> 00:09:46.360
But also we want to configure a bunch of other things.

137
00:09:46.360 --> 00:09:48.400
For instance, we want to add a license.

138
00:09:48.400 --> 00:09:51.400
We want to add a gitignore file.

139
00:09:51.400 --> 00:09:53.800
And there are some tools that I really like.

140
00:09:53.800 --> 00:09:58.600
For instance, I think there is one called gitignore.

141
00:09:58.600 --> 00:10:08.040
Gitignore, which we can say, I think node.js and it should give us a default node.js gitignore.

142
00:10:08.040 --> 00:10:10.760
Let's see if my memory is good.

143
00:10:10.760 --> 00:10:12.080
It is not.

144
00:10:12.080 --> 00:10:14.400
It gave us an empty one.

145
00:10:14.400 --> 00:10:15.400
Okay.

146
00:10:15.400 --> 00:10:19.800
So let's see if we just say gitignore if allows us to select.

147
00:10:19.800 --> 00:10:20.800
Okay.

148
00:10:20.800 --> 00:10:21.800
Gitignore types.

149
00:10:21.800 --> 00:10:25.240
Okay, you're going to have to do slash types.

150
00:10:25.240 --> 00:10:26.240
And what do we have?

151
00:10:26.240 --> 00:10:27.240
Do we have node?

152
00:10:27.240 --> 00:10:31.440
Node with just one word.

153
00:10:31.440 --> 00:10:34.800
Okay, fair enough.

154
00:10:34.800 --> 00:10:35.980
Cool.

155
00:10:35.980 --> 00:10:42.520
Now we've got something that looks a little bit better with a bunch of default stuff.

156
00:10:42.520 --> 00:10:43.520
Okay.

157
00:10:43.520 --> 00:10:50.000
And another thing we can do is npm, I think it's called license and we can select one

158
00:10:50.000 --> 00:10:51.000
license.

159
00:10:51.000 --> 00:10:58.160
Or do we want MIT or something else?

160
00:10:58.160 --> 00:10:59.480
Sounds good to me.

161
00:10:59.480 --> 00:11:02.480
Okay, let's keep it super free.

162
00:11:02.480 --> 00:11:04.000
I don't have that yet.

163
00:11:04.000 --> 00:11:06.000
I think that's good.

164
00:11:06.000 --> 00:11:07.000
And now we have a license.

165
00:11:07.000 --> 00:11:08.000
I don't know about other tools.

166
00:11:08.000 --> 00:11:09.000
I like it.

167
00:11:09.000 --> 00:11:10.000
Cool.

168
00:11:10.000 --> 00:11:16.160
So the next thing that we might want to do is ESLint, I guess.

169
00:11:16.160 --> 00:11:18.440
Oh, yeah.

170
00:11:18.440 --> 00:11:20.840
So we're going to write all this stuff in JavaScript.

171
00:11:20.840 --> 00:11:24.560
That's the plan, right Luciano?

172
00:11:24.560 --> 00:11:25.560
Yeah.

173
00:11:25.560 --> 00:11:26.560
Okay.

174
00:11:26.560 --> 00:11:30.080
It's okay to proceed.

175
00:11:30.080 --> 00:11:35.000
Now our mileage might vary because they keep changing this command.

176
00:11:35.000 --> 00:11:37.040
It's really updated very often.

177
00:11:37.040 --> 00:11:43.480
But it's kind of a guided procedure to pick kind of a default or a starting configuration

178
00:11:43.480 --> 00:11:44.480
for ESLint.

179
00:11:44.480 --> 00:11:48.280
And it's very convenient because of course we don't need to remember by heart all the

180
00:11:48.280 --> 00:11:51.920
different options or presets and things like that.

181
00:11:51.920 --> 00:11:55.960
So we want to check syntax, find problems and enforce code style.

182
00:11:55.960 --> 00:11:59.240
We want to use JavaScript modules or CommonJS.

183
00:11:59.240 --> 00:12:01.880
I don't remember if we decided on that.

184
00:12:01.880 --> 00:12:02.880
We're using...

185
00:12:02.880 --> 00:12:08.880
Yeah, I think when we're trying to prepare for this, we were using ESM modules.

186
00:12:08.880 --> 00:12:09.880
Okay.

187
00:12:09.880 --> 00:12:10.880
So should be...

188
00:12:10.880 --> 00:12:12.280
Let's give it a go.

189
00:12:12.280 --> 00:12:13.280
Yeah.

190
00:12:13.280 --> 00:12:17.780
Let's try to be very brave and go with ESM.

191
00:12:17.780 --> 00:12:23.600
There are some interesting corner cases and edge cases you encounter with them, but maybe

192
00:12:23.600 --> 00:12:26.360
that'll be part of the fun.

193
00:12:26.360 --> 00:12:32.400
We have also a question by Mauro on YouTube saying, isn't PMPM usually used for Monorepo?

194
00:12:32.400 --> 00:12:34.360
Honestly, I don't know.

195
00:12:34.360 --> 00:12:40.760
I know that PMPM is just a faster version of MPM because it does things more in parallel,

196
00:12:40.760 --> 00:12:42.260
but I never use it.

197
00:12:42.260 --> 00:12:44.440
So don't know.

198
00:12:44.440 --> 00:12:49.520
Feel free to try it and let us know if you find any meaningful difference in terms of

199
00:12:49.520 --> 00:12:52.000
how to manage the Monorepos as well.

200
00:12:52.000 --> 00:12:53.000
Okay.

201
00:12:53.000 --> 00:12:54.000
So...

202
00:12:54.000 --> 00:12:59.360
I'm still trying to figure out how MPM workspaces works, especially for service projects.

203
00:12:59.360 --> 00:13:03.000
And maybe this is something we can deal with when we start adding third party dependencies

204
00:13:03.000 --> 00:13:07.200
into different services in the repo and figure out how to package them.

205
00:13:07.200 --> 00:13:08.200
Yeah, exactly.

206
00:13:08.200 --> 00:13:11.120
I also use it for very simple cases.

207
00:13:11.120 --> 00:13:16.120
So there might be edge cases that we haven't discovered yet, but the gist of it should

208
00:13:16.120 --> 00:13:21.240
be that if you're an MPM installer at the top level of the project, it should go inside

209
00:13:21.240 --> 00:13:24.840
every workspace and install all the necessary dependencies.

210
00:13:24.840 --> 00:13:29.520
So it's convenient that way that you can just do MPM installer at the top level.

211
00:13:29.520 --> 00:13:35.160
And then it should also give you a way to import from packages in the same Monorepo.

212
00:13:35.160 --> 00:13:39.840
So for instance, we could have a utils package and we could be reusing that utils package

213
00:13:39.840 --> 00:13:44.720
in frontend, CLI, backend, and things like that.

214
00:13:44.720 --> 00:13:50.320
So it gives you a way to do this kind of cross import and your code is automatically linked.

215
00:13:50.320 --> 00:13:54.640
So if you do changes, you don't need to publish those changes at independent libraries to

216
00:13:54.640 --> 00:13:58.080
actually use the changes in the rest of the code.

217
00:13:58.080 --> 00:14:03.000
And then you have other advantages, like you can run a command in all workspaces.

218
00:14:03.000 --> 00:14:08.960
For instance, if we do tests, you could be running MPM tests in all workspaces and stuff

219
00:14:08.960 --> 00:14:09.960
like that.

220
00:14:09.960 --> 00:14:11.520
So it's very, very simple implementation.

221
00:14:11.520 --> 00:14:17.000
I think for instance, if you are used to using learner, learner has a lot more features,

222
00:14:17.000 --> 00:14:22.280
but at the same time, I don't think we need anything fancy right now.

223
00:14:22.280 --> 00:14:23.840
Okay.

224
00:14:23.840 --> 00:14:25.920
Do we want to use TypeScript or not?

225
00:14:25.920 --> 00:14:28.160
I'd say probably no.

226
00:14:28.160 --> 00:14:35.480
So I'm going to go with no, but we might revisit that decision at some point later.

227
00:14:35.480 --> 00:14:40.080
And do we want to run our code for now just not VS.

228
00:14:40.080 --> 00:14:41.080
Popular style guide.

229
00:14:41.080 --> 00:14:47.360
Now, do we want semicolons or not?

230
00:14:47.360 --> 00:14:51.800
I'll go with, I just defer to the popular opinion here.

231
00:14:51.800 --> 00:14:53.800
So I'm easy.

232
00:14:53.800 --> 00:14:58.840
I always adapt because otherwise it ends up in a big bike sharing discussion.

233
00:14:58.840 --> 00:14:59.840
Okay.

234
00:14:59.840 --> 00:15:01.480
Let's see if anyone.

235
00:15:01.480 --> 00:15:02.680
Okay.

236
00:15:02.680 --> 00:15:05.240
Is it possible to zoom VS code a little bit?

237
00:15:05.240 --> 00:15:06.800
It should be possible.

238
00:15:06.800 --> 00:15:10.320
Let me know if this is better.

239
00:15:10.320 --> 00:15:11.320
So okay.

240
00:15:11.320 --> 00:15:14.940
I'm going to go with standard just because it's not really a standard, but I like to

241
00:15:14.940 --> 00:15:16.920
present it is a standard.

242
00:15:16.920 --> 00:15:17.920
Sounds good.

243
00:15:17.920 --> 00:15:21.680
Configuration in JavaScript and now yes.

244
00:15:21.680 --> 00:15:22.680
MPM.

245
00:15:22.680 --> 00:15:23.680
Oh, nice.

246
00:15:23.680 --> 00:15:24.680
Now you can pick.

247
00:15:24.680 --> 00:15:25.680
Okay.

248
00:15:25.680 --> 00:15:26.680
Interesting.

249
00:15:26.680 --> 00:15:30.840
This is a new option I haven't seen before, but now you can pick your favorite package

250
00:15:30.840 --> 00:15:31.840
manager.

251
00:15:31.840 --> 00:15:33.260
We are using MPM.

252
00:15:33.260 --> 00:15:35.520
So let's stick with it.

253
00:15:35.520 --> 00:15:36.760
Perfect.

254
00:15:36.760 --> 00:15:45.520
And this should have created a default ESLint configuration for us.

255
00:15:45.520 --> 00:15:50.080
Now another thing that we should have been doing is type modules.

256
00:15:50.080 --> 00:15:51.920
Good one.

257
00:15:51.920 --> 00:15:52.920
Yeah.

258
00:15:52.920 --> 00:16:02.880
Because this one allows us to use ESM everywhere without having to call the files CJS or MJS.

259
00:16:02.880 --> 00:16:10.320
So every JS file will automatically default to ECMAScript modules, which means that we'll

260
00:16:10.320 --> 00:16:12.760
need to rename this one CJS.

261
00:16:12.760 --> 00:16:19.000
Cause this is like a special case where it needs to use module.export.

262
00:16:19.000 --> 00:16:20.720
Okay.

263
00:16:20.720 --> 00:16:29.120
So do we want to do anything else in terms of bootstrap in the project?

264
00:16:29.120 --> 00:16:30.120
Let's see.

265
00:16:30.120 --> 00:16:31.920
I think from a JavaScript point of view, that's okay.

266
00:16:31.920 --> 00:16:37.760
Next we're onto the more AWS and serverless specific.

267
00:16:37.760 --> 00:16:40.960
So I'm going to do a commit with what we have so far.

268
00:16:40.960 --> 00:16:41.960
Okay.

269
00:16:41.960 --> 00:16:43.240
That sounds good.

270
00:16:43.240 --> 00:16:53.120
So we have created a new ESLint, gitignore, license, backend, package log and packages.

271
00:16:53.120 --> 00:16:58.720
Perfect.

272
00:16:58.720 --> 00:17:02.640
Okay.

273
00:17:02.640 --> 00:17:06.840
Now you should be able to see these changes in the repository.

274
00:17:06.840 --> 00:17:08.920
Okay.

275
00:17:08.920 --> 00:17:13.840
So I suppose the next step is based on what we saw here.

276
00:17:13.840 --> 00:17:19.720
We need to have a way to create all this infrastructure and to start to write the code for our Lambda.

277
00:17:19.720 --> 00:17:25.900
And this is also another topic where there are lots of different options, but I suppose

278
00:17:25.900 --> 00:17:30.680
one of the most famous ones is the serverless framework.

279
00:17:30.680 --> 00:17:34.120
So let's actually show it here.

280
00:17:34.120 --> 00:17:39.060
Serverless framework, serverless.com.

281
00:17:39.060 --> 00:17:44.940
So this is basically a way to, it's a framework that you can install and use it in your project,

282
00:17:44.940 --> 00:17:50.840
but allows you to define all the infrastructure in a YAML file, and then allows you to deploy

283
00:17:50.840 --> 00:17:53.080
that infrastructure together with your code.

284
00:17:53.080 --> 00:17:57.520
And every time you do changes, behind the scenes, it's actually using cloud formation,

285
00:17:57.520 --> 00:18:03.360
so you can actually deploy changes incrementally and you don't have to worry too much about

286
00:18:03.360 --> 00:18:05.760
how do I replicate these changes in different environments.

287
00:18:05.760 --> 00:18:09.920
You just do deploy and it's just gonna make sure that your infrastructure converges to

288
00:18:09.920 --> 00:18:15.800
the final state that you currently have in your code base.

289
00:18:15.800 --> 00:18:21.000
I don't know if I'm describing that well enough, but yeah, we're going to see it in action.

290
00:18:21.000 --> 00:18:26.800
YAML will tell a thousand words when we get going with our serverless.yaml.

291
00:18:26.800 --> 00:18:28.400
All will become clear.

292
00:18:28.400 --> 00:18:29.400
Certainly.

293
00:18:29.400 --> 00:18:32.360
If I remember correctly.

294
00:18:32.360 --> 00:18:39.560
Oh yeah, we also have DRAM, no semicolons please.

295
00:18:39.560 --> 00:18:42.080
So I'm glad we picked that option.

296
00:18:42.080 --> 00:18:45.160
That is the bullet there.

297
00:18:45.160 --> 00:18:49.980
Okay, so we can bootstrap our serverless project with the generator.

298
00:18:49.980 --> 00:18:51.440
That's our first step, is that it?

299
00:18:51.440 --> 00:18:53.920
Yeah, remind me the command because I'm not sure I remember.

300
00:18:53.920 --> 00:18:56.000
I think there is an NPX-SLS.

301
00:18:56.000 --> 00:19:03.480
It seems to be, yeah, NPX-SLS or NPX serverless, and then the command is create.

302
00:19:03.480 --> 00:19:07.440
And then we want to do, we want to pick a template.

303
00:19:07.440 --> 00:19:14.880
So it's, yeah, dash dash template, or I think you can also use single dash T and AWS dash

304
00:19:14.880 --> 00:19:15.880
Node.js.

305
00:19:15.880 --> 00:19:18.120
Like this, right?

306
00:19:18.120 --> 00:19:20.960
Yeah, and you're within the root.

307
00:19:20.960 --> 00:19:21.960
Yeah.

308
00:19:21.960 --> 00:19:22.960
Oh yeah.

309
00:19:22.960 --> 00:19:25.760
Actually you want to be in the backend directory, I think for this.

310
00:19:25.760 --> 00:19:27.480
So let's copy all of this.

311
00:19:27.480 --> 00:19:31.800
Although you can pass a directory, but I don't know what the path is off the top of my head.

312
00:19:31.800 --> 00:19:35.440
Let's do the same thing.

313
00:19:35.440 --> 00:19:37.040
Okay.

314
00:19:37.040 --> 00:19:38.160
Okay.

315
00:19:38.160 --> 00:19:43.240
Now you've got a serverless.yaml that is much bigger than you need.

316
00:19:43.240 --> 00:19:45.560
So you can start trimming.

317
00:19:45.560 --> 00:19:48.240
Let's look what we have here.

318
00:19:48.240 --> 00:19:49.240
Okay.

319
00:19:49.240 --> 00:19:54.200
We get a bunch of comments that we're going to remove just to keep things minimal.

320
00:19:54.200 --> 00:19:57.160
So the service is being called backend.

321
00:19:57.160 --> 00:19:59.280
It's just taking the name of the folder.

322
00:19:59.280 --> 00:20:01.720
We could rename that.

323
00:20:01.720 --> 00:20:05.120
Probably let's call it WeShare.

324
00:20:05.120 --> 00:20:18.240
Click, or WeShare or WC, WC sounds a bit funny.

325
00:20:18.240 --> 00:20:23.040
Then this is basically saying that we use the version of serverless framework, number

326
00:20:23.040 --> 00:20:24.040
three, version three.

327
00:20:24.040 --> 00:20:29.080
There are different versions and the yaml that you write can change a little bit depending

328
00:20:29.080 --> 00:20:30.820
on which version to use.

329
00:20:30.820 --> 00:20:32.740
So we want to use the latest.

330
00:20:32.740 --> 00:20:35.920
Now here is using by default node 12.

331
00:20:35.920 --> 00:20:39.680
We want to use node 16.

332
00:20:39.680 --> 00:20:45.560
Do we need to specify the region here or is it going to infer it by what we have?

333
00:20:45.560 --> 00:20:50.120
Oh, we lost Eoin.

334
00:20:50.120 --> 00:20:54.840
I think I'm going to specify the region here.

335
00:20:54.840 --> 00:20:57.120
We lost Eoin for a second.

336
00:20:57.120 --> 00:20:59.120
Eoin is back.

337
00:20:59.120 --> 00:21:01.160
I'm back.

338
00:21:01.160 --> 00:21:05.220
I back buttoned on the browser.

339
00:21:05.220 --> 00:21:06.800
You ejected yourself.

340
00:21:06.800 --> 00:21:12.240
Do you remember if this one is mandatory or not?

341
00:21:12.240 --> 00:21:13.240
That's a good question.

342
00:21:13.240 --> 00:21:19.160
I always specify it because I want to be explicit.

343
00:21:19.160 --> 00:21:21.120
I'm guessing it is, but I don't know.

344
00:21:21.120 --> 00:21:23.840
Maybe somebody knows the answer to that and they can tell us.

345
00:21:23.840 --> 00:21:29.480
I think it's maybe a good default because if different people are contributing to this

346
00:21:29.480 --> 00:21:35.520
project and they might have different default regions, probably this is going to be making

347
00:21:35.520 --> 00:21:39.880
sure that everyone uses the same region at the end of the day, right?

348
00:21:39.880 --> 00:21:40.880
Yeah.

349
00:21:40.880 --> 00:21:44.880
And you might make this configurable, but I think it's good to be clear in that.

350
00:21:44.880 --> 00:21:45.880
Okay.

351
00:21:45.880 --> 00:21:48.720
Now here we have an example about how to add permissions.

352
00:21:48.720 --> 00:21:55.320
I'm going to ignore all of this because we are going to be using probably a plugin that

353
00:21:55.320 --> 00:21:57.920
allows us to do this in a slightly different way.

354
00:21:57.920 --> 00:22:01.160
Yeah, let's get rid of that.

355
00:22:01.160 --> 00:22:06.200
So actually I'm going to delete all of this.

356
00:22:06.200 --> 00:22:11.240
Then we can also define environment variables, which we don't need right now.

357
00:22:11.240 --> 00:22:17.560
And we can define which files needs to be included or excluded.

358
00:22:17.560 --> 00:22:19.840
I don't think we need to do any of that.

359
00:22:19.840 --> 00:22:20.840
Right?

360
00:22:20.840 --> 00:22:21.840
Yeah.

361
00:22:21.840 --> 00:22:23.840
We don't need that right now.

362
00:22:23.840 --> 00:22:30.080
If we really want to trim things down later, we can, but generally it's not needed.

363
00:22:30.080 --> 00:22:32.360
Okay.

364
00:22:32.360 --> 00:22:36.360
So now this is the interesting part.

365
00:22:36.360 --> 00:22:37.360
This is very generic.

366
00:22:37.360 --> 00:22:39.160
Like what's the name of the service?

367
00:22:39.160 --> 00:22:40.580
What's the framework?

368
00:22:40.580 --> 00:22:41.580
What is the provider?

369
00:22:41.580 --> 00:22:45.920
This is actually interesting because serverless framework can work not just with AWS, but

370
00:22:45.920 --> 00:22:51.200
also with other providers like Azure or Google cloud, I believe.

371
00:22:51.200 --> 00:22:56.580
So here we are basically configuring more kind of generic project level settings.

372
00:22:56.580 --> 00:22:59.420
We want to say, we want to use AWS as a provider.

373
00:22:59.420 --> 00:23:05.320
We want to specifically use Node.js for everything that is like compute, like Lambda functions

374
00:23:05.320 --> 00:23:08.080
and the region is this one.

375
00:23:08.080 --> 00:23:11.000
And this is where we start to specify Lambda functions.

376
00:23:11.000 --> 00:23:19.520
And by default, there is like an L-law function and we can see that this also created an handler.js.

377
00:23:19.520 --> 00:23:24.560
So this is basically saying we want to have a function called a law where the code lives

378
00:23:24.560 --> 00:23:28.000
inside handler, which is handler.js.

379
00:23:28.000 --> 00:23:35.480
So this is, we need to change this because by default is using common JS, but you can

380
00:23:35.480 --> 00:23:40.980
have kind of a starting point for your Lambda function.

381
00:23:40.980 --> 00:23:42.400
And I think that's all.

382
00:23:42.400 --> 00:23:45.360
Then here we have a bunch of other examples.

383
00:23:45.360 --> 00:23:50.440
We have outputs and other resources.

384
00:23:50.440 --> 00:23:57.360
Do we want to create, do we want to start from the function or do you think it's best

385
00:23:57.360 --> 00:24:02.320
to do something else before?

386
00:24:02.320 --> 00:24:08.140
How about starting with the bucket since this is the center of our architecture?

387
00:24:08.140 --> 00:24:09.140
That's a good point.

388
00:24:09.140 --> 00:24:10.140
Yeah.

389
00:24:10.140 --> 00:24:11.140
So let's do that.

390
00:24:11.140 --> 00:24:15.520
Maybe we can even deploy the bucket and then start writing the function.

391
00:24:15.520 --> 00:24:17.160
Okay.

392
00:24:17.160 --> 00:24:22.960
We can probably leave the L-law function there and deploy just to show how a function is

393
00:24:22.960 --> 00:24:23.960
created.

394
00:24:23.960 --> 00:24:27.840
So resources is basically a more generic thing, which is actually behind the scenes is going

395
00:24:27.840 --> 00:24:29.420
to use CloudFormation.

396
00:24:29.420 --> 00:24:36.480
So here we actually going to be using mostly CloudFormation syntax while functions is kind

397
00:24:36.480 --> 00:24:39.880
of a higher level idea.

398
00:24:39.880 --> 00:24:43.600
It kind of makes it a little bit easier to create CloudFormation resources.

399
00:24:43.600 --> 00:24:45.300
It's way less verbose.

400
00:24:45.300 --> 00:24:48.020
It's going to take a bunch of defaults for you.

401
00:24:48.020 --> 00:24:51.020
But I think the first time you see this, it might be a little bit confusing because at

402
00:24:51.020 --> 00:24:56.540
the end of the day, they are both creating a bunch of CloudFormation resources.

403
00:24:56.540 --> 00:25:02.640
So you could be doing everything even without writing this and just writing pure CloudFormation

404
00:25:02.640 --> 00:25:03.640
here.

405
00:25:03.640 --> 00:25:08.080
But of course, at that point you are kind of losing the benefits of using serverless

406
00:25:08.080 --> 00:25:09.200
framework.

407
00:25:09.200 --> 00:25:15.920
So we are going to be using functions for everything that regards AWS Lambda functions.

408
00:25:15.920 --> 00:25:18.800
And this is going to make our life much easier to do that.

409
00:25:18.800 --> 00:25:24.360
But then for things like buckets, we are going to be using resources because I'm not aware

410
00:25:24.360 --> 00:25:27.320
if there is an easier way to do that in serverless framework.

411
00:25:27.320 --> 00:25:28.320
Yeah.

412
00:25:28.320 --> 00:25:33.840
I mean, when you create a bucket, you have one resource that creates a bucket.

413
00:25:33.840 --> 00:25:38.320
When you create a function with the serverless framework, you have a function which might

414
00:25:38.320 --> 00:25:42.280
have a configured version as well.

415
00:25:42.280 --> 00:25:46.060
And then if you have an event trigger, you might have a lot of API gateway resources

416
00:25:46.060 --> 00:25:47.060
as well.

417
00:25:47.060 --> 00:25:53.260
So sometimes like five lines of YAML in serverless framework will actually generate 200 lines

418
00:25:53.260 --> 00:25:57.680
of CloudFormation with 15 or 20 different resources.

419
00:25:57.680 --> 00:25:59.820
And maybe we can do that later on.

420
00:25:59.820 --> 00:26:06.520
You can run the serverless package command and we can see the generated output of CloudFormation.

421
00:26:06.520 --> 00:26:09.320
We can appreciate that we don't have to write it.

422
00:26:09.320 --> 00:26:10.320
That's a good idea.

423
00:26:10.320 --> 00:26:11.440
Let's do the bucket first.

424
00:26:11.440 --> 00:26:17.100
So the idea is that this is the syntax where we can start to specify resources.

425
00:26:17.100 --> 00:26:21.760
So you can see that YAML is very nested.

426
00:26:21.760 --> 00:26:26.920
And for every year, it's basically an array of different resources.

427
00:26:26.920 --> 00:26:32.880
And it's actually a key value pair where every item has a name.

428
00:26:32.880 --> 00:26:37.800
For instance, here we want to give it a name, I don't know, file bucket.

429
00:26:37.800 --> 00:26:40.600
And then here we specify all the properties.

430
00:26:40.600 --> 00:26:43.960
And the properties are generally a type.

431
00:26:43.960 --> 00:26:48.280
And in this case, the type is, if I remember correctly, something like this.

432
00:26:48.280 --> 00:26:51.540
Yeah, auto complete is helping me.

433
00:26:51.540 --> 00:26:54.200
And then you generally have properties.

434
00:26:54.200 --> 00:26:57.960
And properties, they will be different depending on the type that you are using.

435
00:26:57.960 --> 00:27:02.340
In this case, they are properties that make sense in the context of an S3 bucket.

436
00:27:02.340 --> 00:27:05.520
So definitely we're going to have something like bucket name.

437
00:27:05.520 --> 00:27:12.520
And here, this is interesting because we can call it some random name for now.

438
00:27:12.520 --> 00:27:14.560
But in reality, we really want to make it random.

439
00:27:14.560 --> 00:27:18.720
So we will see how to do that in a second.

440
00:27:18.720 --> 00:27:23.640
And then there are some kind of best practices that we can use.

441
00:27:23.640 --> 00:27:29.600
For instance, generally when you do a bucket, you want to make sure that it is encrypted.

442
00:27:29.600 --> 00:27:36.800
So what we can do is do something like bucket encryption.

443
00:27:36.800 --> 00:27:37.800
Specify...

444
00:27:37.800 --> 00:27:38.800
Oh, I like that.

445
00:27:38.800 --> 00:27:41.200
The auto compute is doing all of this for me.

446
00:27:41.200 --> 00:27:46.080
But we can say something like server side encryption by default.

447
00:27:46.080 --> 00:27:48.280
Yeah, that's what I wanted to do.

448
00:27:48.280 --> 00:27:51.880
And here, AES2056.

449
00:27:51.880 --> 00:27:54.600
Now if you search online, you are going to find the stuff.

450
00:27:54.600 --> 00:27:57.660
This is something that we looked up before.

451
00:27:57.660 --> 00:28:00.760
You don't need to remember by art all these things.

452
00:28:00.760 --> 00:28:05.600
But the idea is basically every file that is going to be in this bucket, it's automatically

453
00:28:05.600 --> 00:28:07.480
encrypted server side.

454
00:28:07.480 --> 00:28:11.200
And it's going to be using this particular algorithm.

455
00:28:11.200 --> 00:28:16.160
So it's not using KMS keys, which is the other option.

456
00:28:16.160 --> 00:28:19.260
So AWS is kind of managing all the keys for you.

457
00:28:19.260 --> 00:28:21.560
You don't need to worry too much about keys.

458
00:28:21.560 --> 00:28:27.360
If you want more control, you can use your own keys through KMS.

459
00:28:27.360 --> 00:28:31.200
And another thing is that we want to limit public access.

460
00:28:31.200 --> 00:28:34.440
So we can do this one.

461
00:28:34.440 --> 00:28:38.920
And then there are a bunch of properties that I'm actually checking in another tab.

462
00:28:38.920 --> 00:28:42.800
So I'm not going to pretend I remember them by art.

463
00:28:42.800 --> 00:28:48.480
But basically we want to block public ACL, which means if somebody is trying to make

464
00:28:48.480 --> 00:28:54.080
this bucket public by mistake or whatever reason, this configuration is going to prevent

465
00:28:54.080 --> 00:28:55.080
that.

466
00:28:55.080 --> 00:28:56.080
Right?

467
00:28:56.080 --> 00:28:57.080
Yeah.

468
00:28:57.080 --> 00:28:58.080
I remember.

469
00:28:58.080 --> 00:28:59.960
I always copy paste this too.

470
00:28:59.960 --> 00:29:02.200
There are four properties, right?

471
00:29:02.200 --> 00:29:04.320
And then this is very similar.

472
00:29:04.320 --> 00:29:05.760
Ignore public ACL.

473
00:29:05.760 --> 00:29:06.760
True.

474
00:29:06.760 --> 00:29:15.960
Like this is trying to prevent all the possible ways that this bucket could be made public.

475
00:29:15.960 --> 00:29:18.720
Do we need anything else?

476
00:29:18.720 --> 00:29:21.400
So I think these are the best.

477
00:29:21.400 --> 00:29:22.880
These are the good security practices.

478
00:29:22.880 --> 00:29:27.200
You know, we've got a config rules that warn us when we create buckets that don't have

479
00:29:27.200 --> 00:29:31.600
encryption turned on and that are public, that can be made public.

480
00:29:31.600 --> 00:29:35.520
The other thing that I have recently started adding into all bucket declarations is to

481
00:29:35.520 --> 00:29:40.560
turn on event bridge notifications, which is a relatively new feature.

482
00:29:40.560 --> 00:29:46.660
But it makes sense because that means you can start reacting to objects being added

483
00:29:46.660 --> 00:29:49.600
or removed from the bucket using event bridge.

484
00:29:49.600 --> 00:29:55.240
So you don't have to use some of the older methods like CloudTrail or S3 notifications,

485
00:29:55.240 --> 00:29:57.280
which were a lot more limited.

486
00:29:57.280 --> 00:30:01.920
So it's definitely a good idea, I think, to add in event bridge notification.

487
00:30:01.920 --> 00:30:07.280
So if you create a bucket in the AWS console, there's a checkbox for this.

488
00:30:07.280 --> 00:30:12.880
In CloudFormation, it's under the notification configuration property.

489
00:30:12.880 --> 00:30:14.880
Yeah.

490
00:30:14.880 --> 00:30:20.280
And I think we have an example for that if we just want to add it there.

491
00:30:20.280 --> 00:30:21.280
Yep.

492
00:30:21.280 --> 00:30:23.560
I'm just going to copy paste.

493
00:30:23.560 --> 00:30:25.120
Should be something like this.

494
00:30:25.120 --> 00:30:30.520
For some reason, Visual Studio got better like this property, but I think it's connect.

495
00:30:30.520 --> 00:30:33.240
Because it's new, maybe.

496
00:30:33.240 --> 00:30:34.240
Okay.

497
00:30:34.240 --> 00:30:37.080
I've seen that Andrea has a questionnaire.

498
00:30:37.080 --> 00:30:38.800
So he's asking the only...

499
00:30:38.800 --> 00:30:40.340
It's more of a comment, I guess.

500
00:30:40.340 --> 00:30:44.160
The only issue I found by putting S3 buckets in the serverless configuration is that when

501
00:30:44.160 --> 00:30:49.060
I needed to remove the stack for any reason, I redeployed all the objects and the bucket

502
00:30:49.060 --> 00:30:50.060
were deleted.

503
00:30:50.060 --> 00:30:53.460
This is a very good point.

504
00:30:53.460 --> 00:30:57.800
And I think that there are ways to limit that behavior.

505
00:30:57.800 --> 00:31:01.820
For instance, there is definitely a way to make sure that the bucket is not deleted.

506
00:31:01.820 --> 00:31:04.520
I think it's called deletion policy.

507
00:31:04.520 --> 00:31:05.520
Yeah.

508
00:31:05.520 --> 00:31:08.760
This is a CloudFormation property that you can put on lots of different resources like

509
00:31:08.760 --> 00:31:12.360
DynamoDB tables as well.

510
00:31:12.360 --> 00:31:15.660
It's not within the bucket policy itself, but it's actually at the higher level.

511
00:31:15.660 --> 00:31:18.960
So it's a sibling of properties itself.

512
00:31:18.960 --> 00:31:20.960
So we'll need to put it here.

513
00:31:20.960 --> 00:31:21.960
Yeah.

514
00:31:21.960 --> 00:31:24.280
Still doesn't like it, but...

515
00:31:24.280 --> 00:31:25.840
Doesn't like it.

516
00:31:25.840 --> 00:31:26.840
Okay.

517
00:31:26.840 --> 00:31:29.440
I trust you that this is correct.

518
00:31:29.440 --> 00:31:30.440
Trust but verify.

519
00:31:30.440 --> 00:31:31.440
Yeah.

520
00:31:31.440 --> 00:31:34.480
We'll verify what gets generated later.

521
00:31:34.480 --> 00:31:40.820
So one issue on that is CloudFormation won't delete objects from your bucket.

522
00:31:40.820 --> 00:31:45.800
So if people have seen that in the past, it might be because you're using some tooling

523
00:31:45.800 --> 00:31:50.400
that is deleting objects for you.

524
00:31:50.400 --> 00:31:52.760
It shouldn't delete your bucket with objects.

525
00:31:52.760 --> 00:31:59.320
But what this does is it just makes sure that even if the bucket is empty, it won't be deleted

526
00:31:59.320 --> 00:32:02.240
when we delete the stack.

527
00:32:02.240 --> 00:32:03.240
Yeah.

528
00:32:03.240 --> 00:32:04.240
Okay.

529
00:32:04.240 --> 00:32:08.860
So at this point, what we can do is we can see what gets generated, right?

530
00:32:08.860 --> 00:32:14.640
So we can do SLS package, if I remember correctly, right?

531
00:32:14.640 --> 00:32:16.560
Which is basically...

532
00:32:16.560 --> 00:32:20.240
It's not deploying, it's just bundling up everything.

533
00:32:20.240 --> 00:32:26.520
And then we can see what would eventually get deployed if we proceed with that package.

534
00:32:26.520 --> 00:32:30.300
So it's kind of a preview in what's going to be produced for us.

535
00:32:30.300 --> 00:32:33.420
And we can see that there is a new folder here called.serverless.

536
00:32:33.420 --> 00:32:39.280
So if we go in there, we have a bunch of CloudFormations and this serverless state JSON.

537
00:32:39.280 --> 00:32:45.880
Now I think the one that is most interesting is the first one, CreateStack.

538
00:32:45.880 --> 00:32:50.640
The CreateStack is the one that creates the bucket that serverless framework is going

539
00:32:50.640 --> 00:32:53.040
to use to deploy its own assets.

540
00:32:53.040 --> 00:32:58.280
So all of your stuff is going to be in the update stack, because it does this kind of

541
00:32:58.280 --> 00:33:01.880
two phase update on the first deployment.

542
00:33:01.880 --> 00:33:07.440
And this is because serverless will need to upload certain assets to be able to proceed

543
00:33:07.440 --> 00:33:08.440
with the deploy.

544
00:33:08.440 --> 00:33:10.440
So this is kind of a bootstrapping thing.

545
00:33:10.440 --> 00:33:11.440
It's a bootstrap.

546
00:33:11.440 --> 00:33:12.440
Yeah.

547
00:33:12.440 --> 00:33:13.440
Okay.

548
00:33:13.440 --> 00:33:16.860
So this is the one we are actually interested in, which looks almost identical because we

549
00:33:16.860 --> 00:33:19.560
have...

550
00:33:19.560 --> 00:33:21.440
Actually this one is the same, right?

551
00:33:21.440 --> 00:33:24.160
It's literally serverless deployment bucket.

552
00:33:24.160 --> 00:33:31.120
It should have the same bucket because it has to make sure that it keeps that bucket.

553
00:33:31.120 --> 00:33:32.120
And now...

554
00:33:32.120 --> 00:33:36.520
Then that's also their bucket, but it's just the policy, the bucket policy.

555
00:33:36.520 --> 00:33:38.160
This is our file bucket.

556
00:33:38.160 --> 00:33:39.160
Yep.

557
00:33:39.160 --> 00:33:40.160
Okay.

558
00:33:40.160 --> 00:33:43.000
It is actually adding this deletion policy, retained.

559
00:33:43.000 --> 00:33:45.880
Type, is that one properties?

560
00:33:45.880 --> 00:33:49.560
Now this, some random name is something that we definitely need to change.

561
00:33:49.560 --> 00:33:55.320
And we'll talk about that in a second, but everything else seems to make sense.

562
00:33:55.320 --> 00:33:56.320
Yeah.

563
00:33:56.320 --> 00:33:57.320
Okay.

564
00:33:57.320 --> 00:34:01.480
And when we do this, when we have a function that will look a little...

565
00:34:01.480 --> 00:34:06.000
When we have a more complex function, it will look a lot more interesting.

566
00:34:06.000 --> 00:34:09.800
Now why do we need to change this some random name?

567
00:34:09.800 --> 00:34:15.780
Because an interesting thing about S3 buckets is that they have to have a unique name across

568
00:34:15.780 --> 00:34:18.220
every account and every region.

569
00:34:18.220 --> 00:34:23.920
So if we try to use some random name, maybe we get lucky, meaning that nobody else ever

570
00:34:23.920 --> 00:34:25.620
used this one.

571
00:34:25.620 --> 00:34:31.360
But if somebody just tries to deploy the same stack as it is, they will bump into a conflict

572
00:34:31.360 --> 00:34:33.760
with whoever deployed first.

573
00:34:33.760 --> 00:34:39.760
So it's better to actually have a way to generate a random string straight away.

574
00:34:39.760 --> 00:34:45.700
Now this is not something that you can do easily with just a CloudFormation itself,

575
00:34:45.700 --> 00:34:49.360
but because we are using serverless framework, serverless framework actually gives us ways

576
00:34:49.360 --> 00:34:57.040
to interpolate code, let's say, or code generated strings into whatever is going to be the result

577
00:34:57.040 --> 00:34:58.040
in CloudFormation.

578
00:34:58.040 --> 00:35:00.720
So it's kind of a template language at the same time.

579
00:35:00.720 --> 00:35:08.280
It's not just giving us an easier way to create some resources, but it also gives us more

580
00:35:08.280 --> 00:35:13.280
abilities in terms of how do we structure the infrastructure as code.

581
00:35:13.280 --> 00:35:14.800
How do we write infrastructure as code?

582
00:35:14.800 --> 00:35:21.600
We have more functionality in terms of string interpolation and things like that.

583
00:35:21.600 --> 00:35:27.920
So if I remember correctly, it is possible to create a JavaScript file that actually

584
00:35:27.920 --> 00:35:33.120
executes some logic and then the result of that logic, it can be a string and then we

585
00:35:33.120 --> 00:35:38.440
can use that string in our template, in our serverless.yaml, right?

586
00:35:38.440 --> 00:35:44.920


587
00:35:44.920 --> 00:35:49.360
Yeah, there's a specific function signature and I'm going to link into the documentation in serverless.com, serverless framework documentation that tells you how to do this.

588
00:35:49.360 --> 00:35:52.660
So you can check that too.

589
00:35:52.660 --> 00:36:02.480
So we can call this file, I don't know, unique target name.js.

590
00:36:02.480 --> 00:36:04.060
Actually it needs to be common.js.

591
00:36:04.060 --> 00:36:14.400
So we need to do cjs and then basically what we do here, module.exports equal, it can be

592
00:36:14.400 --> 00:36:20.200
an async function.

593
00:36:20.200 --> 00:36:30.280
And basically whatever we return is going to be a variable that we can use in our own.

594
00:36:30.280 --> 00:36:34.280
By the way, I'm using Copilot.

595
00:36:34.280 --> 00:36:38.520
Copilot is trying to suggest us something which is not really what we want to do.

596
00:36:38.520 --> 00:36:40.280
No, this looks like a Lambda handler.

597
00:36:40.280 --> 00:36:42.400
You're writing a Lambda function.

598
00:36:42.400 --> 00:36:44.720
But the idea is that we might be doing something like this.

599
00:36:44.720 --> 00:36:52.200
We might be doing, I don't know, bucket name and something random.

600
00:36:52.200 --> 00:36:56.800
Then we should be able to reference this bucket name.

601
00:36:56.800 --> 00:37:01.840
And before we implement all of that, let's try to wire things in and see if it's actually

602
00:37:01.840 --> 00:37:09.560
giving us something random in the final, in the final CloudFormation template.

603
00:37:09.560 --> 00:37:18.480
So here what we want to do is basically we can use, I think it's like this syntax, right?

604
00:37:18.480 --> 00:37:20.520
We need quotes?

605
00:37:20.520 --> 00:37:22.680
You don't need quotes for this.

606
00:37:22.680 --> 00:37:23.680
You just need to...

607
00:37:23.680 --> 00:37:26.960
And it's like file or something like that.

608
00:37:26.960 --> 00:37:29.920
Let's see if I remember.

609
00:37:29.920 --> 00:37:32.920
It's file, yeah.

610
00:37:32.920 --> 00:37:36.800
And then there's no colon actually at this point.

611
00:37:36.800 --> 00:37:38.800
So it's file and then parentheses.

612
00:37:38.800 --> 00:37:39.800
Right.

613
00:37:39.800 --> 00:37:40.800
Okay.

614
00:37:40.800 --> 00:37:41.800
Yeah.

615
00:37:41.800 --> 00:37:42.800
I can check.

616
00:37:42.800 --> 00:37:43.800
I'm verifying all of this in the background.

617
00:37:43.800 --> 00:37:44.800
So don't worry.

618
00:37:44.800 --> 00:37:45.800
It's not all off the top of my head.

619
00:37:45.800 --> 00:37:47.940
And then the path.

620
00:37:47.940 --> 00:37:55.340
We call it unique bucket name.cjs.

621
00:37:55.340 --> 00:37:56.960
If I can type.

622
00:37:56.960 --> 00:37:59.720
And then at that point it gives you back an object.

623
00:37:59.720 --> 00:38:03.180
Let's say like it kind of runs that file and gives you back an object.

624
00:38:03.180 --> 00:38:08.720
So we can just reference bucket name, which is one of the properties that we export from

625
00:38:08.720 --> 00:38:09.720
that file.

626
00:38:09.720 --> 00:38:10.720
Yeah.

627
00:38:10.720 --> 00:38:11.720
That's it.

628
00:38:11.720 --> 00:38:16.960
Now you just need to check the spelling of unique there to match the file name.

629
00:38:16.960 --> 00:38:23.600
Now if we repackage all of that.

630
00:38:23.600 --> 00:38:24.900
It was very fast.

631
00:38:24.900 --> 00:38:28.820
So if we check here, now it is something random.

632
00:38:28.820 --> 00:38:35.800
So just to show that I'm not lying, if we change this to something random too, and we

633
00:38:35.800 --> 00:38:41.440
run this again, it should give us something different now.

634
00:38:41.440 --> 00:38:42.780
Yeah.

635
00:38:42.780 --> 00:38:44.640
Something random too.

636
00:38:44.640 --> 00:38:45.920
Okay.

637
00:38:45.920 --> 00:38:51.600
So now the trick is that we need to generate something random that is consistently random,

638
00:38:51.600 --> 00:38:52.600
right?

639
00:38:52.600 --> 00:38:53.600
Yeah.

640
00:38:53.600 --> 00:38:54.600
Yeah.

641
00:38:54.600 --> 00:38:58.700
So a lot of times what you would do here is you don't necessarily have to do this JavaScript

642
00:38:58.700 --> 00:38:59.960
module approach.

643
00:38:59.960 --> 00:39:05.600
You can just put like an interpolated string using CloudFormation substitutions or serverless

644
00:39:05.600 --> 00:39:10.860
variables where you just add in your account ID and the region as a suffix onto your bucket

645
00:39:10.860 --> 00:39:12.160
name.

646
00:39:12.160 --> 00:39:16.640
But for our application, since the URLs we generate will include the bucket name, we

647
00:39:16.640 --> 00:39:22.160
want to be a little bit more protective of our account name maybe and the name of our

648
00:39:22.160 --> 00:39:26.480
bucket or the account name.

649
00:39:26.480 --> 00:39:30.840
Just make it a little bit more obtuse, I suppose.

650
00:39:30.840 --> 00:39:35.800
So we just want to generate something from these variables rather than exposing our account

651
00:39:35.800 --> 00:39:39.440
ID in the bucket itself.

652
00:39:39.440 --> 00:39:45.440
So I'm going to copy paste a solution that we developed before, but basically the idea

653
00:39:45.440 --> 00:39:53.320
is that we could hash some information that we get for the current account region and

654
00:39:53.320 --> 00:39:59.620
use that as a unique key because at that point we are guaranteed that if you try to deploy

655
00:39:59.620 --> 00:40:03.360
the same thing in a different account or a different region, you will get a different

656
00:40:03.360 --> 00:40:04.360
bucket.

657
00:40:04.360 --> 00:40:08.040
But as long as you use the same account in the same region, you always get the same bucket

658
00:40:08.040 --> 00:40:09.800
name consistently.

659
00:40:09.800 --> 00:40:14.240
So you don't end up with a different bucket at every deployment, which is basically what

660
00:40:14.240 --> 00:40:16.040
we are trying to avoid.

661
00:40:16.040 --> 00:40:20.720
On one side, we want something pseudo random, on the other side it needs to be consistently

662
00:40:20.720 --> 00:40:26.380
the same value for the same account and region.

663
00:40:26.380 --> 00:40:31.640
So we can use the create hash function from Node.js.

664
00:40:31.640 --> 00:40:38.120
And then an interesting thing is that you could get some information here by the serverless

665
00:40:38.120 --> 00:40:39.120
framework.

666
00:40:39.120 --> 00:40:45.200
So serverless framework is going to run this code by passing certain things into it.

667
00:40:45.200 --> 00:40:51.320
And this result variable is a function that allows you to actually retrieve information

668
00:40:51.320 --> 00:40:53.580
from the current context.

669
00:40:53.580 --> 00:40:59.200
So for instance, we can get the current account like this.

670
00:40:59.200 --> 00:41:01.040
Then we could get the region.

671
00:41:01.040 --> 00:41:03.280
Yeah, this is exactly what I wanted to do.

672
00:41:03.280 --> 00:41:04.720
Thank you, Copilot.

673
00:41:04.720 --> 00:41:07.800
And then we can get the stage.

674
00:41:07.800 --> 00:41:11.200
AWS stage.

675
00:41:11.200 --> 00:41:13.160
Actually region is slightly different.

676
00:41:13.160 --> 00:41:19.800
I think we want provider.region.

677
00:41:19.800 --> 00:41:20.800
Stage should be...

678
00:41:20.800 --> 00:41:27.520
No, I think you could do self provider.region or AWS colon region is a new variable in serverless

679
00:41:27.520 --> 00:41:29.960
version 3 that you can use directly.

680
00:41:29.960 --> 00:41:30.960
Interesting.

681
00:41:30.960 --> 00:41:31.960
Okay.

682
00:41:31.960 --> 00:41:35.960
Should we try region then?

683
00:41:35.960 --> 00:41:39.800
Yeah, that's good to go.

684
00:41:39.800 --> 00:41:44.480
Andrea has another useful comment actually about this particular topic.

685
00:41:44.480 --> 00:41:47.480
SLS print to display all the...

686
00:41:47.480 --> 00:41:49.400
Oh, that's a good one.

687
00:41:49.400 --> 00:41:50.400
Let's see.

688
00:41:50.400 --> 00:41:54.080
Yeah, we can try that.

689
00:41:54.080 --> 00:41:55.920
I don't like something.

690
00:41:55.920 --> 00:41:56.920
Stage.

691
00:41:56.920 --> 00:41:59.080
Yeah, we have AWS colon stage.

692
00:41:59.080 --> 00:42:05.600
That should be SLS colon stage because that's a serverless specific.

693
00:42:05.600 --> 00:42:07.640
Right.

694
00:42:07.640 --> 00:42:09.840
Okay.

695
00:42:09.840 --> 00:42:14.120
Now it's actually printing all our...

696
00:42:14.120 --> 00:42:17.760
Like a preview of our transformation without having to package.

697
00:42:17.760 --> 00:42:18.760
Yeah, that's a good point.

698
00:42:18.760 --> 00:42:19.760
Yeah.

699
00:42:19.760 --> 00:42:20.760
Thank you.

700
00:42:20.760 --> 00:42:21.760
It resolves all the variables.

701
00:42:21.760 --> 00:42:25.000
It's not CloudFormation strictly because it still has the high level of functions and

702
00:42:25.000 --> 00:42:26.000
stuff.

703
00:42:26.000 --> 00:42:27.000
Okay.

704
00:42:27.000 --> 00:42:32.680
So at this point we still are returning something random too, but we have information that we

705
00:42:32.680 --> 00:42:34.240
can hash.

706
00:42:34.240 --> 00:42:44.280
So basically what we can do is say const input equal and we can do a string like we share

707
00:42:44.280 --> 00:42:52.760
and then account hash region dash stage.

708
00:42:52.760 --> 00:42:55.600
Thank you, Co-Pilot.

709
00:42:55.600 --> 00:43:07.840
And at this point, the bucket name we want to generate is basically...

710
00:43:07.840 --> 00:43:08.840
Let's see.

711
00:43:08.840 --> 00:43:11.780
What we can do is we still want to retain a prefix, right?

712
00:43:11.780 --> 00:43:21.440
So let's say we share hash plus create hash MD5 update input.

713
00:43:21.440 --> 00:43:24.480
Yeah, that's exactly what I want.

714
00:43:24.480 --> 00:43:25.480
Nice.

715
00:43:25.480 --> 00:43:32.040
So this is basically saying take all the string, hash it using MD5, and then prepend this we

716
00:43:32.040 --> 00:43:35.260
share dash, whatever is the hash.

717
00:43:35.260 --> 00:43:39.300
Now at this point, we can just read out this bucket name.

718
00:43:39.300 --> 00:43:44.060
And if we do this again, we should get something slightly different.

719
00:43:44.060 --> 00:43:47.160
We share something something.

720
00:43:47.160 --> 00:43:55.040
And because these values are not going to change, we should get the same bucket again.

721
00:43:55.040 --> 00:43:57.760
Makes sense?

722
00:43:57.760 --> 00:43:59.000
Cool.

723
00:43:59.000 --> 00:44:03.160
Should we try to deploy all of this?

724
00:44:03.160 --> 00:44:04.160
This makes sense.

725
00:44:04.160 --> 00:44:06.160
Yeah, let's deploy.

726
00:44:06.160 --> 00:44:07.160
Okay.

727
00:44:07.160 --> 00:44:09.240
We have some credentials set up.

728
00:44:09.240 --> 00:44:11.120
Do I have credentials?

729
00:44:11.120 --> 00:44:16.080
I think I did have credentials in another terminal.

730
00:44:16.080 --> 00:44:17.080
Let's see.

731
00:44:17.080 --> 00:44:18.960
Here I don't think I have credentials.

732
00:44:18.960 --> 00:44:21.400
Here I have my own credentials.

733
00:44:21.400 --> 00:44:26.720
So how do we do this?

734
00:44:26.720 --> 00:44:30.680
I think I can deploy from here.

735
00:44:30.680 --> 00:44:35.560
I can, we can do SLS deploy, right?

736
00:44:35.560 --> 00:44:42.000
That's actually let me make sure we have the right credentials.

737
00:44:42.000 --> 00:44:43.000
I do.

738
00:44:43.000 --> 00:44:44.840
That looks good to me.

739
00:44:44.840 --> 00:44:47.560
And now we can do just SLS deploy should be enough, right?

740
00:44:47.560 --> 00:44:49.640
We don't need any other option.

741
00:44:49.640 --> 00:44:54.720
Yep, that looks good.

742
00:44:54.720 --> 00:44:56.720
Okay.

743
00:44:56.720 --> 00:45:01.880
This is creating the CloudFormation stack.

744
00:45:01.880 --> 00:45:07.000


745
00:45:07.000 --> 00:45:08.920
So this should just create our bucket and that default boilerplate Lambda function we have.

746
00:45:08.920 --> 00:45:19.440
So if we go into the AWS console, we should see that these resources are being created.

747
00:45:19.440 --> 00:45:27.120
Meanwhile we have a question from Juan Lopez from YouTube saying the need for uniqueness

748
00:45:27.120 --> 00:45:32.280
across bucket name in S3 is something that I had to deal with in the past.

749
00:45:32.280 --> 00:45:37.320
I will not have expected that S3 bucket names needs to be unique across S3 and not only

750
00:45:37.320 --> 00:45:40.960
your account or region as well, I guess.

751
00:45:40.960 --> 00:45:46.040
And I think the main reason for that is that because S3 is like one of the oldest services.

752
00:45:46.040 --> 00:45:53.000
So probably some of the thinking that happens now when AWS create a new service didn't happen

753
00:45:53.000 --> 00:45:54.840
at the time.

754
00:45:54.840 --> 00:45:59.860
And the other thing is that S3 creates domain names.

755
00:45:59.860 --> 00:46:04.080
So in that sense, the name of a bucket is kind of one-to-one to the domain name that

756
00:46:04.080 --> 00:46:05.580
gets created.

757
00:46:05.580 --> 00:46:09.640
And also some of the rules for creating a bucket name are pretty much the same rules

758
00:46:09.640 --> 00:46:11.920
for a domain name, right?

759
00:46:11.920 --> 00:46:18.320
So I think that was the idea at the time and probably AWS now is stuck with that decision.

760
00:46:18.320 --> 00:46:20.080
Okay.

761
00:46:20.080 --> 00:46:21.440
So everything was deployed.

762
00:46:21.440 --> 00:46:30.600
I should be able to go into the account and show you that we have the bucket deployed.

763
00:46:30.600 --> 00:46:33.120
Let me bring up another window.

764
00:46:33.120 --> 00:46:34.120
Okay.

765
00:46:34.120 --> 00:46:38.240
I have it here.

766
00:46:38.240 --> 00:46:43.560
Let me make this a little bit bigger.

767
00:46:43.560 --> 00:46:47.800
So I am filtering because in this account we have so many more buckets, but you can

768
00:46:47.800 --> 00:46:50.400
see the two buckets were created.

769
00:46:50.400 --> 00:46:56.960
This is the bucket created by serverless framework for dealing with the deployments.

770
00:46:56.960 --> 00:47:01.200
This is the one that we just created from our resource.

771
00:47:01.200 --> 00:47:03.560
Okay.

772
00:47:03.560 --> 00:47:10.880
So maybe what I can do now is commit all these changes and that's it to you, Eoin, for writing

773
00:47:10.880 --> 00:47:12.880
some Lambda code.

774
00:47:12.880 --> 00:47:14.200
Okay.

775
00:47:14.200 --> 00:47:18.720
Actually, status, git add.

776
00:47:18.720 --> 00:47:23.280
Should I add the handler for now?

777
00:47:23.280 --> 00:47:25.280
Yeah, we will change it.

778
00:47:25.280 --> 00:47:29.560
Either way is good.

779
00:47:29.560 --> 00:47:30.560
Serverless.

780
00:47:30.560 --> 00:47:31.560
Okay.

781
00:47:31.560 --> 00:47:50.200
So whenever you are ready, feel free to share your screen.

782
00:47:50.200 --> 00:47:55.640
We also have Gil in the chat who is sending us a chicken, a log gill.

783
00:47:55.640 --> 00:48:03.520
We also like chickens.

784
00:48:03.520 --> 00:48:05.240
Do you need to stop sharing the channel?

785
00:48:05.240 --> 00:48:07.240
Yes, I need to switch.

786
00:48:07.240 --> 00:48:08.240
Excellent.

787
00:48:08.240 --> 00:48:13.160
Let me pull down these latest changes.

788
00:48:13.160 --> 00:48:16.680
By the way, Andrea is asking if the episode will be available later.

789
00:48:16.680 --> 00:48:18.960
We will definitely post it on YouTube.

790
00:48:18.960 --> 00:48:23.720
We are also considering to add it as an audio only podcast.

791
00:48:23.720 --> 00:48:27.800
I don't know if it makes sense, but we will probably try that anyway.

792
00:48:27.800 --> 00:48:31.280
So yeah, definitely we will make it available later in different ways.

793
00:48:31.280 --> 00:48:34.800
Hopefully, we will see you next time, Andrea.

794
00:48:34.800 --> 00:48:36.920
Thank you for all the questions and comments.

795
00:48:36.920 --> 00:48:38.480
Great tips.

796
00:48:38.480 --> 00:48:39.760
Okay.

797
00:48:39.760 --> 00:48:43.440
So we're about to set about creating a function.

798
00:48:43.440 --> 00:48:50.200
So if we go back to the architecture, maybe it's worth a quick look at that, actually.

799
00:48:50.200 --> 00:48:53.680


800
00:48:53.680 --> 00:48:59.960
We mentioned that we're going to create a function here that will create this kind of share that allows you to get a look at an upload URL and a download URL.

801
00:48:59.960 --> 00:49:04.000
So we're kind of in a restful sense, we're going to create a share object, but we don't

802
00:49:04.000 --> 00:49:05.560
create anything in a database.

803
00:49:05.560 --> 00:49:10.940
We're just going to talk to S3 here.

804
00:49:10.940 --> 00:49:11.940
So let's have a look at that.

805
00:49:11.940 --> 00:49:16.880
In serverless.yaml, we've got the existing function boilerplate.

806
00:49:16.880 --> 00:49:22.340
So let's try and take this and make something more of it.

807
00:49:22.340 --> 00:49:24.600
So let's say we're going to give our function a name.

808
00:49:24.600 --> 00:49:30.640
Now, this is just a name that the serverless framework uses to identify our function.

809
00:49:30.640 --> 00:49:39.040
So let's just call it create share because we're going to create a share resource.

810
00:49:39.040 --> 00:49:43.720
And we want this to be triggered by an API endpoint.

811
00:49:43.720 --> 00:49:46.440
So we're going to create an API endpoint.

812
00:49:46.440 --> 00:49:52.160
So our handler in our Lambda function code is going to be responding to this event.

813
00:49:52.160 --> 00:49:55.660
So let's call this handle.

814
00:49:55.660 --> 00:49:57.960
Let's just call it handle event.

815
00:49:57.960 --> 00:50:01.600
We might rename our handler to be a little bit more explicit.

816
00:50:01.600 --> 00:50:04.040
Let's call it share handler.

817
00:50:04.040 --> 00:50:09.820
And beyond that, we need to start wiring in the HTTP interfaces.

818
00:50:09.820 --> 00:50:12.080
So we've got a couple of ways of doing this.

819
00:50:12.080 --> 00:50:19.560
And within API gateway, we've got the API gateway rest API, which is the kind of traditional

820
00:50:19.560 --> 00:50:20.960
way of doing it.

821
00:50:20.960 --> 00:50:25.600
And now you have the kind of simpler and more cost effective way of doing it, which is the

822
00:50:25.600 --> 00:50:27.560
HTTP API method.

823
00:50:27.560 --> 00:50:35.240
I know these things aren't particularly well named, but HTTP API is pretty simple.

824
00:50:35.240 --> 00:50:36.820
So let's go with that one.

825
00:50:36.820 --> 00:50:41.880
So we're saying that this function is going to be triggered by a number of events because

826
00:50:41.880 --> 00:50:43.920
this is an array here we're creating.

827
00:50:43.920 --> 00:50:46.560
So this function can be triggered by more than one.

828
00:50:46.560 --> 00:50:50.900
We're just going to restrict it to HTTP API events.

829
00:50:50.900 --> 00:50:53.560
So for that, we just need to give it the method.

830
00:50:53.560 --> 00:51:00.560
And since we're creating this share resource, then this will be a HTTP post and we can give

831
00:51:00.560 --> 00:51:03.720
it a path.

832
00:51:03.720 --> 00:51:08.680
Maybe one thing that is worth clarifying for people that never used Lambda before is that

833
00:51:08.680 --> 00:51:14.520
Lambda is not like something that is always running, but it's just a function that is

834
00:51:14.520 --> 00:51:18.440
automatically triggered by AWS when a specific event happens.

835
00:51:18.440 --> 00:51:24.640
So what we are doing here is basically telling AWS the event that we want to use to trigger

836
00:51:24.640 --> 00:51:32.200
our Lambda is an HTTP event in particular, like a post request to a particular path.

837
00:51:32.200 --> 00:51:33.200
Yeah.

838
00:51:33.200 --> 00:51:34.200
Yeah.

839
00:51:34.200 --> 00:51:36.540
This is definitely worth stating.

840
00:51:36.540 --> 00:51:44.360
We can give this a path and what we can do here is just give it the root path and why

841
00:51:44.360 --> 00:51:50.840
we do this at the root rather than creating like a specific path, like a share resource

842
00:51:50.840 --> 00:51:58.000
here, it will become more apparent when we look at introducing domain names and API later

843
00:51:58.000 --> 00:52:03.540
APIs later, because we can create all of the functions and APIs relating to this type of

844
00:52:03.540 --> 00:52:07.120
resource all within this serverless project.

845
00:52:07.120 --> 00:52:13.520
And then we can map it to a domain name with a path so we can actually apply the path later.

846
00:52:13.520 --> 00:52:16.960
And this makes it much easier to do that.

847
00:52:16.960 --> 00:52:20.880
So that's our handler code.

848
00:52:20.880 --> 00:52:26.000
This is a handler module we're going to have to write and this is the event and that's

849
00:52:26.000 --> 00:52:27.000
it.

850
00:52:27.000 --> 00:52:32.560
We will need to add some permissions, but maybe we can come back to that because that's

851
00:52:32.560 --> 00:52:40.960
maybe a little bit clearer just to write the handler code that will do the code that responds

852
00:52:40.960 --> 00:52:41.960
to the event.

853
00:52:41.960 --> 00:52:46.080
So let's start creating that handler now.

854
00:52:46.080 --> 00:52:50.040
So since we renamed it, handler.js is not going to work anymore.

855
00:52:50.040 --> 00:52:52.760
So let's just rename this to share handler.

856
00:52:52.760 --> 00:53:00.800
I must remember to use Node.js syntax rather than Python.

857
00:53:00.800 --> 00:53:01.800
Okay.

858
00:53:01.800 --> 00:53:06.480
So let's just rename this one.

859
00:53:06.480 --> 00:53:11.040
Okay.

860
00:53:11.040 --> 00:53:15.720
So we've got all sorts of hours here, like semicolons and common JS modules.

861
00:53:15.720 --> 00:53:20.800
So let's just make this and go from scratch.

862
00:53:20.800 --> 00:53:25.040
So the syntax of our handler is we're going to create a function.

863
00:53:25.040 --> 00:53:35.080
This will be an async function with the syntax for a Lambda function, which is that it takes

864
00:53:35.080 --> 00:53:37.520
an event and it also takes context.

865
00:53:37.520 --> 00:53:42.340
We will probably not use context in fact, so we can admit it completely, but let's just

866
00:53:42.340 --> 00:53:45.800
leave it in there for clarity maybe for now.

867
00:53:45.800 --> 00:53:51.120
And within this handler, we're going to do everything we need to create the get URL and

868
00:53:51.120 --> 00:53:54.900
the upload URL.

869
00:53:54.900 --> 00:53:58.040
So maybe we can just think about the syntax of this.

870
00:53:58.040 --> 00:54:00.560
This is an arrow function.

871
00:54:00.560 --> 00:54:05.720
This is an arrow function, so I'll need an arrow.

872
00:54:05.720 --> 00:54:07.220
So we've got a few steps, right?

873
00:54:07.220 --> 00:54:12.640
So what are the things we need to do in order to interact with S3 and generate an upload

874
00:54:12.640 --> 00:54:14.840
URL and a retrieval URL?

875
00:54:14.840 --> 00:54:21.080
So we're using the concept of S3 presigned URLs, which are really useful feature.

876
00:54:21.080 --> 00:54:27.260
And the beauty of that is that it allows us to offload all of the scalability for retrieving

877
00:54:27.260 --> 00:54:32.220
and uploading large files to S3 completely.

878
00:54:32.220 --> 00:54:37.560
So none of that file data ever has to actually go through any of the systems that we're building

879
00:54:37.560 --> 00:54:38.560
here.

880
00:54:38.560 --> 00:54:44.280
And that's really the goal because S3 is way better at handling the throughput and scalability

881
00:54:44.280 --> 00:54:47.760
that would be required if the system was to scale.

882
00:54:47.760 --> 00:54:54.320


883
00:54:54.320 --> 00:54:59.920
Yeah, I guess another advantage to that is that signed URLs allow us to define certain like boundaries for which the file can be uploaded or downloaded.

884
00:54:59.920 --> 00:55:03.480
Now I think for the first version, we're not going to worry too much, but in the future,

885
00:55:03.480 --> 00:55:08.820
we might use that for instance, to limit the time that the file is going to be available,

886
00:55:08.820 --> 00:55:13.880
just as an example, but you can put other like boundaries and they are just built in.

887
00:55:13.880 --> 00:55:15.880
You just need to configure specific properties.

888
00:55:15.880 --> 00:55:19.040
You don't need to implement additional codes for that.

889
00:55:19.040 --> 00:55:20.320
Yeah.

890
00:55:20.320 --> 00:55:25.280
So just referring back to the diagram, then we're creating this function here and we've

891
00:55:25.280 --> 00:55:29.920
already declared everything we need to do for the API gateway endpoint.

892
00:55:29.920 --> 00:55:31.840
We've declared the post.

893
00:55:31.840 --> 00:55:36.080
We're just using the root path at the moment.

894
00:55:36.080 --> 00:55:38.720
And the next thing we need to do is then create presigned URLs.

895
00:55:38.720 --> 00:55:43.880
So maybe let's just pseudocode this out or comment about the steps we need to do.

896
00:55:43.880 --> 00:55:48.600
So when we think about it, if we want people to be able to upload an object, we need to

897
00:55:48.600 --> 00:55:51.980
have some sort of identifier for this file or object.

898
00:55:51.980 --> 00:56:00.960
So we should probably first create a key or a file or a file name.

899
00:56:00.960 --> 00:56:10.720
Then we'd want to create an upload URL and then we create the download URL.

900
00:56:10.720 --> 00:56:16.200
And finally we'll return something like an object, right?

901
00:56:16.200 --> 00:56:25.600
So this is an API gateway Lambda proxy, which means that API gateway is proxying to the

902
00:56:25.600 --> 00:56:27.600
Lambda service internally within AWS.

903
00:56:27.600 --> 00:56:32.040
So there's a specific contract that you'll have to obey here.

904
00:56:32.040 --> 00:56:37.640
That means when you return your response, it should have HTTP status code.

905
00:56:37.640 --> 00:56:42.240
And if you want to return a body, it should also have a body and you can also return HTTP

906
00:56:42.240 --> 00:56:44.400
response headers.

907
00:56:44.400 --> 00:56:51.440
So in the status code, I guess what we want is a 201, right?

908
00:56:51.440 --> 00:56:56.560
Because we're creating something and that would indicate we've successfully created

909
00:56:56.560 --> 00:56:59.880
something and then we're going to create a body.

910
00:56:59.880 --> 00:57:11.000
So this will be something with a download URL and upload URL.

911
00:57:11.000 --> 00:57:12.680
So let's go through this.

912
00:57:12.680 --> 00:57:19.380
So we need to start using the AWS SDK because we're going to interact with S3.

913
00:57:19.380 --> 00:57:22.220
So let's set about that.

914
00:57:22.220 --> 00:57:27.540
In order to get this to work, we'll need to install a few modules.

915
00:57:27.540 --> 00:57:31.200
So Luciano, is it a good time to talk about the AWS SDK v3?

916
00:57:31.200 --> 00:57:38.120


917
00:57:38.120 --> 00:57:42.640
I think we covered it on the podcast actually a couple of months back, but it works quite a different way to the one we're used to, the AWS SDK version two.

918
00:57:42.640 --> 00:57:47.120
Yeah, I think it's interesting to show how it works.

919
00:57:47.120 --> 00:57:48.120
Okay.

920
00:57:48.120 --> 00:57:50.120
Okay, good.

921
00:57:50.120 --> 00:57:59.800
So these are the two modules that we researched and know we need to use in order to interact

922
00:57:59.800 --> 00:58:00.800
with S3.

923
00:58:00.800 --> 00:58:08.240
So you have the, everything is a separate module, the AWS SDK v3, that allows you to

924
00:58:08.240 --> 00:58:11.920
have very small bundles of modules when you deploy.

925
00:58:11.920 --> 00:58:14.720
So we actually have two that we can use here.

926
00:58:14.720 --> 00:58:19.440
We have the S3 one and we have the S3 request presigner one, which is a separate module

927
00:58:19.440 --> 00:58:22.520
just for doing presigning.

928
00:58:22.520 --> 00:58:27.560
And I'm installing those as dev dependencies actually.

929
00:58:27.560 --> 00:58:28.560
Is that a good idea Luciano?

930
00:58:28.560 --> 00:58:32.560
Or should we be installing these as top level dependencies?

931
00:58:32.560 --> 00:58:38.800


932
00:58:38.800 --> 00:58:42.000
I would probably consider this top level dependencies because they need to be available when we run our code in production, right?

933
00:58:42.000 --> 00:58:47.800
It's not just something we use for building or for testing.

934
00:58:47.800 --> 00:58:54.160
And Lambda does provide the AWS SDK in the runtime, but if you want to be sure that you're

935
00:58:54.160 --> 00:58:59.240
pinning to a specific version that you've tested with, this is a good practice.

936
00:58:59.240 --> 00:59:00.920
Okay.

937
00:59:00.920 --> 00:59:09.360
So now that we've got that, let's set about importing these and getting to use our S3

938
00:59:09.360 --> 00:59:10.360
client.

939
00:59:10.360 --> 00:59:11.360
Okay.

940
00:59:11.360 --> 00:59:15.600
So there's, the first thing we need to do is get our S3 client.

941
00:59:15.600 --> 00:59:19.240
So the syntax for that is S3 client.

942
00:59:19.240 --> 00:59:24.600
There's a couple of ways you can use the AWS SDK version three, one of which is very similar

943
00:59:24.600 --> 00:59:29.440
to SDK version two.

944
00:59:29.440 --> 00:59:35.120
But the new kind of idiomatic way to do it with the version three client is with the

945
00:59:35.120 --> 00:59:36.680
command pattern.

946
00:59:36.680 --> 00:59:43.560
So if you want to be able to create, get an object from S3 or put an object, then you're

947
00:59:43.560 --> 00:59:50.180
basically sending a command to get object command or put object command to the S3 service.

948
00:59:50.180 --> 00:59:59.280
So let's import the classes we need to do that from the S3 client module.

949
00:59:59.280 --> 01:00:05.220
And even though we're not doing the upload or the download in this handler, we're generating

950
01:00:05.220 --> 01:00:10.520
a presigned URL, but the presigned URL needs to know what is the command that this URL

951
01:00:10.520 --> 01:00:13.340
will ultimately fulfill.

952
01:00:13.340 --> 01:00:17.240
So that's the pattern we're following here.

953
01:00:17.240 --> 01:00:18.680
So let's just have a quick look.

954
01:00:18.680 --> 01:00:25.260
Maybe we'll do the download URL first.

955
01:00:25.260 --> 01:00:32.200
So maybe what we can do is just have a look at the syntax of the get object command.

956
01:00:32.200 --> 01:00:41.180
So let's say we create this command, get object command.

957
01:00:41.180 --> 01:00:46.100
So we're creating a new instance of this get object command that needs the properties that

958
01:00:46.100 --> 01:00:49.600
get object command accepts, which is going to be a bucket.

959
01:00:49.600 --> 01:00:51.900
So we need to figure out what our bucket name is.

960
01:00:51.900 --> 01:00:56.920
I'm going to suggest that we take that from an environment variable, and then we're going

961
01:00:56.920 --> 01:00:58.760
to need a key.

962
01:00:58.760 --> 01:01:02.380
So the key is the path to this file.

963
01:01:02.380 --> 01:01:04.820
So we're missing a couple of things here.

964
01:01:04.820 --> 01:01:06.820
We've got red lines all over the place.

965
01:01:06.820 --> 01:01:11.940
So what we need to do is make sure we import the environment variable so we can take that

966
01:01:11.940 --> 01:01:20.100
from process.env.

967
01:01:20.100 --> 01:01:22.060
And the key is something we can generate.

968
01:01:22.060 --> 01:01:24.540
So let's figure out how we would generate that.

969
01:01:24.540 --> 01:01:33.340
I think it makes sense to use like a UUID, like you have version 4 UUID for that.

970
01:01:33.340 --> 01:01:36.500
And there's a new, you don't need to install a third party dependency for that anymore

971
01:01:36.500 --> 01:01:38.060
in Node.js, do you?

972
01:01:38.060 --> 01:01:43.120
Yeah, I think since node 14 or 16, I'm not sure.

973
01:01:43.120 --> 01:01:47.420
But yeah, you have now built in functionality in the crypto module.

974
01:01:47.420 --> 01:01:48.420
Excellent.

975
01:01:48.420 --> 01:01:53.260
Can I ask you a question, Luciano, because I don't know the answer to this.

976
01:01:53.260 --> 01:01:56.260
I saw that I had two autocomplete options here.

977
01:01:56.260 --> 01:02:00.140
One was crypto and one was node crypto.

978
01:02:00.140 --> 01:02:04.080
And I've seen people use both, but I'm not sure what the difference is.

979
01:02:04.080 --> 01:02:05.080
To be honest.

980
01:02:05.080 --> 01:02:06.080
Can you clarify?

981
01:02:06.080 --> 01:02:11.860
Yeah, node column crypto is the recommended way, I would say right now, because the idea

982
01:02:11.860 --> 01:02:20.420
is that the module resolution algorithm, the way that it does to resolve a package is by

983
01:02:20.420 --> 01:02:23.780
giving precedence to whatever you have in your node modules.

984
01:02:23.780 --> 01:02:29.100
So for instance, if you install a third party module called crypto, then you end up importing

985
01:02:29.100 --> 01:02:31.320
something that is not the node core crypto.

986
01:02:31.320 --> 01:02:36.380
So by doing node column crypto, you are kind of explicitly saying, I want to use the node

987
01:02:36.380 --> 01:02:37.380
JS one.

988
01:02:37.380 --> 01:02:43.500
Like in reality, this is not a very common problem, but because it has been a problem

989
01:02:43.500 --> 01:02:48.900
and it will be very hard to debug otherwise, I think this is why we have now this new best

990
01:02:48.900 --> 01:02:53.660
practice where every day you are importing a node core module, it's better to prefix

991
01:02:53.660 --> 01:02:55.140
it with node column.

992
01:02:55.140 --> 01:02:56.140
Okay.

993
01:02:56.140 --> 01:02:58.060
Yeah, that makes sense.

994
01:02:58.060 --> 01:03:03.980
I guess there could be a vulnerability if you have a spelling mistake in here, right?

995
01:03:03.980 --> 01:03:04.980
Yeah.

996
01:03:04.980 --> 01:03:10.820


997
01:03:10.820 --> 01:03:11.820
Because then somebody could have published some sort of supply chain attack thing to NPM.

998
01:03:11.820 --> 01:03:12.820
Okay.

999
01:03:12.820 --> 01:03:16.380
That's really good to know.

1000
01:03:16.380 --> 01:03:17.380
Yeah.

1001
01:03:17.380 --> 01:03:22.140
If you end up packaging a folder called crypto inside your node modules, whatever you have

1002
01:03:22.140 --> 01:03:24.180
there is going to take precedence.

1003
01:03:24.180 --> 01:03:25.180
Yeah.

1004
01:03:25.180 --> 01:03:26.180
Yeah.

1005
01:03:26.180 --> 01:03:27.180
Okay.

1006
01:03:27.180 --> 01:03:35.540
So let's, let's generate a UUID and from that we can create a key.

1007
01:03:35.540 --> 01:03:42.580
Now we could just make the key to be the ID, but if we think about lots of uploads of hundreds,

1008
01:03:42.580 --> 01:03:47.780
thousands, millions of files over time into the same bucket, it might not be a great user

1009
01:03:47.780 --> 01:03:53.420
experience when you open the S3 console and you see everything in one prefix, because

1010
01:03:53.420 --> 01:03:58.940
that's three, even though forward slashes in S3 don't really mean anything, there's

1011
01:03:58.940 --> 01:04:00.780
no such thing as paths.

1012
01:04:00.780 --> 01:04:06.340
They're more of a, just a user friendly way of browsing through files.

1013
01:04:06.340 --> 01:04:11.940
The S3 console will use slashes as a, in the same way as you would see in a traditional

1014
01:04:11.940 --> 01:04:13.780
file browser.

1015
01:04:13.780 --> 01:04:15.380
So maybe it's a good idea.

1016
01:04:15.380 --> 01:04:20.380
It's also, you know, there are cases if you have extremely high throughput on your bucket

1017
01:04:20.380 --> 01:04:26.140
that S3 will try to automatically partition the bucket based on prefixes.

1018
01:04:26.140 --> 01:04:32.540
So it is good to make sure that the start of your keys have kind of an even distribution

1019
01:04:32.540 --> 01:04:41.020
and that helps S3 to automatically partition the bucket for you so that you can get a throughput

1020
01:04:41.020 --> 01:04:43.660
allocation per partition.

1021
01:04:43.660 --> 01:04:49.780
So let's put everything into a shares prefix, but we'll use like the first two characters

1022
01:04:49.780 --> 01:05:03.780
of our UUID to just give us some sort of sorting or categorization.

1023
01:05:03.780 --> 01:05:10.100
Remember this used to be very, very common when doing similar things with like network

1024
01:05:10.100 --> 01:05:11.300
drives.

1025
01:05:11.300 --> 01:05:15.860
I think at the time there was also some, maybe depending on the file system, some performance

1026
01:05:15.860 --> 01:05:18.500
benefit to that.

1027
01:05:18.500 --> 01:05:22.060


1028
01:05:22.060 --> 01:05:27.240
But yeah, I think as a user, as you described the user experience, it makes a lot of sense to do the same thing here as well, because I mean, if we, if we ever need to debug something

1029
01:05:27.240 --> 01:05:32.860
where we know the UUID and we want to go in the S3 console to see the file, we know we

1030
01:05:32.860 --> 01:05:37.620
need to click twice to see that file rather than scrolling across potentially millions

1031
01:05:37.620 --> 01:05:39.220
of items.

1032
01:05:39.220 --> 01:05:40.460
Yeah.

1033
01:05:40.460 --> 01:05:41.820
Yeah.

1034
01:05:41.820 --> 01:05:43.140
Okay.

1035
01:05:43.140 --> 01:05:50.780
So we've got a key that allows us to create the get command.

1036
01:05:50.780 --> 01:05:54.460
And from that get command, we can create a URL.

1037
01:05:54.460 --> 01:06:00.700
So this will allow us to create a retrieval URL for our users to use.

1038
01:06:00.700 --> 01:06:06.100
So what we can do for that is the, we're going to start using the presigned URL module that

1039
01:06:06.100 --> 01:06:09.420
we already added into our node modules.

1040
01:06:09.420 --> 01:06:10.420
There is a separate.

1041
01:06:10.420 --> 01:06:17.220
So it's a separate module, we need to import that separately.

1042
01:06:17.220 --> 01:06:22.980
So this is the AWS SDK S3 request presigner and the function we're going to use is called

1043
01:06:22.980 --> 01:06:27.820
get signed URL.

1044
01:06:27.820 --> 01:06:30.340
These are asynchronous functions.

1045
01:06:30.340 --> 01:06:32.020
They're going to return a promise.

1046
01:06:32.020 --> 01:06:39.840
So we're a way to get signed URL and we need to pass in the command that we created.

1047
01:06:39.840 --> 01:06:45.580
So the function, you can see the function signature here is we need an S3 client and

1048
01:06:45.580 --> 01:06:47.260
we need a command.

1049
01:06:47.260 --> 01:06:55.020
So let's pass in S3 client, our get command and our properties.

1050
01:06:55.020 --> 01:07:01.640
So the properties that are kind of important here are the expiry.

1051
01:07:01.640 --> 01:07:05.940
So how long is this temporary presigned URL going to last for?

1052
01:07:05.940 --> 01:07:09.440
You want to make sure that it's long enough that people get to upload their content by

1053
01:07:09.440 --> 01:07:15.820
the time you send it to them, but not so long that maybe somebody could grab it and intervene.

1054
01:07:15.820 --> 01:07:24.580
So maybe we'll just create a constant at the top of our file that gives us some sort of

1055
01:07:24.580 --> 01:07:27.060
default expiration.

1056
01:07:27.060 --> 01:07:35.260
And I think maybe 24 hours seems like a good value to start with.

1057
01:07:35.260 --> 01:07:37.680
The value is in seconds.

1058
01:07:37.680 --> 01:07:44.980
So that will allow us to have URLs that last for a day.

1059
01:07:44.980 --> 01:07:45.980
Okay.

1060
01:07:45.980 --> 01:07:47.880
So we don't have an S3 client.

1061
01:07:47.880 --> 01:07:49.100
We can create one.

1062
01:07:49.100 --> 01:07:51.760
And that's fairly straightforward.

1063
01:07:51.760 --> 01:07:58.780
We can just do that outside the handler because it can be reused for multiple Lambda function

1064
01:07:58.780 --> 01:08:01.880
invocations.

1065
01:08:01.880 --> 01:08:08.560
So all of the code that's outside the handler is going to get evaluated when the function

1066
01:08:08.560 --> 01:08:09.940
is loaded for the first time.

1067
01:08:09.940 --> 01:08:15.840
So in cold start phase of your Lambda, everything within the handler is going to be evaluated

1068
01:08:15.840 --> 01:08:17.740
every time an event comes in.

1069
01:08:17.740 --> 01:08:20.640
Okay.

1070
01:08:20.640 --> 01:08:26.120
So now we've got a retrieval URL and the process for an upload URL is going to be very similar.

1071
01:08:26.120 --> 01:08:33.080
So much so that I'm just going to copy paste and change everything from get to put.

1072
01:08:33.080 --> 01:08:39.780
So we'll need a put command, which will use the same bucket and key because we have to

1073
01:08:39.780 --> 01:08:44.400
put it to that key before we get it.

1074
01:08:44.400 --> 01:08:50.040
And let's change the name of this to upload URL.

1075
01:08:50.040 --> 01:08:53.080
And that will use the put command.

1076
01:08:53.080 --> 01:08:54.560
Okay.

1077
01:08:54.560 --> 01:08:57.700
So I think now we have everything we need to give our users.

1078
01:08:57.700 --> 01:09:02.080
I think it's also interesting that you can specify two different expiries for the upload

1079
01:09:02.080 --> 01:09:03.440
and download.

1080
01:09:03.440 --> 01:09:08.520
Maybe you would want in real life the upload window to be very small while the download

1081
01:09:08.520 --> 01:09:10.760
can be even a week, I suppose.

1082
01:09:10.760 --> 01:09:11.760
Right.

1083
01:09:11.760 --> 01:09:12.760
That's a good idea.

1084
01:09:12.760 --> 01:09:13.760
Yeah.

1085
01:09:13.760 --> 01:09:19.240
But for now it makes sense to keep it the same because we can optimize it later.

1086
01:09:19.240 --> 01:09:20.240
Okay.

1087
01:09:20.240 --> 01:09:24.880
Now, since this is our MVP and we don't have a command line interface, we don't have a

1088
01:09:24.880 --> 01:09:30.720
web interface, we're giving our poor users two really ugly URLs.

1089
01:09:30.720 --> 01:09:33.440
It probably makes sense that we don't return any JSON here.

1090
01:09:33.440 --> 01:09:38.440
We can just return some instructions and the two URLs that they can use.

1091
01:09:38.440 --> 01:09:44.480
So we know that they could use something like curl as a command line interface to upload

1092
01:09:44.480 --> 01:09:46.360
and download their files.

1093
01:09:46.360 --> 01:09:51.080
So maybe we can just give those instructions in the output.

1094
01:09:51.080 --> 01:09:58.800
So the upload would be curl and with curl, we can do minus X put, because this is a put

1095
01:09:58.800 --> 01:10:00.940
command to upload.

1096
01:10:00.940 --> 01:10:07.200
So we need to specify the put method, put HTTP method, and then they can specify the

1097
01:10:07.200 --> 01:10:14.560
file name and the upload URL.

1098
01:10:14.560 --> 01:10:18.420
So that's the upload instruction for the user.

1099
01:10:18.420 --> 01:10:26.320
And we can say download with curl download URL.

1100
01:10:26.320 --> 01:10:28.600
I didn't call it download URL, did I?

1101
01:10:28.600 --> 01:10:31.600
Called it retrieval URL.

1102
01:10:31.600 --> 01:10:32.880
Yeah.

1103
01:10:32.880 --> 01:10:36.240
Good catch.

1104
01:10:36.240 --> 01:10:37.800
Okay.

1105
01:10:37.800 --> 01:10:45.880
So I think we have a function so we can export that.

1106
01:10:45.880 --> 01:10:50.880
Yeah, we need to export.

1107
01:10:50.880 --> 01:10:51.880
Okay.

1108
01:10:51.880 --> 01:10:56.880
Actually the...

1109
01:10:56.880 --> 01:10:59.840
Yeah.

1110
01:10:59.840 --> 01:11:14.080
I generally prefer to just say export function at the top and not even use the arrow function.

1111
01:11:14.080 --> 01:11:20.360
I think the, yeah, I'm thinking ahead to one of the ideas we have to improve this, which

1112
01:11:20.360 --> 01:11:21.360
is to use MIDI.

1113
01:11:21.360 --> 01:11:25.280
And in that case, we'll do it in two separate steps.

1114
01:11:25.280 --> 01:11:31.760
But okay, this is good and there's a couple of things we added here.

1115
01:11:31.760 --> 01:11:35.420
So we added some interactions with S3, which means we're going to need permissions.

1116
01:11:35.420 --> 01:11:38.040
We also added an environment variable usage.

1117
01:11:38.040 --> 01:11:41.560
So before this is going to work, we need to go back to our serverless.yaml and do some

1118
01:11:41.560 --> 01:11:42.560
changes.

1119
01:11:42.560 --> 01:11:47.840
Also, before we forget, I think we also need to specify type modules inside the package

1120
01:11:47.840 --> 01:11:51.280
JSON of the backend.

1121
01:11:51.280 --> 01:11:54.400
Because I think this is what AWS will see.

1122
01:11:54.400 --> 01:11:58.080
AWS is not going to see the top one we have created.

1123
01:11:58.080 --> 01:11:59.080
Okay.

1124
01:11:59.080 --> 01:12:00.080
Good call.

1125
01:12:00.080 --> 01:12:02.400
So it looks like that.

1126
01:12:02.400 --> 01:12:03.400
Is that correct?

1127
01:12:03.400 --> 01:12:06.000
I think so, yeah.

1128
01:12:06.000 --> 01:12:07.000
Okay.

1129
01:12:07.000 --> 01:12:08.000
Okay.

1130
01:12:08.000 --> 01:12:09.600
So let's add some environment variables.

1131
01:12:09.600 --> 01:12:12.240
So we've got...

1132
01:12:12.240 --> 01:12:16.000
We could do this per function, but I think since everything is going to be centered around

1133
01:12:16.000 --> 01:12:18.240
this bucket, we can do this globally.

1134
01:12:18.240 --> 01:12:21.160
So it will be applied to all functions.

1135
01:12:21.160 --> 01:12:24.380
And we want to say that every function will receive an environment variable called bucket

1136
01:12:24.380 --> 01:12:25.880
name.

1137
01:12:25.880 --> 01:12:31.960
So in order to pick up that bucket name, it has to use the variable that Luciano created

1138
01:12:31.960 --> 01:12:34.780
with that clever unique bucket name.

1139
01:12:34.780 --> 01:12:41.640
But we can also use the CloudFormation syntax to retrieve the name of the bucket.

1140
01:12:41.640 --> 01:12:47.720
So the shorthand for that looks like this ref file bucket.

1141
01:12:47.720 --> 01:12:56.240
And if you look in the CloudFormation documentation for AWS S3 bucket, it will tell you that every

1142
01:12:56.240 --> 01:12:59.800
CloudFormation resource outputs a reference.

1143
01:12:59.800 --> 01:13:03.820
And for buckets, that reference is the bucket name.

1144
01:13:03.820 --> 01:13:05.840
It's not consistent across all the different resources.

1145
01:13:05.840 --> 01:13:08.520
Sometimes it's an ARN or something else.

1146
01:13:08.520 --> 01:13:11.960
For buckets, we know this is a way to get the bucket name.

1147
01:13:11.960 --> 01:13:14.080
So that should work nicely.

1148
01:13:14.080 --> 01:13:19.400
I think for buckets, it kind of makes sense because it's guaranteed to be unique anyway.

1149
01:13:19.400 --> 01:13:22.440
Like an ARN is always unique.

1150
01:13:22.440 --> 01:13:24.040
Bucket name is always unique as well.

1151
01:13:24.040 --> 01:13:29.160
Again, it's not consistent, but if you think about uniqueness, it makes sense.

1152
01:13:29.160 --> 01:13:30.160
Yeah.

1153
01:13:30.160 --> 01:13:31.160
Okay.

1154
01:13:31.160 --> 01:13:37.640
Now, when we are adding in IAM permissions, the way I like to do it is using the IAM roles

1155
01:13:37.640 --> 01:13:40.520
per function serverless plugin.

1156
01:13:40.520 --> 01:13:46.720
So let's add in this plugin into our configuration here.

1157
01:13:46.720 --> 01:13:54.140
So the way to do that, there is a serverless native way to do that, but I'd like to just

1158
01:13:54.140 --> 01:13:56.020
do it explicitly with NPM.

1159
01:13:56.020 --> 01:14:01.320
So we'll do NPM install, and this is a development dependency.

1160
01:14:01.320 --> 01:14:04.880
And the name of the plugin is serverless IAM roles per function.

1161
01:14:04.880 --> 01:14:08.680
And this allows you to kind of honor the principle of least privilege by having a separate set

1162
01:14:08.680 --> 01:14:15.280
of IAM policy statements for every single function.

1163
01:14:15.280 --> 01:14:22.320
So at the top of our serverless.yaml, then we need to declare our plugins array, and

1164
01:14:22.320 --> 01:14:25.920
we just add in the module we've installed.

1165
01:14:25.920 --> 01:14:31.560
So this is a plugin that's going to get hooked into the lifecycle when we run serverless

1166
01:14:31.560 --> 01:14:33.880
package or serverless deploy.

1167
01:14:33.880 --> 01:14:43.040
And it will pick up the IAM policy statements for each individual function.

1168
01:14:43.040 --> 01:14:44.880
So let's start writing this then.

1169
01:14:44.880 --> 01:14:51.020
So the syntax is to declare IAM role statements inside the function instead of at the provider

1170
01:14:51.020 --> 01:14:52.280
level.

1171
01:14:52.280 --> 01:14:57.100
And then we need to start creating some statements for an IAM role for this function.

1172
01:14:57.100 --> 01:15:02.560
So this is the set of, this is the policy that the function will run with.

1173
01:15:02.560 --> 01:15:08.360
So every time an event comes in the API, the execution of that Lambda function or the code

1174
01:15:08.360 --> 01:15:13.760
within it will be run within this role.

1175
01:15:13.760 --> 01:15:19.200
So we want to allow, we need to allow the permissions that we're giving the signed URLs

1176
01:15:19.200 --> 01:15:22.880
because we're using the get object command, the put object command, we need permissions

1177
01:15:22.880 --> 01:15:25.580
to do those things.

1178
01:15:25.580 --> 01:15:37.360
So the actions we want are S3 get object and S3 put object.

1179
01:15:37.360 --> 01:15:51.320
And we'll try to be as specific as we possibly can be for this MVP.

1180
01:15:51.320 --> 01:15:59.120
So what we can do here is we essentially want for the resource identifier should be the

1181
01:15:59.120 --> 01:16:02.680
ARN of the bucket with the prefix attached to it.

1182
01:16:02.680 --> 01:16:07.000
So it's going to be something like ARN, AWS, S3.

1183
01:16:07.000 --> 01:16:13.200
You don't need to specify the account or the region because those things are, you know,

1184
01:16:13.200 --> 01:16:16.080
as Luciano said, it's globally unique.

1185
01:16:16.080 --> 01:16:18.240
Then we'll need here the bucket name.

1186
01:16:18.240 --> 01:16:23.080
So that's a placeholder for now, and then the path, which is shares.

1187
01:16:23.080 --> 01:16:27.000
We set everything with the go and shares after that it's pretty much random.

1188
01:16:27.000 --> 01:16:34.320
So we need a wildcard and we can also make use of another CloudFormation intrinsic function

1189
01:16:34.320 --> 01:16:37.920
with the short term syntax sub.

1190
01:16:37.920 --> 01:16:45.160
And this is basically saying to CloudFormation substitute variables inside that with some

1191
01:16:45.160 --> 01:16:47.800
resolved value.

1192
01:16:47.800 --> 01:16:56.520
So instead of bucket name, we can just put in file bucket and CloudFormation is going

1193
01:16:56.520 --> 01:17:00.640
to take the reference of that file bucket, which is the bucket name and pop it in here

1194
01:17:00.640 --> 01:17:01.640
in its place.

1195
01:17:01.640 --> 01:17:03.640
So that should be enough.

1196
01:17:03.640 --> 01:17:04.640
Yep.

1197
01:17:04.640 --> 01:17:08.920
One thing that is worth mentioning, I don't know if we made that very clear.

1198
01:17:08.920 --> 01:17:13.480
And again, this is more for people that are trying to do AWS for the first time that in

1199
01:17:13.480 --> 01:17:19.700
AWS, everything is by default, it's like blacklisted, like you cannot do anything.

1200
01:17:19.700 --> 01:17:24.860
So if we were not adding this policy, what will happen at runtime is that our Lambda

1201
01:17:24.860 --> 01:17:29.980
will fail as soon as it's going to try to do a get object or a put object operation,

1202
01:17:29.980 --> 01:17:32.380
because it doesn't have permission to do that.

1203
01:17:32.380 --> 01:17:36.240
Now that we added this policy, what's going to happen is that the Lambda is going to run

1204
01:17:36.240 --> 01:17:43.560
in a context where we authorized the action of get object and put object only in those

1205
01:17:43.560 --> 01:17:47.920
specific resources that match this particular expression here.

1206
01:17:47.920 --> 01:17:52.600
So everything inside our bucket, the start switch shares, and then whatever the file

1207
01:17:52.600 --> 01:17:53.600
name.

1208
01:17:53.600 --> 01:17:54.600
Yeah.

1209
01:17:54.600 --> 01:17:59.080
Yeah, that's a really good point.

1210
01:17:59.080 --> 01:18:07.120
And the other action we'll need is, well, we don't need it actually.

1211
01:18:07.120 --> 01:18:13.760
I was just thinking you could also add a list bucket permission.

1212
01:18:13.760 --> 01:18:18.600
Whether we do it or not, it doesn't really make a massive difference for this application,

1213
01:18:18.600 --> 01:18:22.800
but you could also allow users to list the bucket.

1214
01:18:22.800 --> 01:18:29.000
Why would you need a Lambda function that only gets or puts permissions to list bucket?

1215
01:18:29.000 --> 01:18:34.080
Well, the advantage of that, and we just use the ARN directly like this.

1216
01:18:34.080 --> 01:18:37.840
The advantage of that is it means that if you try to get an object that doesn't exist,

1217
01:18:37.840 --> 01:18:41.080
it will give you a 404 instead of a 403 error.

1218
01:18:41.080 --> 01:18:48.940
So it'll give you a not found response instead of a permissions error.

1219
01:18:48.940 --> 01:18:52.440
Because if you don't have permissions to list bucket, then it's not going to tell you whether

1220
01:18:52.440 --> 01:18:58.220
the object can't be retrieved because it doesn't exist or because you don't have permissions

1221
01:18:58.220 --> 01:19:00.400
to read it.

1222
01:19:00.400 --> 01:19:05.280
And I think that's everything we need.

1223
01:19:05.280 --> 01:19:07.120
Luciano, have I missed anything?

1224
01:19:07.120 --> 01:19:09.920
Are we ready to give this a run and try and deploy it?

1225
01:19:09.920 --> 01:19:13.320
I think we can try deploying it and see if it works.

1226
01:19:13.320 --> 01:19:14.320
Okay.

1227
01:19:14.320 --> 01:19:15.320
Exciting times.

1228
01:19:15.320 --> 01:19:16.540
So let's do this.

1229
01:19:16.540 --> 01:19:21.520
So I'm going to run serverless deploy within the backend folder.

1230
01:19:21.520 --> 01:19:25.880
Maybe I'll give it just some trepidation here.

1231
01:19:25.880 --> 01:19:30.080
I'm just going to try package.

1232
01:19:30.080 --> 01:19:34.280
We already have a validation error because it says I put in the word event.

1233
01:19:34.280 --> 01:19:39.000
I think what I need there is events, plural.

1234
01:19:39.000 --> 01:19:44.280
It's good that we get this kind of validation from serverless.

1235
01:19:44.280 --> 01:19:47.080
This would have been tricky to debug otherwise.

1236
01:19:47.080 --> 01:19:48.080
Yeah.

1237
01:19:48.080 --> 01:19:49.740
And it's pretty new.

1238
01:19:49.740 --> 01:19:51.360
It's only around the last year, I think.

1239
01:19:51.360 --> 01:19:54.440
So this validation has been there, but it's really good.

1240
01:19:54.440 --> 01:19:55.440
Okay.

1241
01:19:55.440 --> 01:19:56.440
So that's all the information that has been packaged.

1242
01:19:56.440 --> 01:20:00.960
Let's have a quick look at our generated CloudFormation.

1243
01:20:00.960 --> 01:20:02.280
Okay.

1244
01:20:02.280 --> 01:20:08.440
So now we can see that serverless framework is starting to really take over and do a lot

1245
01:20:08.440 --> 01:20:13.200
of work here, like creating a CloudFormation log group, or sorry, a CloudWatch logs group

1246
01:20:13.200 --> 01:20:14.960
log group for us.

1247
01:20:14.960 --> 01:20:15.960
It's creating our role.

1248
01:20:15.960 --> 01:20:17.600
So let's have a look at that.

1249
01:20:17.600 --> 01:20:22.240
The role can then be assumed by Lambda, which is important.

1250
01:20:22.240 --> 01:20:31.240
It has permissions to create logs.

1251
01:20:31.240 --> 01:20:36.280
One thing that I would like to mention there is that this is where we see the advantage

1252
01:20:36.280 --> 01:20:41.000
of serverless framework, because if we were doing the same thing with something like,

1253
01:20:41.000 --> 01:20:46.560
I don't know, Terraform or CloudFormation directly, you don't get anything for free.

1254
01:20:46.560 --> 01:20:51.240
Like you really need to know, okay, to create a Lambda, I need to create a role.

1255
01:20:51.240 --> 01:20:55.440
Then I need to create a log group, which are things that you always do all the time because

1256
01:20:55.440 --> 01:20:58.280
they are required for the Lambda to run.

1257
01:20:58.280 --> 01:21:02.680
So with serverless framework, we are actually getting all this stuff being created for us

1258
01:21:02.680 --> 01:21:09.040
for free using best practices, rather than having to copy paste all the stuff every time.

1259
01:21:09.040 --> 01:21:10.040
Yeah.

1260
01:21:10.040 --> 01:21:14.040
That's a really good point.

1261
01:21:14.040 --> 01:21:15.040
Yeah.

1262
01:21:15.040 --> 01:21:21.100
While we're on this topic, actually, one of the points that Juan has mentioned on the

1263
01:21:21.100 --> 01:21:26.360
YouTube chat is what is the best way to test locally?

1264
01:21:26.360 --> 01:21:32.320
And it's probably almost something that could be an episode in its own right.

1265
01:21:32.320 --> 01:21:35.480
You can definitely test these.

1266
01:21:35.480 --> 01:21:40.000
I think you need maybe to cover this topic very briefly.

1267
01:21:40.000 --> 01:21:44.240
You can test using, you need to write unit tests anyway to test your handlers and to

1268
01:21:44.240 --> 01:21:46.160
test the code within those handlers.

1269
01:21:46.160 --> 01:21:51.480
We've done it in a fairly simple way because we've got a very simple function today.

1270
01:21:51.480 --> 01:21:57.860
But you can also use now with AWS STK version 3, you can also use their mocks.

1271
01:21:57.860 --> 01:22:05.160
You can, because we're using serverless framework, you can use local simulation of the API gateway

1272
01:22:05.160 --> 01:22:10.800
and Lambda in order to test things a little bit more end to end before you deploy.

1273
01:22:10.800 --> 01:22:17.400
But once you've tested your code, unit tested your code, you want to get it into AWS and

1274
01:22:17.400 --> 01:22:20.740
test on AWS as quickly as possible and then start doing things like integration tests

1275
01:22:20.740 --> 01:22:24.300
and end to end tests for a real world application.

1276
01:22:24.300 --> 01:22:28.600
Because the local simulations can be very useful from time to time, but there's always

1277
01:22:28.600 --> 01:22:33.880
a point at which there are limitations you can't overcome.

1278
01:22:33.880 --> 01:22:34.880
Yeah.

1279
01:22:34.880 --> 01:22:40.720
For instance, here you start to bump into this kind of philosophical questions.

1280
01:22:40.720 --> 01:22:46.080
Okay, if I run things locally, should I test against the real S3 or should I simulate S3

1281
01:22:46.080 --> 01:22:47.560
as well locally?

1282
01:22:47.560 --> 01:22:53.200
And there are ways to simulate S3 locally, but as Eoin said, the degree of fidelity might

1283
01:22:53.200 --> 01:22:56.540
vary depending on what kind of features we are going to use.

1284
01:22:56.540 --> 01:23:01.120
So for simple use cases, maybe everything works as expected.

1285
01:23:01.120 --> 01:23:05.360
For as soon as you start to use more advanced features, you might start to bump into discrepancies

1286
01:23:05.360 --> 01:23:10.520
and you might have this kind of false sense of security because everything works locally.

1287
01:23:10.520 --> 01:23:14.000
Then you test it remotely and you bump into issues.

1288
01:23:14.000 --> 01:23:17.160
Another thing that is also very interesting is permissions.

1289
01:23:17.160 --> 01:23:22.520
When you test things locally, you end up using the permissions that you have as a user most

1290
01:23:22.520 --> 01:23:24.740
of the time, depending on which tool do you use.

1291
01:23:24.740 --> 01:23:29.600
But most of the time, all the tools, they will use your own local credentials.

1292
01:23:29.600 --> 01:23:33.080
And generally you have very broad credentials as an admin, right?

1293
01:23:33.080 --> 01:23:37.280
Because when you are deploying, you need a large set of credentials.

1294
01:23:37.280 --> 01:23:41.440
So you simulate your code with this large set of credentials and you don't realize that

1295
01:23:41.440 --> 01:23:44.500
you haven't specified your policies correctly.

1296
01:23:44.500 --> 01:23:48.320
So yeah, that's another use case that I've seen a lot of people test it locally, everything

1297
01:23:48.320 --> 01:23:52.900
works, then deploy, run it for the first time and they have a permission error and they

1298
01:23:52.900 --> 01:23:55.280
have to revisit their own permissions.

1299
01:23:55.280 --> 01:23:59.720
So I think it's still a very open debate whether you should try everything you can to test

1300
01:23:59.720 --> 01:24:05.080
locally or whether you should go as fast as possible to a real AWS environment and test

1301
01:24:05.080 --> 01:24:06.720
it there.

1302
01:24:06.720 --> 01:24:11.960
Usually there is some kind of middle ground that gives you benefits, but yeah, for this

1303
01:24:11.960 --> 01:24:16.040
simple use case, I think it's just easier to try to deploy remotely and see if it works

1304
01:24:16.040 --> 01:24:17.040
that way.

1305
01:24:17.040 --> 01:24:18.040
Okay.

1306
01:24:18.040 --> 01:24:19.040
Yeah.

1307
01:24:19.040 --> 01:24:26.320
Feel free to disagree with our opinion if you know better ways of testing this locally.

1308
01:24:26.320 --> 01:24:28.400
Yeah, of course.

1309
01:24:28.400 --> 01:24:34.720
Yeah, so we can see in the clip generator information then we've got the API gateway

1310
01:24:34.720 --> 01:24:44.920
resources, including the integration routes.

1311
01:24:44.920 --> 01:24:47.740
And then we can see actually the specific policy that's been generated.

1312
01:24:47.740 --> 01:24:53.540
So this is the one that's been generated by the IAM roles per function plugin and it's

1313
01:24:53.540 --> 01:24:58.000
got our, as well as permission to create logs, it's got the get object and put object on

1314
01:24:58.000 --> 01:24:59.600
this bucket.

1315
01:24:59.600 --> 01:25:03.840
So I think let's go ahead and try and deploy this because we need to, and I have some time

1316
01:25:03.840 --> 01:25:12.560
in case we've made any further typos or mistakes in the code.

1317
01:25:12.560 --> 01:25:13.560
Okay.

1318
01:25:13.560 --> 01:25:15.880
So this is deploying to CloudFormation now.

1319
01:25:15.880 --> 01:25:21.320
Let's have a flick into the CloudFormation console where we can see the stack.

1320
01:25:21.320 --> 01:25:25.780
This is from the time Luciano created it previously.

1321
01:25:25.780 --> 01:25:31.760
We should see that it's doing an update.

1322
01:25:31.760 --> 01:25:35.680
I don't see it update yet.

1323
01:25:35.680 --> 01:25:39.440
It says creating CloudFormation stack, which is slightly concerning.

1324
01:25:39.440 --> 01:25:42.160
I would have expected it to.

1325
01:25:42.160 --> 01:25:44.760
Hopefully you are not deploying to another account.

1326
01:25:44.760 --> 01:25:45.960
Let's see.

1327
01:25:45.960 --> 01:25:49.000
It could be.

1328
01:25:49.000 --> 01:25:59.840
I don't think so, but let me check here because I think I have a, yeah, this is the right

1329
01:25:59.840 --> 01:26:03.400
account here, so maybe what I can do.

1330
01:26:03.400 --> 01:26:07.040
I have, yeah.

1331
01:26:07.040 --> 01:26:16.880
I'm just going to pause this other one here and check if that was the same account.

1332
01:26:16.880 --> 01:26:22.240
Yeah, it's the same account.

1333
01:26:22.240 --> 01:26:26.720
Maybe a different region, but that shouldn't be the case because we are to call it in our

1334
01:26:26.720 --> 01:26:27.720
serverless frame.

1335
01:26:27.720 --> 01:26:30.280
It shouldn't be the case.

1336
01:26:30.280 --> 01:26:31.760
So the account is the same.

1337
01:26:31.760 --> 01:26:32.760
What did we change?

1338
01:26:32.760 --> 01:26:36.760
Did I change the name of the stack or something inadvertently?

1339
01:26:36.760 --> 01:26:44.640
But I don't see any other stack being deployed here either.

1340
01:26:44.640 --> 01:26:47.040
Are we using the same account?

1341
01:26:47.040 --> 01:26:50.240
Good question.

1342
01:26:50.240 --> 01:26:54.560
Let me check.

1343
01:26:54.560 --> 01:26:57.840
We are, because this is definitely from your deployment, right?

1344
01:26:57.840 --> 01:26:58.840
Yes.

1345
01:26:58.840 --> 01:26:59.840
This is the right time.

1346
01:26:59.840 --> 01:27:11.600
Let me give it a full browser refresh for good luck.

1347
01:27:11.600 --> 01:27:15.440
This is where we show the joys of debugging on AWS.

1348
01:27:15.440 --> 01:27:16.440
Wow.

1349
01:27:16.440 --> 01:27:21.360
Well, it has deployed somewhere.

1350
01:27:21.360 --> 01:27:26.400
Okay, so let me check this identity again.

1351
01:27:26.400 --> 01:27:27.560
I mean, it makes sense.

1352
01:27:27.560 --> 01:27:32.400
This is the right account.

1353
01:27:32.400 --> 01:27:37.320
Yeah, this looks good.

1354
01:27:37.320 --> 01:27:40.760
So the question is, what's the region?

1355
01:27:40.760 --> 01:27:44.480
I'm actually using credentials that have region variables here.

1356
01:27:44.480 --> 01:27:49.540
We've got AWS region, we've got AWS default region, just for good measure.

1357
01:27:49.540 --> 01:27:54.740
And we have the region defined in the serverless stack.

1358
01:27:54.740 --> 01:27:59.260
So that's EU West one, and I haven't changed its WeShare backend.

1359
01:27:59.260 --> 01:28:11.560
So the deployments deployed stack name should indeed be WeShare backend dev.

1360
01:28:11.560 --> 01:28:13.900
This is really interesting.

1361
01:28:13.900 --> 01:28:15.680
I'm going to give it one more go, right?

1362
01:28:15.680 --> 01:28:24.160
So what I'm going to do is I'm going to create a new terminal, a new session in my terminal,

1363
01:28:24.160 --> 01:28:29.080
and I'm going to set up some new credentials.

1364
01:28:29.080 --> 01:28:44.600
So I'll stop screen sharing for the risk of inadvertently leaking any credentials.

1365
01:28:44.600 --> 01:28:49.920
I can already see what the problem is here.

1366
01:28:49.920 --> 01:28:51.320
When I'm looking at my credentials.

1367
01:28:51.320 --> 01:28:55.840
Do you want to try and guess what it is?

1368
01:28:55.840 --> 01:28:58.360
Maybe someone can guess what it is.

1369
01:28:58.360 --> 01:29:01.180
Did we deploy to the wrong account?

1370
01:29:01.180 --> 01:29:04.640
I deployed to the wrong account just now.

1371
01:29:04.640 --> 01:29:09.920
So we're using AWS SSO, right?

1372
01:29:09.920 --> 01:29:18.080
So we use SSO to get credentials for our accounts and serverless framework doesn't support SSO

1373
01:29:18.080 --> 01:29:20.400
credentials yet properly.

1374
01:29:20.400 --> 01:29:22.620
There is an issue on it in their GitHub.

1375
01:29:22.620 --> 01:29:26.960
And unfortunately the latest response I saw on that issue is that we're not going to fix

1376
01:29:26.960 --> 01:29:29.140
it anytime soon.

1377
01:29:29.140 --> 01:29:33.440
But one of the work rounds you have to do then is use some kind of tool that takes your

1378
01:29:33.440 --> 01:29:39.680
SSO credentials and converts them into like credentials on your file system or environment

1379
01:29:39.680 --> 01:29:41.160
variables.

1380
01:29:41.160 --> 01:29:49.680
And I'm using the approach that uses environment variables.

1381
01:29:49.680 --> 01:29:56.880
And I can actually show you what that is.

1382
01:29:56.880 --> 01:30:01.240
So I think this will work a lot better.

1383
01:30:01.240 --> 01:30:08.880
I'm just going to share my screen again, because I think we're past the point of worrying about

1384
01:30:08.880 --> 01:30:15.000
leaking credentials.

1385
01:30:15.000 --> 01:30:16.680
So this is the command I use.

1386
01:30:16.680 --> 01:30:21.200
So Ben Kehoe from iRobot wrote a couple of really useful utilities around SSO.

1387
01:30:21.200 --> 01:30:23.520
One of them is AWS export credentials.

1388
01:30:23.520 --> 01:30:31.120
And then I can specify my SSO profile and it will convert this into a set of environment

1389
01:30:31.120 --> 01:30:32.940
variables that I can use.

1390
01:30:32.940 --> 01:30:39.800
So when I call it get caller identity, when I did that previously, it was using my SSO

1391
01:30:39.800 --> 01:30:41.280
credentials.

1392
01:30:41.280 --> 01:30:45.080
But I also had an AWS profile environment variable set.

1393
01:30:45.080 --> 01:30:47.920
So I actually had environment variables for two different profiles set up.

1394
01:30:47.920 --> 01:30:50.400
I don't know how I managed that in this account.

1395
01:30:50.400 --> 01:30:53.340
They were both my accounts.

1396
01:30:53.340 --> 01:30:58.920
But I think what serverless framework did was it picked up AWS profile and used that

1397
01:30:58.920 --> 01:31:03.720
instead of the other variables.

1398
01:31:03.720 --> 01:31:05.600
Let's go back to our deployment.

1399
01:31:05.600 --> 01:31:10.440
By the way, if you're curious about these topics, we have an entire episode dedicated

1400
01:31:10.440 --> 01:31:11.520
to credentials.

1401
01:31:11.520 --> 01:31:16.600
And I'm going to post the link here in the YouTube chat.

1402
01:31:16.600 --> 01:31:25.120
Now we can see your stack is being updated, Isilano.

1403
01:31:25.120 --> 01:31:30.240
So we can actually see the events occur, so it's creating the HTTP API resources.

1404
01:31:30.240 --> 01:31:41.840
It's creating the log group and it'll be creating the function as well.

1405
01:31:41.840 --> 01:31:45.280
So at the end of this, we'll be able to take a file, upload it to S3.

1406
01:31:45.280 --> 01:31:48.480
I'll be able to share it with you, Luciano, or anyone else.

1407
01:31:48.480 --> 01:31:50.240
And they'll be able to download it.

1408
01:31:50.240 --> 01:31:53.780
That could be, you know, already this is an MVP.

1409
01:31:53.780 --> 01:31:57.140
You've got ugly URLs, but already this is useful.

1410
01:31:57.140 --> 01:32:02.320
If you want to share it from transferred from one laptop to another, from your mobile to

1411
01:32:02.320 --> 01:32:08.480
laptop, vice versa, you could use this service as it is and use it as your own personal file

1412
01:32:08.480 --> 01:32:10.680
to share it with your friends.

1413
01:32:10.680 --> 01:32:12.880
Now there's a couple of restrictions, right?

1414
01:32:12.880 --> 01:32:20.900
We've got some security issues here because anyone who gets that URL, and in fact, anyone

1415
01:32:20.900 --> 01:32:27.240
who gets the upload URL, in fact, the API Gator URL can start creating upload URLs and

1416
01:32:27.240 --> 01:32:29.020
putting files onto our bucket, right?

1417
01:32:29.020 --> 01:32:31.360
Which isn't great.

1418
01:32:31.360 --> 01:32:35.480
They could certainly do a denial of wallet attack if they wanted to by just continually

1419
01:32:35.480 --> 01:32:41.180
uploading large objects and also retrieving them because that's where you really pay because

1420
01:32:41.180 --> 01:32:46.100
you have your data retrieval costs out of AWS.

1421
01:32:46.100 --> 01:32:50.240
So the next thing we're going to do is start figuring out how to protect that and lock

1422
01:32:50.240 --> 01:32:52.800
it down a little bit more.

1423
01:32:52.800 --> 01:32:53.800
Okay.

1424
01:32:53.800 --> 01:32:58.120
So this has been deployed and now you've got an upload URL or sorry, we've got an API URL.

1425
01:32:58.120 --> 01:33:07.000
So we can start invoking our post URI, creating a share and seeing what response we get back.

1426
01:33:07.000 --> 01:33:09.640
So let's say clear for this.

1427
01:33:09.640 --> 01:33:14.440
So let's create a post to our API endpoint.

1428
01:33:14.440 --> 01:33:15.440
Aha.

1429
01:33:15.440 --> 01:33:19.440
What went wrong?

1430
01:33:19.440 --> 01:33:29.800
Okay, let's give it a go.

1431
01:33:29.800 --> 01:33:32.400
Okay.

1432
01:33:32.400 --> 01:33:34.000
So this is our log group.

1433
01:33:34.000 --> 01:33:40.640
We've seen you've got a log stream here and it says we can't find package AWS SDK client

1434
01:33:40.640 --> 01:33:49.480
S3, which in fact, if you look at the function code, there is no node modules.

1435
01:33:49.480 --> 01:33:50.920
I'm not really sure why that's the case.

1436
01:33:50.920 --> 01:34:00.200
Do we need to specify something in serverless framework v3 to include dependencies?

1437
01:34:00.200 --> 01:34:01.440
It's a good question.

1438
01:34:01.440 --> 01:34:13.680
But what I think the, what we've got here is I guess if we look, we've got node node

1439
01:34:13.680 --> 01:34:14.680
modules here.

1440
01:34:14.680 --> 01:34:16.880
I'm just thinking about NPM workspaces.

1441
01:34:16.880 --> 01:34:19.280
This has bitten me before.

1442
01:34:19.280 --> 01:34:26.400
So if we look at the parent node modules, I guess we would get AWS SDK.

1443
01:34:26.400 --> 01:34:34.260
Oh, client S3 is in there.

1444
01:34:34.260 --> 01:34:38.660
So I'm wondering if it's failing to pick that up, but we've did this before, right?

1445
01:34:38.660 --> 01:34:42.680
We have checked that this would work in advance and we didn't come across this problem.

1446
01:34:42.680 --> 01:34:43.680
So I'm just wondering now.

1447
01:34:43.680 --> 01:34:48.560
Can you try doing NPM install inside the backend folder?

1448
01:34:48.560 --> 01:34:49.920
Yeah.

1449
01:34:49.920 --> 01:34:56.360
I don't think it's going to change anything, but I'm happy to be wrong.

1450
01:34:56.360 --> 01:35:01.720
So we still don't have a node modules here.

1451
01:35:01.720 --> 01:35:04.200
Did you try NPM install already?

1452
01:35:04.200 --> 01:35:05.200
I did.

1453
01:35:05.200 --> 01:35:06.200
Yeah.

1454
01:35:06.200 --> 01:35:07.200
Okay.

1455
01:35:07.200 --> 01:35:09.200
I didn't see that command.

1456
01:35:09.200 --> 01:35:11.080
Yeah.

1457
01:35:11.080 --> 01:35:13.640
That's interesting.

1458
01:35:13.640 --> 01:35:18.640
So would it be okay if I just disable the workspaces because we've only got a single

1459
01:35:18.640 --> 01:35:23.520
workspace and see if this goes away and maybe then this is, this is like a bit of homework

1460
01:35:23.520 --> 01:35:27.160
we can do for the next time to figure out how.

1461
01:35:27.160 --> 01:35:32.960
Maybe there is a plugin for serverless framework to basically use the workspace definition.

1462
01:35:32.960 --> 01:35:33.960
Yeah.

1463
01:35:33.960 --> 01:35:34.960
Yeah.

1464
01:35:34.960 --> 01:35:36.840
That would be good.

1465
01:35:36.840 --> 01:35:37.840
So, okay.

1466
01:35:37.840 --> 01:35:38.840
Let's try that.

1467
01:35:38.840 --> 01:35:44.820
So I think what we have to do then is edit the root package.json and remove this basically.

1468
01:35:44.820 --> 01:35:47.200
Remove the workspaces property.

1469
01:35:47.200 --> 01:35:49.240
Okay.

1470
01:35:49.240 --> 01:35:55.680
So if I do that and I go back to the shell and I do NPM install now within backend, does

1471
01:35:55.680 --> 01:35:58.640
it realize that it has its own world?

1472
01:35:58.640 --> 01:35:59.640
It does.

1473
01:35:59.640 --> 01:36:00.640
Okay.

1474
01:36:00.640 --> 01:36:09.040
So now I've got node modules and let's just check that I've got AWS.

1475
01:36:09.040 --> 01:36:10.920
Maybe my problem is here.

1476
01:36:10.920 --> 01:36:14.480
Oh, maybe we added them at the top level.

1477
01:36:14.480 --> 01:36:15.480
Interesting.

1478
01:36:15.480 --> 01:36:17.680
This is a known problem, not a node problem.

1479
01:36:17.680 --> 01:36:18.680
Okay.

1480
01:36:18.680 --> 01:36:20.760
So let's put workspaces back.

1481
01:36:20.760 --> 01:36:24.560
I added it at the top level instead of the root level.

1482
01:36:24.560 --> 01:36:33.080
So let's go back to our NPM install, add them into backend.

1483
01:36:33.080 --> 01:36:37.600
I'm guessing, yeah, that's gone now because we've got workspaces back.

1484
01:36:37.600 --> 01:36:43.260
If I go back to the root, yeah, I added them in here.

1485
01:36:43.260 --> 01:36:47.120
So we could probably remove them from there.

1486
01:36:47.120 --> 01:36:48.400
Yep.

1487
01:36:48.400 --> 01:36:51.880
Which is NPM uninstall, right?

1488
01:36:51.880 --> 01:36:55.400
Or RM, I think as well.

1489
01:36:55.400 --> 01:36:56.400
RM.

1490
01:36:56.400 --> 01:36:57.400
Okay.

1491
01:36:57.400 --> 01:36:58.400
Okay.

1492
01:36:58.400 --> 01:37:03.840
They're gone from there.

1493
01:37:03.840 --> 01:37:06.200
They're in here now as primary dependencies.

1494
01:37:06.200 --> 01:37:08.480
So the AWS SDK version three, right?

1495
01:37:08.480 --> 01:37:12.840
What I'm seeing from this, the other learning I'm getting here is that the version three

1496
01:37:12.840 --> 01:37:15.560
SDK is not packaged with the Lambda runtime.

1497
01:37:15.560 --> 01:37:19.440
Even with the version, the node 16 latest runtime.

1498
01:37:19.440 --> 01:37:27.680


1499
01:37:27.680 --> 01:37:29.560
As far as I remember, there is a discrepancy depending on whether you use common JS or ESM modules.

1500
01:37:29.560 --> 01:37:35.880
I think if you use common JS, you might have some version package there, but your mileage

1501
01:37:35.880 --> 01:37:40.880
might vary because it's not necessarily guaranteed to be the latest version or any specific version

1502
01:37:40.880 --> 01:37:42.320
you might get.

1503
01:37:42.320 --> 01:37:45.080
Whatever is the current version, the Lambda runtime.

1504
01:37:45.080 --> 01:37:46.080
Okay.

1505
01:37:46.080 --> 01:37:48.720
So it's always best to package your own dependencies.

1506
01:37:48.720 --> 01:37:54.360
At least you are guaranteed that you get whatever you are requesting, right?

1507
01:37:54.360 --> 01:37:55.360
Yeah.

1508
01:37:55.360 --> 01:37:57.480
Yeah, I agree.

1509
01:37:57.480 --> 01:37:58.480
Yeah.

1510
01:37:58.480 --> 01:37:59.480
Yep.

1511
01:37:59.480 --> 01:38:04.680
It's just something you should be, I guess, more conscious of now than we used to be with

1512
01:38:04.680 --> 01:38:07.000
version two.

1513
01:38:07.000 --> 01:38:08.720
Okay.

1514
01:38:08.720 --> 01:38:17.360
So what we can also do actually is we can use an npx sls package and inside the serverless

1515
01:38:17.360 --> 01:38:20.560
directory you have the full backend uploaded.

1516
01:38:20.560 --> 01:38:26.320
Now the file size looks a little small, so let's have a look at the contents of this.

1517
01:38:26.320 --> 01:38:27.320
Zip.

1518
01:38:27.320 --> 01:38:34.960
I'm actually looking at the files uploaded in the Lambda and we have an odd modules folder,

1519
01:38:34.960 --> 01:38:35.960
but it's empty.

1520
01:38:35.960 --> 01:38:38.440
So it's interesting.

1521
01:38:38.440 --> 01:38:41.280
I think we're still going to have some problems there.

1522
01:38:41.280 --> 01:38:42.560
Okay.

1523
01:38:42.560 --> 01:38:46.120
Can I go back to removing workspaces?

1524
01:38:46.120 --> 01:38:49.760
I think so, yeah.

1525
01:38:49.760 --> 01:38:50.760
Okay.

1526
01:38:50.760 --> 01:38:53.480
All right.

1527
01:38:53.480 --> 01:39:02.840
So let's do another install npm install.

1528
01:39:02.840 --> 01:39:05.400
I like that it works even with a typo.

1529
01:39:05.400 --> 01:39:06.960
With a typo.

1530
01:39:06.960 --> 01:39:07.960
Yeah.

1531
01:39:07.960 --> 01:39:11.000
Any sub-stream, any prefix will do.

1532
01:39:11.000 --> 01:39:12.000
Okay.

1533
01:39:12.000 --> 01:39:16.840
So in node modules now it looks like we have something a bit more expected.

1534
01:39:16.840 --> 01:39:18.520
Let's run one more.

1535
01:39:18.520 --> 01:39:21.440
Let's just do the package command because that's really quick.

1536
01:39:21.440 --> 01:39:22.440
Okay.

1537
01:39:22.440 --> 01:39:26.240
And we'll do our unzip again.

1538
01:39:26.240 --> 01:39:27.480
Ah yeah.

1539
01:39:27.480 --> 01:39:31.480
Now we've got a lot more going on.

1540
01:39:31.480 --> 01:39:34.480
All right.

1541
01:39:34.480 --> 01:39:39.080
I'm getting more confident that this is going to work.

1542
01:39:39.080 --> 01:39:44.400


1543
01:39:44.400 --> 01:39:46.160
I also like that we did everything we could to avoid to bring that UUID dependency and somehow it's there anyway.

1544
01:39:46.160 --> 01:39:53.280
I'm going to guess it's a dependency of the AWS SDK.

1545
01:39:53.280 --> 01:39:57.160
Yeah.

1546
01:39:57.160 --> 01:40:07.080


1547
01:40:07.080 --> 01:40:08.080
So we have Will in the chat saying that AWS SDK version 2 is included in this common JS runtime.

1548
01:40:08.080 --> 01:40:11.200
So you don't get the version 3.

1549
01:40:11.200 --> 01:40:13.200
Thank you, Will, for the clarification.

1550
01:40:13.200 --> 01:40:14.200
Okay.

1551
01:40:14.200 --> 01:40:15.200
That's right.

1552
01:40:15.200 --> 01:40:22.720
So does that mean you get the AWS SDK version 3 if you use common JS or not?

1553
01:40:22.720 --> 01:40:25.800
You only get the AWS SDK version 2?

1554
01:40:25.800 --> 01:40:30.520
You get the AWS SDK version 2 as far as I understand.

1555
01:40:30.520 --> 01:40:31.520
Okay.

1556
01:40:31.520 --> 01:40:32.520
Yeah.

1557
01:40:32.520 --> 01:40:33.520
Okay.

1558
01:40:33.520 --> 01:40:34.520
All right.

1559
01:40:34.520 --> 01:40:35.520
Let's give another go to our command.

1560
01:40:35.520 --> 01:40:42.120
So we're going to curl minus X post to this and hopefully we'll get back a couple of URLs.

1561
01:40:42.120 --> 01:40:43.120
Let's see.

1562
01:40:43.120 --> 01:40:44.120
Not.

1563
01:40:44.120 --> 01:40:45.120
No such joy.

1564
01:40:45.120 --> 01:40:46.120
Okay.

1565
01:40:46.120 --> 01:40:47.120
Ah, okay.

1566
01:40:47.120 --> 01:40:48.120
I've given myself a few more.

1567
01:40:48.120 --> 01:40:55.920
Okay.

1568
01:40:55.920 --> 01:41:06.920
Ah, okay.

1569
01:41:06.920 --> 01:41:07.920
I've given a Python syntax in our handler.

1570
01:41:07.920 --> 01:41:08.920
Snake case is no good here.

1571
01:41:08.920 --> 01:41:11.920
So I think it was handle event, but let's just verify that here.

1572
01:41:11.920 --> 01:41:13.560
Nope.

1573
01:41:13.560 --> 01:41:15.840
It's called handler.

1574
01:41:15.840 --> 01:41:19.760
So I think I prefer to give it a verb.

1575
01:41:19.760 --> 01:41:20.760
Yeah.

1576
01:41:20.760 --> 01:41:21.760
Than a noun.

1577
01:41:21.760 --> 01:41:24.760
So let's stick with handler event.

1578
01:41:24.760 --> 01:41:27.760
It's always weird when you see handler dot handler.

1579
01:41:27.760 --> 01:41:30.360
It's not very clear what that means.

1580
01:41:30.360 --> 01:41:31.360
Yeah.

1581
01:41:31.360 --> 01:41:32.360
Oops.

1582
01:41:32.360 --> 01:41:33.360
Yeah.

1583
01:41:33.360 --> 01:41:44.680
So in a couple of seconds we should have all that resolved.

1584
01:41:44.680 --> 01:41:49.360
And like with a proper project structure here, we might have a sub we would have a sub directory

1585
01:41:49.360 --> 01:41:55.400
for our handlers and then separate directories for the logic that occurs within these handlers

1586
01:41:55.400 --> 01:42:01.440
and probably not avoid having all of our modules at the root with all of the code and that

1587
01:42:01.440 --> 01:42:04.880
the lambda handler itself.

1588
01:42:04.880 --> 01:42:10.360
Will is also clarifying that the SDK version three is not included in any runtime, not

1589
01:42:10.360 --> 01:42:14.760
just runtime, but hopefully will be not JS 18.

1590
01:42:14.760 --> 01:42:15.760
Oh, okay.

1591
01:42:15.760 --> 01:42:16.760
Okay.

1592
01:42:16.760 --> 01:42:20.120
Cause I was, I was wondering if the reason not to include it was just to keep the runtime

1593
01:42:20.120 --> 01:42:26.680
light and to like reduce cold start time by, because I suppose what the advantage of the

1594
01:42:26.680 --> 01:42:30.280
version three SDK is that they're modular and you don't have to bundle them all.

1595
01:42:30.280 --> 01:42:32.760
So that's interesting.

1596
01:42:32.760 --> 01:42:38.480
I guess having it in the runtime is good for people who are using, you know, cloud nine

1597
01:42:38.480 --> 01:42:44.000
or the inbuilt lambda console editor to try something fairly basic because you don't have

1598
01:42:44.000 --> 01:42:47.760
to worry about packaging modules there.

1599
01:42:47.760 --> 01:42:50.640
Okay.

1600
01:42:50.640 --> 01:42:52.640
We are.

1601
01:42:52.640 --> 01:42:54.520
Nice.

1602
01:42:54.520 --> 01:42:56.280
Okay.

1603
01:42:56.280 --> 01:43:00.440
We've got our first URL.

1604
01:43:00.440 --> 01:43:05.320
So now we've got, um, an upload URL and our download URL.

1605
01:43:05.320 --> 01:43:09.320
So let me, I did promise that the URLs weren't going to be pretty.

1606
01:43:09.320 --> 01:43:13.120
I think I've lived up to that promise.

1607
01:43:13.120 --> 01:43:16.200
So let's, let's put something up on S3.

1608
01:43:16.200 --> 01:43:18.000
Let's upload something to WeShare.

1609
01:43:18.000 --> 01:43:20.440
So what'll I use?

1610
01:43:20.440 --> 01:43:27.280
Let's say, let's use our diagram from the repository.

1611
01:43:27.280 --> 01:43:29.280
What is it called?

1612
01:43:29.280 --> 01:43:34.080
Oh, it's in the, um, in the directory.

1613
01:43:34.080 --> 01:43:38.080
Yeah, and it's called MVP-DIAG.png.

1614
01:43:38.080 --> 01:43:40.080
Okay.

1615
01:43:40.080 --> 01:43:52.800
That's, looks to have succeeded.

1616
01:43:52.800 --> 01:43:59.960
So let me just go back to the download URL.

1617
01:43:59.960 --> 01:44:10.440
Ah, I don't know if this is going to work for me, my scrolling and pasting in my terminal.

1618
01:44:10.440 --> 01:44:12.960
This might be a slight gotcha for this demo.

1619
01:44:12.960 --> 01:44:14.560
Let's see how we get on.

1620
01:44:14.560 --> 01:44:17.760
Well, I can confirm that I see something in a stream.

1621
01:44:17.760 --> 01:44:18.760
Oh yeah.

1622
01:44:18.760 --> 01:44:19.760
Okay.

1623
01:44:19.760 --> 01:44:20.760
This is good.

1624
01:44:20.760 --> 01:44:21.760
Yeah.

1625
01:44:21.760 --> 01:44:25.520
I have a problem here with this URL.

1626
01:44:25.520 --> 01:44:27.520
So let me do it a slightly different way.

1627
01:44:27.520 --> 01:44:32.920
I can show very quickly that here we have this file in S3.

1628
01:44:32.920 --> 01:44:33.920
Nice.

1629
01:44:33.920 --> 01:44:34.920
Okay.

1630
01:44:34.920 --> 01:44:39.920
Let me do this again.

1631
01:44:39.920 --> 01:44:45.080
MVP-DIAG.png.

1632
01:44:45.080 --> 01:44:56.720
What did I miss?

1633
01:44:56.720 --> 01:44:57.720
MVN.

1634
01:44:57.720 --> 01:44:58.720
MVP.

1635
01:44:58.720 --> 01:44:59.720
MVN.

1636
01:44:59.720 --> 01:45:05.120
It's like a hangover from my days of using Maven.

1637
01:45:05.120 --> 01:45:07.320
Excellent.

1638
01:45:07.320 --> 01:45:15.740
Let's give our, um, upload, download URL a go.

1639
01:45:15.740 --> 01:45:19.760
So I'm going to do curl minus V just so we can see like things like the response headers

1640
01:45:19.760 --> 01:45:20.760
and stuff.

1641
01:45:20.760 --> 01:45:23.520
Can you zoom a little bit your font?

1642
01:45:23.520 --> 01:45:24.520
Yeah.

1643
01:45:24.520 --> 01:45:29.760
Actually, let's just, um, let's just paste this into the browser.

1644
01:45:29.760 --> 01:45:31.560
So this is the download URL.

1645
01:45:31.560 --> 01:45:34.920
I don't need the curl command.

1646
01:45:34.920 --> 01:45:36.600
Okay.

1647
01:45:36.600 --> 01:45:43.900
So now I've got a file with a not too obvious name in my downloads folder.

1648
01:45:43.900 --> 01:45:44.900
So let me do it.

1649
01:45:44.900 --> 01:45:50.360
Let me open up my downloads folder so everyone can see.

1650
01:45:50.360 --> 01:46:00.280
And I guess I'm going to have to rename this to.png.

1651
01:46:00.280 --> 01:46:02.440
And let's open it up.

1652
01:46:02.440 --> 01:46:06.320
And we have our architecture diagram.

1653
01:46:06.320 --> 01:46:07.320
Awesome.

1654
01:46:07.320 --> 01:46:13.960
That's a success for MVP.

1655
01:46:13.960 --> 01:46:14.960
I think so.

1656
01:46:14.960 --> 01:46:15.960
Excellent.

1657
01:46:15.960 --> 01:46:22.160
Let's have a quick check of what we added since last commit.

1658
01:46:22.160 --> 01:46:38.920
And I'm going to commit the add handler to generate, upload and download URLs and push

1659
01:46:38.920 --> 01:46:42.320
that and everybody can have a go.

1660
01:46:42.320 --> 01:46:48.760
And deploy it to their own environments.

1661
01:46:48.760 --> 01:46:55.160
And what I'm going to do before we wrap up is I'm just going to remove this stack because

1662
01:46:55.160 --> 01:46:58.240
I don't want us to be DDoSed on our bucket.

1663
01:46:58.240 --> 01:47:02.960
Yeah, because everyone saw the URL for uploading, right?

1664
01:47:02.960 --> 01:47:03.960
Yeah.

1665
01:47:03.960 --> 01:47:08.720
Maybe, maybe we've got a few surprise objects, but we better not share them publicly.

1666
01:47:08.720 --> 01:47:10.720
Yeah, absolutely.

1667
01:47:10.720 --> 01:47:17.560
I think just to wrap things up, of course, we did a very simple implementation, like

1668
01:47:17.560 --> 01:47:20.840
the bare minimum that you could possibly do to get this working.

1669
01:47:20.840 --> 01:47:25.120
There are a few things that would be nice to do and maybe something we can consider

1670
01:47:25.120 --> 01:47:27.160
for the next episode.

1671
01:47:27.160 --> 01:47:32.600
For instance, one thing that we saw is that when you were downloading the file, you totally

1672
01:47:32.600 --> 01:47:35.760
lost the file name, the extension.

1673
01:47:35.760 --> 01:47:38.000
So you needed to figure out, oh, this is a PNG.

1674
01:47:38.000 --> 01:47:39.720
Let me rename it and open it.

1675
01:47:39.720 --> 01:47:45.400
There are actually ways that we could retain the MIME type and the file name.

1676
01:47:45.400 --> 01:47:48.900
So we could implement all of that in the next session.

1677
01:47:48.900 --> 01:47:53.220
And then other things we will be doing are making this a little bit more production ready.

1678
01:47:53.220 --> 01:47:58.040
For instance, by adding proper logging metrics and stuff like that, we could be using something

1679
01:47:58.040 --> 01:48:00.960
like MIDI to implement all these features.

1680
01:48:00.960 --> 01:48:04.120
We will be using power tools as well.

1681
01:48:04.120 --> 01:48:08.400
So maybe in the next session, we try to do all of this.

1682
01:48:08.400 --> 01:48:12.400
But by any means, if you have other ideas or specific questions, feel free to ask and

1683
01:48:12.400 --> 01:48:16.880
we'll try to tackle those questions in the next episode.

1684
01:48:16.880 --> 01:48:22.000
Which probably is gonna be next week, more or less, same day, same time.

1685
01:48:22.000 --> 01:48:26.940
But just stay tuned on YouTube and our social media channels, because as soon as we have

1686
01:48:26.940 --> 01:48:30.120
all of that scheduled, we are gonna announce it.

1687
01:48:30.120 --> 01:48:31.120
Yeah.

1688
01:48:31.120 --> 01:48:33.000
Look forward to it.

1689
01:48:33.000 --> 01:48:38.360
It was good to get all that setup done, because there's quite a few small pieces there.

1690
01:48:38.360 --> 01:48:42.240
We were at the start before we got to actually writing the code.

1691
01:48:42.240 --> 01:48:44.520
I think it's gonna be interesting next week.

1692
01:48:44.520 --> 01:48:50.200
We should be able to plow ahead with making this a little bit more user friendly.

1693
01:48:50.200 --> 01:48:52.680
I don't like the look of those URLs.

1694
01:48:52.680 --> 01:48:58.240
Just as a reminder, in the chat, I'm gonna be posting our repository.

1695
01:48:58.240 --> 01:49:01.380
And I think this is all we have for today.

1696
01:49:01.380 --> 01:49:08.000
So hopefully you enjoyed all of that and we'll see you next time.

1697
01:49:08.000 --> 01:49:09.000
Bye everyone.

1698
01:49:09.000 --> 01:49:10.000
Thanks everyone.

1699
01:49:10.000 --> 01:49:38.080
We'll see you next time.
