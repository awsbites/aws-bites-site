WEBVTT

1
00:00:00.000 --> 00:00:05.000
AWS Application Composer is a free service that helps you architect and build serverless applications.

2
00:00:05.000 --> 00:00:09.600
With a simple drag and drop interface, it promises to lower the barrier to entry

3
00:00:09.600 --> 00:00:12.840
in building applications using infrastructure as code.

4
00:00:12.840 --> 00:00:14.720
But does it live up to that promise?

5
00:00:14.720 --> 00:00:18.280
In this episode, we're going to unbox AWS Application Composer,

6
00:00:18.280 --> 00:00:19.920
tell you what it's like to use,

7
00:00:19.920 --> 00:00:23.200
and let you know whether you should add it to your toolkit or give it a hard pass.

8
00:00:23.200 --> 00:00:34.800
I'm Eoin, I'm here with Luciano and this is the AWS Bites podcast.

9
00:00:34.800 --> 00:00:36.760
AWS Bites is sponsored by fourTheorem,

10
00:00:36.760 --> 00:00:40.440
and fourTheorem is an AWS partner for migration, architecture and training.

11
00:00:40.440 --> 00:00:44.680
Find out more at fourtheorem.com and you can find the link in the show notes.

12
00:00:44.680 --> 00:00:46.320
Right, let's get down to it, Luciano.

13
00:00:46.320 --> 00:00:51.200
We covered Application Composer briefly when it was announced at reInvent late last year.

14
00:00:51.200 --> 00:00:53.640
Since then, you've taken it for a proper test drive

15
00:00:53.640 --> 00:00:56.920
and really tried to see where it works and where it doesn't work.

16
00:00:56.920 --> 00:01:00.280
So maybe we can just start by telling everybody who doesn't know

17
00:01:00.280 --> 00:01:05.600
what is Application Composer and what kind of problem is it actually designed to solve in the first place?

18
00:01:05.600 --> 00:01:08.480
Of course, yeah. So let's get started.

19
00:01:08.480 --> 00:01:12.720
And as you said in the introduction, Application Composer is a free service.

20
00:01:12.720 --> 00:01:15.960
Let's put a little bit of an effort there in that free keyword,

21
00:01:15.960 --> 00:01:20.920
because I think it's going to be very important towards the end when we try to draw our conclusions.

22
00:01:20.920 --> 00:01:25.600
And the idea is that this service is going to help developers, cloud architects,

23
00:01:25.600 --> 00:01:30.920
to streamline and accelerate the architecture configuration of serverless applications.

24
00:01:30.920 --> 00:01:35.480
So the idea is that it's built on top of infrastructure as code.

25
00:01:35.480 --> 00:01:39.640
So it uses some of CloudFormation syntax in a more general sense.

26
00:01:39.640 --> 00:01:43.320
So it kind of helps you out if you are not familiar with that syntax,

27
00:01:43.320 --> 00:01:48.800
gives you a very visual drag and drop interface where you can drag different resources,

28
00:01:48.800 --> 00:01:52.920
connect them and behind the scenes, it keeps that infrastructure as code representation

29
00:01:52.920 --> 00:01:57.600
of everything that you are drawing up to date with the latest changes.

30
00:01:57.600 --> 00:02:02.120
So the idea is that if you don't know infrastructure as code,

31
00:02:02.120 --> 00:02:05.040
CloudFormation specifically, or maybe you know a little bit of it,

32
00:02:05.040 --> 00:02:10.440
maybe you don't know specific resources, again, it's that idea that it tries to lower down the barrier to end

33
00:02:10.440 --> 00:02:15.760
and trying to speed up achieving something mostly in the serverless space as of today,

34
00:02:15.760 --> 00:02:20.880
that you can quickly build and use it and put it in your own AWS account.

35
00:02:20.880 --> 00:02:24.720
The way it works is that it is an application that is running on your browser,

36
00:02:24.720 --> 00:02:26.960
specifically, you just log in in the AWS console,

37
00:02:26.960 --> 00:02:31.280
and it's going to be one of the many services that are available through the AWS console.

38
00:02:31.280 --> 00:02:34.800
And when you start that particular service on the AWS console,

39
00:02:34.800 --> 00:02:37.520
you immediately see that there is this concept of a canvas,

40
00:02:37.520 --> 00:02:41.160
which looks like one of the resources that you can manage with this service.

41
00:02:41.160 --> 00:02:45.360
But it's important to mention that it's not really an actual resource in the classic sense,

42
00:02:45.360 --> 00:02:49.440
because it's not something that is persisted long term in your AWS account.

43
00:02:49.440 --> 00:02:52.800
It's just the idea that you can start a new session in the browser,

44
00:02:52.800 --> 00:02:56.800
but that session is totally lost when you leave that browser window.

45
00:02:56.800 --> 00:03:02.400
And this is an important detail that we will cover a little bit more in the rest of this episode.

46
00:03:02.400 --> 00:03:05.920
So the idea is that you have to persist files somewhere

47
00:03:05.920 --> 00:03:10.960
because you are creating templates in YAML for your infrastructure as code through this experience,

48
00:03:10.960 --> 00:03:12.240
visual experience.

49
00:03:12.240 --> 00:03:16.960
So what the application composer gives you is the opportunity to synchronize

50
00:03:16.960 --> 00:03:21.280
a local folder in your file system with everything that you are doing in the browser.

51
00:03:21.280 --> 00:03:23.760
And this is what they call connected mode.

52
00:03:23.760 --> 00:03:25.520
So when you start a new canvas,

53
00:03:25.520 --> 00:03:28.240
the first thing that you see is literally a screen that tells you,

54
00:03:28.240 --> 00:03:30.080
do you want to work in connected mode?

55
00:03:30.080 --> 00:03:32.400
If you want to do that, you need to give me permission.

56
00:03:32.400 --> 00:03:36.480
You need to give the browser permission to read a specific folder in a file system.

57
00:03:36.480 --> 00:03:43.360
Now, this is another important detail because being able to give a browser file system permission

58
00:03:43.360 --> 00:03:45.840
is something relatively new in the web platform.

59
00:03:45.840 --> 00:03:50.560
And at this time, only Chrome and Edge, I believe, implemented that.

60
00:03:50.560 --> 00:03:52.640
Definitely doesn't work for Firefox,

61
00:03:52.640 --> 00:03:57.360
even though if I was researching a little bit this API called File System Access API,

62
00:03:57.360 --> 00:04:01.200
and it seems that Firefox now has an experimental support for that.

63
00:04:01.200 --> 00:04:05.200
So maybe eventually this is something that also Firefox will be able to support.

64
00:04:05.200 --> 00:04:11.680
So again, at this point, what you can do is start the browser, start the application composer,

65
00:04:11.680 --> 00:04:16.160
connect your local folder, give permission, and at that point, you can work on this canvas.

66
00:04:16.720 --> 00:04:22.320
OK, so from what I understand, then it's something that you get through the AWS console.

67
00:04:22.320 --> 00:04:26.560
It gives you a nice looking UI for building applications, and it works in both directions.

68
00:04:26.560 --> 00:04:29.280
So you can generate a visual representation from code,

69
00:04:29.280 --> 00:04:33.600
but you can also generate code by dragging and dropping in this application.

70
00:04:33.600 --> 00:04:38.720
I know that like many other people, it took me a while to get to grips with CloudFormation

71
00:04:38.720 --> 00:04:43.840
when I started many years ago and figuring out how to define components and connect them together.

72
00:04:43.840 --> 00:04:45.920
So it's not something you can pick up that quickly.

73
00:04:45.920 --> 00:04:49.600
And for that reason, I think the idea of application composer makes sense.

74
00:04:49.600 --> 00:04:52.960
And you've mentioned that phrase, lowering the barrier to entry a few times.

75
00:04:52.960 --> 00:04:56.000
So it seems like, in theory, at least a good fit.

76
00:04:56.880 --> 00:04:58.320
In practice, what is it like?

77
00:04:58.320 --> 00:05:00.160
So you've built some applications with it.

78
00:05:00.160 --> 00:05:01.840
What are your first impressions?

79
00:05:01.840 --> 00:05:03.920
Did you encounter any major roadblocks?

80
00:05:07.520 --> 00:05:09.440
Yeah, I think it would be beneficial to try to describe what I try to build, because it's a relatively simple project.

81
00:05:09.440 --> 00:05:12.000
But I think there is also enough complexity there,

82
00:05:12.000 --> 00:05:15.280
if you were going to do all of that infrastructure as code manually,

83
00:05:15.280 --> 00:05:20.800
to have a good feeling for whether this kind of tool can really help us for more realistic projects.

84
00:05:21.360 --> 00:05:25.760
So everything that I'm about to say, by the way, is available in our repository.

85
00:05:25.760 --> 00:05:27.600
We will have the link in the show notes.

86
00:05:27.600 --> 00:05:32.320
And also the repository details how to basically clone that solution and deploy it,

87
00:05:32.320 --> 00:05:35.360
if you want to see it running yourself, and all the steps that you can follow,

88
00:05:35.360 --> 00:05:40.160
if you want to replicate everything that I am about to describe yourself.

89
00:05:40.160 --> 00:05:42.640
So the idea is that it's a very simple application,

90
00:05:42.640 --> 00:05:44.960
where there is an API gateway with just one endpoint.

91
00:05:45.520 --> 00:05:49.600
This endpoint will trigger a Lambda, which is responsible for basically doing

92
00:05:49.600 --> 00:05:53.040
that Lambda proxy integration and generating an HTTP response.

93
00:05:53.040 --> 00:05:56.400
And before doing that, it's going to go into an S3 bucket

94
00:05:56.400 --> 00:05:59.120
and create a new file. So basically for every request,

95
00:05:59.120 --> 00:06:01.520
it's going to create a new file with a timestamp,

96
00:06:01.520 --> 00:06:05.920
just to simulate some interaction between the Lambda and another service like S3,

97
00:06:05.920 --> 00:06:08.560
to answer that particular HTTP request.

98
00:06:08.560 --> 00:06:13.680
So effectively, we have three different services, API gateway, Lambda and S3.

99
00:06:13.680 --> 00:06:16.800
They are connected together and there is a very specific workflow

100
00:06:16.800 --> 00:06:20.880
triggered by an HTTP request, starts the Lambda, the Lambda writes to S3,

101
00:06:20.880 --> 00:06:23.440
and then the Lambda responds back to API gateway.

102
00:06:23.440 --> 00:06:27.520
So these are the steps that I follow to try to implement all of this.

103
00:06:27.520 --> 00:06:31.040
I started a new project in Application Composer, started in synced mode.

104
00:06:31.040 --> 00:06:34.000
So I had to select a folder in my file system.

105
00:06:34.000 --> 00:06:36.640
And as soon as I said, okay, keep going,

106
00:06:37.200 --> 00:06:40.800
the first thing that I noticed is that I didn't have anything in that folder,

107
00:06:40.800 --> 00:06:43.280
but as soon as I clicked okay in Application Composer,

108
00:06:43.280 --> 00:06:46.240
a new template.yaml appeared in that folder.

109
00:06:46.240 --> 00:06:47.840
And initially, it's totally emptied.

110
00:06:47.840 --> 00:06:51.600
Actually, there is literally like an empty object in the YAML syntax.

111
00:06:51.600 --> 00:06:58.240
So that kind of tells you that an empty canvas is equivalent to an empty object in YAML

112
00:06:58.240 --> 00:06:59.760
for Application Composer.

113
00:07:00.800 --> 00:07:03.920
At this point, you have an Application Composer on the left side,

114
00:07:03.920 --> 00:07:06.320
a list of all the resources that are supported.

115
00:07:06.320 --> 00:07:08.240
And one of these is API gateway.

116
00:07:08.240 --> 00:07:11.680
So I just drag and dropped that resource into the canvas.

117
00:07:11.680 --> 00:07:17.040
And immediately what you could see is that it starts with one endpoint.

118
00:07:17.040 --> 00:07:22.480
This is already preconfigured for you, which is a GET endpoint to the slash path, so the root path.

119
00:07:23.120 --> 00:07:24.480
Of course, it's something that you can change.

120
00:07:24.480 --> 00:07:29.440
You can double click in the canvas object that you just dropped there,

121
00:07:29.440 --> 00:07:32.000
and you will see a panel with a bunch of configuration options.

122
00:07:32.000 --> 00:07:34.400
So you can add more endpoints if you want to.

123
00:07:34.400 --> 00:07:37.920
But for the sake of this project, I was happy with that default endpoint.

124
00:07:38.480 --> 00:07:42.240
And then I started to look at the template and I realized that all of that stuff,

125
00:07:42.240 --> 00:07:46.800
so that this new API gateway resource was already codified in Infrastructure as Code.

126
00:07:46.800 --> 00:07:51.440
And that was actually something already interesting because that is, I don't know,

127
00:07:51.440 --> 00:07:53.440
probably around 15, 20 lines of code.

128
00:07:53.440 --> 00:07:56.800
So it's definitely not necessarily simple if you want to write it yourself.

129
00:07:56.800 --> 00:08:01.760
And I was able to get all of that in just a few seconds by drag and dropping something in the browser.

130
00:08:02.640 --> 00:08:06.240
So the next step was to start to provision, well,

131
00:08:06.240 --> 00:08:08.960
start to create the code related to the Lambda function.

132
00:08:08.960 --> 00:08:13.600
So same idea, go to the bar with all the resources supported,

133
00:08:13.600 --> 00:08:18.240
drag the Lambda icon into the canvas and immediately you have the definition of a Lambda,

134
00:08:18.800 --> 00:08:22.000
both in the canvas visible, but also in your template YAML.

135
00:08:23.200 --> 00:08:26.080
And with Lambda is actually very interesting.

136
00:08:26.080 --> 00:08:30.560
I feel like it's one of the resources where they spend the most time trying to

137
00:08:31.120 --> 00:08:33.520
give you ways to configure it.

138
00:08:33.520 --> 00:08:36.560
In fact, you can double click that Lambda object in the canvas

139
00:08:36.560 --> 00:08:40.880
and you will have such a big panel with like many configurations options.

140
00:08:40.880 --> 00:08:45.680
And one of these options, the first one that kind of captured my attention was the runtime option.

141
00:08:45.680 --> 00:08:49.680
So you can click there and you have a long list of all the possible runtimes that you can use.

142
00:08:50.240 --> 00:08:54.080
And actually even more interesting, if you're interested in Node.js,

143
00:08:54.080 --> 00:08:56.320
you have runtimes that are not just Node.js,

144
00:08:56.320 --> 00:09:00.640
but you can have the same runtime for instance Node.js 18 plus TypeScript.

145
00:09:00.640 --> 00:09:05.040
So I was really curious to try that and I picked up Node.js 18 with TypeScript.

146
00:09:05.040 --> 00:09:12.160
And I immediately realized that I didn't just get all the YAML related to that Lambda

147
00:09:12.160 --> 00:09:16.080
with that particular runtime, with the metadata that SAM understands to be able to

148
00:09:16.640 --> 00:09:19.520
build TypeScript for you using ES build.

149
00:09:19.520 --> 00:09:25.280
But also there was a skeleton folder that was created for me called source slash function,

150
00:09:25.280 --> 00:09:29.760
where inside of it I already had an handler in TypeScript and a package JSON.

151
00:09:29.760 --> 00:09:32.400
So all of that stuff was very convenient.

152
00:09:32.400 --> 00:09:35.520
And again, something else that lowers the barrier to end to even understand

153
00:09:35.520 --> 00:09:40.800
how do you organize files with your source code when you're using a template with SAM.

154
00:09:40.800 --> 00:09:43.120
All of this stuff was nicely connected together.

155
00:09:44.400 --> 00:09:47.040
Then at this point, the next step was S3.

156
00:09:47.040 --> 00:09:53.120
So again, drag the S3 icon into the canvas and you get a YAML with the definition of a bucket.

157
00:09:53.120 --> 00:09:57.600
And this was also very interesting because this is something if you want to do it yourself,

158
00:09:57.600 --> 00:10:00.240
it's actually the simplest of the three resources.

159
00:10:00.240 --> 00:10:04.000
But then you never remember that there are a bunch of configuration best practices

160
00:10:04.000 --> 00:10:06.080
that you can do when it comes to S3 buckets.

161
00:10:06.080 --> 00:10:10.000
For instance, encryption, for instance, making sure that you don't have communication

162
00:10:10.000 --> 00:10:15.200
without encryption when you use the APIs to connect to S3.

163
00:10:15.200 --> 00:10:19.120
And all that stuff, all these best practices were already provided

164
00:10:19.120 --> 00:10:21.920
by the YAML auto-generated by Application Composer.

165
00:10:21.920 --> 00:10:27.120
So it wasn't just the S3 bucket on its own, but there was also all the configuration for

166
00:10:27.120 --> 00:10:32.560
encrypting at rest and encrypting in transit, which is, I think, a really good best practice

167
00:10:32.560 --> 00:10:34.880
and something that you would easily forget to do it yourself,

168
00:10:34.880 --> 00:10:37.920
especially if you are learning CloudFormation for the first time.

169
00:10:39.360 --> 00:10:44.320
So the next step is to connect things together because right now we only have an API gateway.

170
00:10:44.320 --> 00:10:47.680
We have a Lambda and we have an S3 bucket.

171
00:10:47.680 --> 00:10:52.080
They are not connected with each other and we can easily connect them by dragging.

172
00:10:52.080 --> 00:10:56.400
There are like some dots that you can drag on every source to connect with the other one.

173
00:10:56.400 --> 00:10:58.160
So basically you create a line between them.

174
00:10:59.200 --> 00:11:03.600
And the first line that I created was from API gateway to the Lambda.

175
00:11:03.600 --> 00:11:08.640
And what that did was basically understand, OK, you want to trigger this Lambda from API gateway.

176
00:11:08.640 --> 00:11:14.160
So basically the YAML was updated, creating an event description in the specific Lambda

177
00:11:14.160 --> 00:11:17.440
saying this Lambda can be triggered by an HTTP event.

178
00:11:18.480 --> 00:11:23.600
So that was really convenient as well, especially if you don't really know what's the right syntax.

179
00:11:23.600 --> 00:11:25.760
Should they put something on the API gateway side?

180
00:11:25.760 --> 00:11:27.920
Should I put something on the Lambda side?

181
00:11:27.920 --> 00:11:31.600
That kind of helps you out to really figure out how to describe that integration

182
00:11:31.600 --> 00:11:33.760
in CloudFormation and some.

183
00:11:34.560 --> 00:11:36.960
And finally, I did something similar for the bucket.

184
00:11:36.960 --> 00:11:42.880
So basically I connected the bucket to the Lambda and that understood that I wanted to use

185
00:11:43.440 --> 00:11:46.560
that particular bucket in the context of my Lambda code.

186
00:11:46.560 --> 00:11:49.360
So what happened is that it was created a policy for me.

187
00:11:49.360 --> 00:11:53.920
So for the Lambda to actually access the S3 bucket, but also this was really cool.

188
00:11:53.920 --> 00:11:58.560
It created two environment variables in the Lambda, referencing the name of the bucket

189
00:11:58.560 --> 00:12:02.800
and the ARN of the bucket, which is something very convenient when you need to start to add your code.

190
00:12:02.800 --> 00:12:05.840
You don't necessarily know what's going to be the name of the bucket.

191
00:12:05.840 --> 00:12:09.280
So generally you would use an environment variable to create a reference,

192
00:12:09.280 --> 00:12:14.080
and then you have an abstract way to connect to a specific bucket in your Lambda code.

193
00:12:15.360 --> 00:12:17.600
Now, the last step was to try to deploy all of this.

194
00:12:17.600 --> 00:12:22.240
I thought at that point I had, of course, I had to write a little bit more code in my own Lambda

195
00:12:22.240 --> 00:12:25.440
because the handler that was generated was just an Hello World.

196
00:12:25.440 --> 00:12:29.760
I actually wanted to write code to use the SDK,

197
00:12:29.760 --> 00:12:34.640
connect to S3 and create that file and then respond back to the API Gateway request.

198
00:12:35.360 --> 00:12:42.320
So for all of that, I needed to install a few extra dependencies because the SDK was not included.

199
00:12:42.320 --> 00:12:46.320
And also there is a dev dependency that you can use to get

200
00:12:46.320 --> 00:12:53.200
types for the different events and responses that you can use with the API integration.

201
00:12:53.200 --> 00:12:55.760
There was some code there, but the dependencies were not installed.

202
00:12:55.760 --> 00:12:59.680
So I needed to install those myself, but eventually I had all the code ready.

203
00:12:59.680 --> 00:13:03.360
It's probably like 12 lines of code. You can check that in the repository.

204
00:13:03.360 --> 00:13:04.480
And I was able to deploy.

205
00:13:05.040 --> 00:13:10.960
I wasn't able to deploy directly from Application Composer itself,

206
00:13:10.960 --> 00:13:12.720
but I had all the files locally.

207
00:13:12.720 --> 00:13:17.200
So basically locally you can just run SAM, you can do SAM build to build all the TypeScript

208
00:13:17.200 --> 00:13:21.200
and convert it into proper JavaScript. And then you can do SAM deploy to initialize

209
00:13:21.200 --> 00:13:26.080
a deploy. And after a few minutes, you should have everything running in your AWS account.

210
00:13:26.080 --> 00:13:30.000
It's pretty nice the way you can also then use SAM Accelerate.

211
00:13:30.000 --> 00:13:34.320
So you could run 'sam sync --watch' and have it just live update.

212
00:13:34.320 --> 00:13:36.880
So when you drag and drop components in your architecture,

213
00:13:37.680 --> 00:13:41.200
it's actually deploying that infrastructure under the hood and updating the function

214
00:13:41.200 --> 00:13:45.840
configuration under the hood. And it could be a fairly productive workflow

215
00:13:45.840 --> 00:13:49.760
for the kind of applications that Application Composer supports right now.

216
00:13:50.400 --> 00:13:53.200
So you've kind of explained how you start with the visual version,

217
00:13:53.200 --> 00:13:55.200
but we talked about this being bi-directional.

218
00:13:55.200 --> 00:13:57.280
So what happens if you've got an existing application?

219
00:13:57.840 --> 00:14:01.840
Can you import any application you've got that supports CloudFormation or SAM?

220
00:14:01.840 --> 00:14:03.920
Does it work flawlessly? Are there any limitations?

221
00:14:05.120 --> 00:14:08.080
Yeah, by the way, I didn't try to do that sync idea.

222
00:14:08.080 --> 00:14:11.680
I think it's a pretty cool idea. We should try it at some point.

223
00:14:11.680 --> 00:14:15.600
And I'd be curious to see what happens if you like break the YAML at some point,

224
00:14:16.160 --> 00:14:19.840
because another note that I have is that it's very easy to break the YAML if you create new

225
00:14:19.840 --> 00:14:22.880
resources, remove them, disconnect them, reconnect them.

226
00:14:22.880 --> 00:14:26.800
You might end up in a state where the YAML is not necessarily 100% correct

227
00:14:26.800 --> 00:14:31.120
until you fix the issues. So it would be interesting to try exactly what happens

228
00:14:31.120 --> 00:14:36.560
when you use the sync mode and then it tries to deploy continuously at every change.

229
00:14:36.560 --> 00:14:43.520
Anyway, with that aside, I did try to import an existing project that I worked on

230
00:14:43.520 --> 00:14:48.080
that is a little bit more... It's not too complicated, but there is a little bit more to it.

231
00:14:48.640 --> 00:14:52.800
And this is a project we will also have the repository link in the show notes.

232
00:14:52.800 --> 00:14:57.600
It's something that I call earthquake notifier, because it's a small personal project that I built

233
00:14:57.600 --> 00:15:02.800
just to be notified when a significantly interesting earthquake is happening close

234
00:15:02.800 --> 00:15:07.280
to my family in Sicily. So I can immediately know that that's happening and I can reach out to them

235
00:15:07.280 --> 00:15:13.040
to see if everything is fine. And it's a serverless project. Basically, it's built using a Lambda that

236
00:15:13.040 --> 00:15:18.160
runs on a schedule. This Lambda will call a specific API every hour that this API has a

237
00:15:18.160 --> 00:15:23.840
list of recent earthquakes in Italy and it will check if there is a set of conditions that will

238
00:15:23.840 --> 00:15:29.280
match mostly based on position and magnitude of the latest earthquakes. And if there is an

239
00:15:29.280 --> 00:15:33.840
earthquake that matches what it does, it creates an event bridge event. Then there is an event bridge

240
00:15:33.840 --> 00:15:39.600
rule that captures this kind of events and will deliver them to a CloudWatch log stream,

241
00:15:39.600 --> 00:15:44.080
just for me to see all of them historically. And also to an SNS topic where I can easily

242
00:15:44.080 --> 00:15:49.920
trigger notifications, for instance, to my email using an email subscription to that SNS topic.

243
00:15:49.920 --> 00:15:53.920
So again, it's not an extremely complicated project. It's actually a very simple one,

244
00:15:53.920 --> 00:15:58.960
but there are enough resources there to try to put application composers to test.

245
00:15:58.960 --> 00:16:03.760
And I did all of that using some pretty much manually. So it was also a good use case,

246
00:16:03.760 --> 00:16:07.680
I think, to try to see that reverse approach when you have something already created manually,

247
00:16:07.680 --> 00:16:10.960
what happens when you import it in Application Composer.

248
00:16:12.320 --> 00:16:17.760
So the result was actually a little bit disappointing because when I imported,

249
00:16:17.760 --> 00:16:22.080
well, basically I created a new canvas and I connected it to my local folder. But this time

250
00:16:22.080 --> 00:16:27.280
the local folder had all the files for this project, including the template.yaml. And what

251
00:16:27.280 --> 00:16:33.360
appeared in the canvas was some of the resources, not all of them, and they were not all connected

252
00:16:33.360 --> 00:16:38.160
correctly. I had my own architecture diagram and I was expecting to see something very close to it.

253
00:16:38.160 --> 00:16:43.200
Instead, it was very different. There were only a few resources that were connected together,

254
00:16:43.200 --> 00:16:49.360
and most of the connections were missing. And so that was a little bit disappointing.

255
00:16:49.360 --> 00:16:55.920
And I started to try to fill the gaps myself. For instance, I was trying to connect an event

256
00:16:55.920 --> 00:17:03.520
bridge rule to SNS and I got an error message popping up saying this feature is not supported

257
00:17:03.520 --> 00:17:08.720
yet. So this is probably one of the reasons why the Application Composer wasn't able to build

258
00:17:08.720 --> 00:17:13.600
a correct representation of the architecture or at least the connections between different

259
00:17:13.600 --> 00:17:17.120
resources correctly, because probably some of these things are not supported yet.

260
00:17:17.840 --> 00:17:24.320
So in general, yeah, I wasn't really happy with the result. I don't think it was giving me value

261
00:17:24.320 --> 00:17:28.160
at that point to continue with that approach. I think for that particular project, I was probably

262
00:17:28.160 --> 00:17:32.720
better off to just continue with the manual approach.

263
00:17:32.720 --> 00:17:37.120
Okay, so there's a mixture of good and bad there. Talk about, you mentioned that it's for creating serverless applications, right? So

264
00:17:37.680 --> 00:17:41.760
I'm sure then it supports all of the serverless offerings from AWS, including, I don't know,

265
00:17:41.760 --> 00:17:47.120
Fargate, MSK serverless, Redshift serverless, EMR serverless, right? They're all in the same

266
00:17:47.120 --> 00:17:54.800
serverless family. Obviously my tongue is in my cheek there, but what is the extent of it? Where

267
00:17:54.800 --> 00:18:00.720
do the boundaries exist for this Application Composer serverless world?

268
00:18:00.720 --> 00:18:06.880
Yeah, it definitely doesn't support many of the serverless or at least the ones labeled with serverless offering in AWS.

269
00:18:06.880 --> 00:18:11.520
For instance, Fargate is the one that I wish was there because it requires significant

270
00:18:11.520 --> 00:18:17.360
infrastructure as code to even just provision one container running on Fargate and it takes

271
00:18:17.360 --> 00:18:21.120
some time to learn all the concepts. We have another episode on that if you're curious.

272
00:18:21.680 --> 00:18:28.560
So definitely missing Fargate, I think it's a major feature that I wish was there. And of course,

273
00:18:28.560 --> 00:18:33.440
you mentioned other serverless services like Redshift, EMR and so on. It would be nice to

274
00:18:33.440 --> 00:18:38.640
have those also integrated in this tool. So the reality is that they are not there yet.

275
00:18:38.640 --> 00:18:44.000
There are, the last time I counted was I think yesterday, there were 13 resources, but I also counted them

276
00:18:44.560 --> 00:18:50.080
a couple of weeks ago and there were 12. So that's maybe an indicator that the team is working hard

277
00:18:50.080 --> 00:18:54.880
on this product and we will see more and more resources being added over time.

278
00:18:55.440 --> 00:19:00.960
So that's, in the negative, there is a positive trend that we see that there is cost and development happening

279
00:19:00.960 --> 00:19:08.160
on this tool. So things might change drastically in a few months. Then there were a couple of weird

280
00:19:08.160 --> 00:19:13.520
things that I noticed that I think are just confusing. I don't know if I will consider

281
00:19:13.520 --> 00:19:20.080
them missing features or bugs. I'm just going to try to give you a quick list of things that I

282
00:19:20.080 --> 00:19:25.920
found a little bit confusing or not really working as I expected. The first one is that you see step

283
00:19:25.920 --> 00:19:30.720
functions there. And I was like, okay, maybe this is a good alternative or a more integrated tool

284
00:19:30.720 --> 00:19:36.960
that I can use to design my Step Functions visually without, rather than using the step

285
00:19:36.960 --> 00:19:42.560
function designer tool. And then I realized that you can create this Step Function resource,

286
00:19:42.560 --> 00:19:47.200
but basically it only manages one state. It doesn't allow you to really create a complicated

287
00:19:47.200 --> 00:19:50.800
workflow. So you can just connect a Step Function to one Lambda, for instance, and that's it.

288
00:19:50.800 --> 00:19:56.240
You cannot create all the other logical connections that you can use with Step Functions, like if

289
00:19:56.240 --> 00:20:01.120
statements or parallel execution and all these kinds of things. So that was a little bit annoying

290
00:20:01.120 --> 00:20:05.760
because really there isn't a lot of value to have a Step Function resource if it doesn't do

291
00:20:05.760 --> 00:20:09.680
all, well, not necessarily all, but at least some of the main things that you're probably

292
00:20:10.800 --> 00:20:18.160
going to be using a Step Function for. The other one is that SQS queues are a little bit confusing

293
00:20:18.160 --> 00:20:23.920
because you can use an SQS queue as a, for instance, as something that triggers event on Lambdas.

294
00:20:23.920 --> 00:20:28.480
For instance, if you want to consume messages with a pool of Lambdas from a queue,

295
00:20:28.480 --> 00:20:34.880
but also you can use a queue as a dead letter queue for a Lambda. And it seems like these two

296
00:20:34.880 --> 00:20:39.280
options are supported, but I wasn't able to use the designer and really connect things in the

297
00:20:39.280 --> 00:20:45.600
way I wanted. So again, it feels more like there is some missing feature there or some bug, and it

298
00:20:45.600 --> 00:20:50.000
doesn't really seem to work in the way you want it to work, even though you know, or at least I

299
00:20:50.000 --> 00:20:54.320
was aware of the concept and I was trying to do something that was very clear in my mind, I wasn't

300
00:20:54.320 --> 00:21:01.360
able to use this tool to achieve that particular goal. The other thing, there are some other small things.

301
00:21:01.360 --> 00:21:04.960
Like for instance, it's really cool that it creates environment variables in Lambdas for

302
00:21:04.960 --> 00:21:09.600
you. But if you are experimenting heavily, like creating new resources, connecting them, then

303
00:21:09.600 --> 00:21:14.080
maybe removing them because you change your mind, you realize you can do something differently,

304
00:21:14.080 --> 00:21:18.160
all these environment variables are not cleaned up for you. So you will end up with a lot of

305
00:21:18.160 --> 00:21:22.480
references to resources that maybe are not relevant anymore to your Lambda, maybe you even

306
00:21:22.480 --> 00:21:27.600
deleted and your template at that point is wrong because it's going to fail to reference the

307
00:21:27.600 --> 00:21:32.800
specific resource when you try to deploy. So again, probably in between a bug and a missing

308
00:21:32.800 --> 00:21:37.280
feature there, so there is definitely work to do to polish it. Very similarly, if you change your

309
00:21:37.280 --> 00:21:42.320
own runtime, for instance, if you switch from JavaScript to TypeScript, it will create a

310
00:21:42.320 --> 00:21:47.280
JavaScript file first and then a TypeScript file, but it doesn't clean up the original JavaScript file.

311
00:21:47.280 --> 00:21:53.040
Now this is maybe a safety thing because if you have already written code in that JavaScript

312
00:21:53.040 --> 00:21:58.640
file, of course you don't want to lose that code, but you might end up with, for instance, I noticed

313
00:21:58.640 --> 00:22:04.400
that the package.json was not getting updated correctly, and if you manage to create a new

314
00:22:04.400 --> 00:22:09.680
Lambda with TypeScript straight away, the package.json will contain things that you need

315
00:22:09.680 --> 00:22:14.400
for TypeScript, like the type definitions, but if you started with JavaScript and then you create,

316
00:22:15.200 --> 00:22:19.120
you switch to TypeScript, it's not going to update your package.json anymore, so it doesn't match

317
00:22:19.120 --> 00:22:23.040
exactly your expectations at that point, and you need to manually fix all of that.

318
00:22:23.040 --> 00:22:29.920
Well, you need to realize first and then manually fix it. So yeah, that's another bugbear that I have with it,

319
00:22:29.920 --> 00:22:34.560
that it could be a little bit better and will give much more value. And last point I have is,

320
00:22:34.560 --> 00:22:39.040
actually last two points I have is one that for TypeScript, it is really cool that generates a

321
00:22:39.040 --> 00:22:44.560
skeleton for you with types already built in, but for instance, when you connect API Gateway,

322
00:22:44.560 --> 00:22:50.240
I was expecting to create a skeleton that will contain proper types for the LambdaProxy

323
00:22:50.240 --> 00:22:55.680
integration. Instead, it just gives you a generic handler object object, which at that point,

324
00:22:55.680 --> 00:23:00.800
it doesn't give you too much value for TypeScript. Of course, you can fix it manually, but it would

325
00:23:00.800 --> 00:23:05.360
have been so easy to add that extra step and you will get so much value for it, because you,

326
00:23:05.360 --> 00:23:10.480
even having to know exactly which types are the right one to use with API Gateway and the

327
00:23:10.480 --> 00:23:14.720
LambdaProxy integration takes a while, because there are so many different types of events

328
00:23:14.720 --> 00:23:18.480
in the TypeScript library that you will be spending probably five minutes just to figure

329
00:23:18.480 --> 00:23:22.960
out which ones are the right ones for the incoming event and the response that you have to provide.

330
00:23:23.760 --> 00:23:28.800
And finally, the last one is that I needed to go into the API Gateway console just to figure out

331
00:23:28.800 --> 00:23:34.000
the URL of my provision API Gateway, because it didn't create an output block for me, which is

332
00:23:34.000 --> 00:23:38.960
something that could have been very easy to do and very convenient. Just a small feature request,

333
00:23:38.960 --> 00:23:44.960
if anyone from AWS is listening. And the last thing, and I think we kind of mentioned this

334
00:23:44.960 --> 00:23:49.840
already, is that the Canvas resource is not persistent. So basically, that means that if

335
00:23:49.840 --> 00:23:55.360
you forget to copy paste your files, if you are working in a non-synchronized mode, you're going

336
00:23:55.360 --> 00:24:00.480
to lose everything you just did. It doesn't even ask you, like, when you're closing the tab, be

337
00:24:00.480 --> 00:24:05.040
careful because you're losing everything there. It just closes the tab and everything is gone.

338
00:24:05.040 --> 00:24:09.520
So if you were working in sync mode, you still have the files locally, you get everything that way.

339
00:24:09.520 --> 00:24:13.520
But if you didn't work in sync mode, it can be very dangerous that you might be losing everything,

340
00:24:13.520 --> 00:24:17.760
while I think the expectation in AWS is that everything is persistent.

341
00:24:17.760 --> 00:24:22.720
So that could be a little bit misleading if you are used to use the web console in AWS.

342
00:24:24.400 --> 00:24:29.200
So it sounds like there's quite a lot of work to do.

343
00:24:29.200 --> 00:24:33.440
I mean, on Application Composer, I think I'm still on the optimistic side because I like the fact that the designer user interface,

344
00:24:33.440 --> 00:24:37.680
it seems and feels like a bit of a step forward from other AWS user interfaces.

345
00:24:39.360 --> 00:24:43.040
If there was better support for all of the different configuration options for

346
00:24:43.040 --> 00:24:47.280
each of the services and some of the other things you point out, it could become very useful.

347
00:24:47.280 --> 00:24:50.800
But what's your opinion in general? Would you recommend for people listening,

348
00:24:51.440 --> 00:24:55.680
they should give it a chance now, wait for a while or just ditch Application Composer and

349
00:24:55.680 --> 00:24:58.400
forget about it altogether? It's a very good question.

350
00:24:58.400 --> 00:25:03.440
I honestly have a bit of mixed feelings. I see a lot of potential there. This might become a really

351
00:25:03.440 --> 00:25:09.280
good tool in the future. Right now, it is a little bit not there yet. It could be still useful if you

352
00:25:09.280 --> 00:25:13.360
are just doing your very first steps in AWS and you are trying to learn serverless and you want

353
00:25:13.360 --> 00:25:18.480
to use infrastructure as code, by the way, you should. So it could be really convenient for just

354
00:25:18.480 --> 00:25:23.120
doing some very quick experiments and trying to see if I do this, what kind of infrastructure

355
00:25:23.120 --> 00:25:28.720
as code do I get? And that could be a way to kind of train yourself to understand CloudFormation

356
00:25:28.720 --> 00:25:32.960
in a more practical way, rather than just reading the documentation and then copy pasting and trying

357
00:25:32.960 --> 00:25:39.120
to build things from scratch by yourself. This can speed up a little bit. You're building a

358
00:25:39.120 --> 00:25:45.600
mental model for our CloudFormation and some work. And when I was trying to think if I like this tool

359
00:25:45.600 --> 00:25:53.600
or not, I realized that probably like 20 years ago when I started my tech career, I was learning HTML

360
00:25:53.600 --> 00:25:58.320
and the way I learned it was through tools like FrontPage and Dreamweaver, which were giving me

361
00:25:58.320 --> 00:26:03.200
this kind of visual feeling. And then I was really curious and I was constantly switching to the

362
00:26:03.200 --> 00:26:09.680
HTML tab of everything that I was drawing. And it was horrible HTML, retrospective, like it wasn't

363
00:26:09.680 --> 00:26:16.240
clean at all. I wouldn't write HTML that way today, but that helped me a lot to learn the HTML

364
00:26:16.240 --> 00:26:20.880
language on itself. Like I was able to, for instance, draw a table with columns that were

365
00:26:20.880 --> 00:26:25.680
merged and very complicated things, and then just switch to the HTML tab and stuff to learn all the

366
00:26:25.680 --> 00:26:30.240
different tags and attributes that I could use to rebuild the thing myself. And eventually, of

367
00:26:30.240 --> 00:26:34.880
course, I stopped using these tools because I was able to just write HTML myself.

368
00:26:34.880 --> 00:26:39.920
But I think these tools were very instrumental for me to speed up that learning journey and make it more interactive

369
00:26:39.920 --> 00:26:44.880
and probably more rewarding, at least for the way of learning that I have. So hopefully Application

370
00:26:44.880 --> 00:26:50.080
Composer can become that kind of tool for infrastructure as code in AWS.

371
00:26:50.080 --> 00:26:54.240
That's at least my positive take on it.

372
00:26:54.240 --> 00:26:59.440
That sounds like a fair assessment. So it's worth a shot if you're getting started. And also maybe if you just want to prototype something up quickly based on all these

373
00:26:59.440 --> 00:27:04.640
serverless resources and then switch to code from that point on. I suppose we should probably say

374
00:27:04.640 --> 00:27:08.960
that it's always good advice to prepare to learn what the generated template syntax is anyway,

375
00:27:08.960 --> 00:27:12.400
and don't try to completely hide from infrastructure as code because it's a really

376
00:27:12.400 --> 00:27:17.120
valuable cloud skill. Maybe one day we'll be able to use Application Composer to import very advanced

377
00:27:17.120 --> 00:27:23.120
applications with loads of resources and keep that bi-directional flow going. But it's a difficult

378
00:27:23.120 --> 00:27:28.720
ambition to achieve. So maybe everyone out there, if you have tried it, let us know what you found

379
00:27:28.720 --> 00:27:32.960
about it and what you might expect from it in the future. Otherwise, thank you very much for joining

380
00:27:32.960 --> 00:27:34.960
us again and we'll see you in the next episode.
