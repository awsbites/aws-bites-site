WEBVTT

1
00:00:00.000 --> 00:00:03.120
Lambdas are a great abstraction to write event-driven logic

2
00:00:03.120 --> 00:00:05.440
and to split this logic into small, composable,

3
00:00:05.440 --> 00:00:06.840
and maintainable units.

4
00:00:06.840 --> 00:00:08.780
But as developers, we are not only sleeping bad

5
00:00:08.780 --> 00:00:11.160
at abusing technology, or at least I am.

6
00:00:11.160 --> 00:00:12.800
In today's episode, I want to tell you the story

7
00:00:12.800 --> 00:00:15.520
of how I ended up creating a terrible monolith Lambda

8
00:00:15.520 --> 00:00:18.160
and how five years later, doomed by the shame and guilt

9
00:00:18.160 --> 00:00:20.880
of having done that, I am now decomposing that Lambda

10
00:00:20.880 --> 00:00:22.480
using Step Functions.

11
00:00:22.480 --> 00:00:24.000
My name is Luciano, and I'm joined by Eoin

12
00:00:24.000 --> 00:00:26.240
for another episode of AWS Bites podcast.

13
00:00:26.240 --> 00:00:33.240
AWS Bites is made possible by the support of fourTheorem,

14
00:00:33.240 --> 00:00:35.520
an AWS consulting partner that works with you

15
00:00:35.520 --> 00:00:37.360
to make AWS migration, architecture,

16
00:00:37.360 --> 00:00:38.800
and development a success.

17
00:00:38.800 --> 00:00:40.800
See fourtheorem.com to find out more.

18
00:00:40.800 --> 00:00:42.560
The link is in the show notes.

19
00:00:42.560 --> 00:00:44.960
Let me start by telling you a little bit

20
00:00:44.960 --> 00:00:47.280
what's the context of this episode.

21
00:00:47.280 --> 00:00:49.640
I'm talking about a side project that I've been working on

22
00:00:49.640 --> 00:00:51.760
for a few years called Full Stack Bulletin,

23
00:00:51.760 --> 00:00:57.280
and it's a free weekly newsletter that you can subscribe

24
00:00:57.280 --> 00:01:00.080
if you go at fullstackbulletin.com.

25
00:01:00.080 --> 00:01:02.240
And the idea is that if you are a full stack web developer,

26
00:01:02.240 --> 00:01:04.600
then you might want to subscribe because you will receive

27
00:01:04.600 --> 00:01:06.160
some interesting information every week,

28
00:01:06.160 --> 00:01:08.080
and you can try to keep up with this field

29
00:01:08.080 --> 00:01:09.960
that evolves very quickly.

30
00:01:09.960 --> 00:01:13.160
And it's always very hard to find interesting information

31
00:01:13.160 --> 00:01:15.920
and try to stay up to date with the latest news.

32
00:01:15.920 --> 00:01:17.520
I guess that's the context, right?

33
00:01:17.520 --> 00:01:19.960
And let's try to figure out a little bit more

34
00:01:19.960 --> 00:01:21.040
about the implementation.

35
00:01:21.040 --> 00:01:23.320
This is a serverless project.

36
00:01:23.320 --> 00:01:25.680
As I said, something I built a long time ago.

37
00:01:25.680 --> 00:01:29.840
And the way I built it is a Lambda project

38
00:01:29.840 --> 00:01:32.800
effectively triggered on a schedule every week.

39
00:01:32.800 --> 00:01:35.960
And the idea is that I want to automate as much as possible

40
00:01:35.960 --> 00:01:37.960
because it's something that I want to keep doing every week,

41
00:01:37.960 --> 00:01:39.720
and I might be busy.

42
00:01:39.720 --> 00:01:41.400
I cannot spend too much time on this.

43
00:01:41.400 --> 00:01:43.320
It's a free activity after all.

44
00:01:43.320 --> 00:01:44.760
I think automation helps a lot.

45
00:01:44.760 --> 00:01:46.440
And the idea of this Lambda is that it's going to do

46
00:01:46.440 --> 00:01:49.960
as much work as possible to try to pre-combine a draft version

47
00:01:49.960 --> 00:01:51.160
of the next newsletter.

48
00:01:51.160 --> 00:01:54.200
And then I can edit it manually and improve things.

49
00:01:54.200 --> 00:01:56.320
So what this Lambda is doing, the newsletter

50
00:01:56.320 --> 00:01:57.880
is basically made up of three parts.

51
00:01:57.880 --> 00:01:59.000
There is a book suggestion.

52
00:01:59.000 --> 00:02:00.400
There is an inspirational quote.

53
00:02:00.400 --> 00:02:01.880
And there are seven links that might

54
00:02:01.880 --> 00:02:05.440
come from articles, videos, or GitHub

55
00:02:05.440 --> 00:02:09.120
repositories, or other projects that might be relevant.

56
00:02:09.120 --> 00:02:12.520
How do we fetch all this information?

57
00:02:12.520 --> 00:02:14.720
From different sources, but the most complicated one

58
00:02:14.720 --> 00:02:17.360
is fetching the links.

59
00:02:17.360 --> 00:02:20.560
And fetching the links is a bit of an involved process.

60
00:02:20.560 --> 00:02:23.120
So the idea is that I'm going to be finding

61
00:02:23.120 --> 00:02:25.040
interesting information throughout the week,

62
00:02:25.040 --> 00:02:26.880
and I will be tweeting it on Twitter,

63
00:02:26.880 --> 00:02:28.800
sharing these links on specific profiles.

64
00:02:28.800 --> 00:02:31.640
There is a full-stack bulletin profile on Twitter.

65
00:02:31.640 --> 00:02:33.960
Now, to differentiate these tweets

66
00:02:33.960 --> 00:02:37.600
from other regular tweets, I generally use Hootsuite.

67
00:02:37.600 --> 00:02:39.160
And Hootsuite is a service that allows

68
00:02:39.160 --> 00:02:40.600
you to schedule the tweets.

69
00:02:40.600 --> 00:02:45.520
And these tweets are also spread out during the week using

70
00:02:45.520 --> 00:02:47.600
Hootsuite, because you can just put them on a queue,

71
00:02:47.600 --> 00:02:49.680
and they will be automatically spread out.

72
00:02:49.680 --> 00:02:52.920
So this automation needs to connect to Twitter,

73
00:02:52.920 --> 00:02:55.000
discriminate between the interesting tweets coming

74
00:02:55.000 --> 00:02:57.120
from Hootsuite and the regular ones.

75
00:02:57.120 --> 00:03:00.240
Then it's going to take all the ones that contain links.

76
00:03:00.240 --> 00:03:02.760
It's going to filter out all the invalid links or the ones

77
00:03:02.760 --> 00:03:05.440
that have been used already in previous newsletters.

78
00:03:05.440 --> 00:03:07.200
Then it's going to try to rank them.

79
00:03:07.200 --> 00:03:08.600
There is a super secret algorithm,

80
00:03:08.600 --> 00:03:11.480
which is just counting the number of shares

81
00:03:11.480 --> 00:03:12.920
of that particular URL.

82
00:03:12.920 --> 00:03:14.800
And then it takes the top seven.

83
00:03:14.800 --> 00:03:17.360
And for every link that is selected,

84
00:03:17.360 --> 00:03:18.560
we need to get some metadata.

85
00:03:18.560 --> 00:03:20.640
So there is a process that scrapes every link,

86
00:03:20.640 --> 00:03:22.400
extra the title, description, and it

87
00:03:22.400 --> 00:03:24.280
tries to get a relevant image.

88
00:03:24.280 --> 00:03:26.960
Sometimes the image is not available, not every article

89
00:03:26.960 --> 00:03:28.000
has an image.

90
00:03:28.000 --> 00:03:32.480
So there is a fallback step that uses a placeholder image that

91
00:03:32.480 --> 00:03:34.600
is related to technology, something very generic,

92
00:03:34.600 --> 00:03:37.480
but that still fits nicely with the overall theme.

93
00:03:37.480 --> 00:03:39.560
Then these images are uploaded to Cloudinary,

94
00:03:39.560 --> 00:03:42.540
which takes care of doing a CDN, downscaling the picture,

95
00:03:42.540 --> 00:03:44.200
and all that kind of stuff.

96
00:03:44.200 --> 00:03:48.040
So all this stuff is then taken together and used

97
00:03:48.040 --> 00:03:48.800
with Mailchimp.

98
00:03:48.800 --> 00:03:51.240
So there is another step that takes all this information,

99
00:03:51.240 --> 00:03:52.160
sends it to Mailchimp.

100
00:03:52.160 --> 00:03:53.920
There is already a template in Mailchimp.

101
00:03:53.920 --> 00:03:55.520
A draft campaign is created.

102
00:03:55.520 --> 00:03:58.480
And then I receive a preview by email.

103
00:03:58.480 --> 00:04:00.760
Wow, there's quite a lot of steps involved there.

104
00:04:00.760 --> 00:04:04.360
And I'm interested in knowing, I've seen Fullstack Bulletin,

105
00:04:04.360 --> 00:04:06.600
and it's really useful and looks really slick.

106
00:04:06.600 --> 00:04:08.640
It looks like there's a lot of time put into it.

107
00:04:08.640 --> 00:04:10.160
So how much of that is manual?

108
00:04:10.160 --> 00:04:12.560
I mean, I can imagine that just taking the top seven tweets

109
00:04:12.560 --> 00:04:15.520
based on the number of shares is probably good in the most case.

110
00:04:15.520 --> 00:04:16.960
But sometimes you end up with things

111
00:04:16.960 --> 00:04:18.720
that are not so relevant, or maybe they've

112
00:04:18.720 --> 00:04:20.400
gone viral for the wrong reason.

113
00:04:20.400 --> 00:04:21.680
So how do you manage that?

114
00:04:21.680 --> 00:04:23.240
Is it just a manual process where

115
00:04:23.240 --> 00:04:24.560
you have to curate all of this?

116
00:04:24.560 --> 00:04:25.960
Is it fully automated?

117
00:04:27.680 --> 00:04:29.900
So I think my goal has always been that I want to keep the curation.

118
00:04:29.900 --> 00:04:32.240
So I don't want to get random stuff.

119
00:04:32.240 --> 00:04:35.040
I still want every single piece of content

120
00:04:35.040 --> 00:04:39.280
that comes out to be something that I somehow selected before.

121
00:04:39.280 --> 00:04:42.200
So every week, everything I read that I think is relevant,

122
00:04:42.200 --> 00:04:43.080
I will be sharing it.

123
00:04:43.080 --> 00:04:45.360
And I think that's part of the curation process.

124
00:04:45.360 --> 00:04:48.200
Then ideally, I wouldn't want to spend more than 15 minutes

125
00:04:48.200 --> 00:04:51.080
every weekend, because I generally

126
00:04:51.080 --> 00:04:54.000
do the process where I receive the email, the draft,

127
00:04:54.000 --> 00:04:55.200
every Friday evening.

128
00:04:55.200 --> 00:04:57.840
And then I have a couple of days just to review and refine.

129
00:04:57.840 --> 00:05:00.640
And then the next Monday afternoon, the new issue

130
00:05:00.640 --> 00:05:01.720
will go out.

131
00:05:01.720 --> 00:05:04.640
So in my mind, I would like to spend no more than 15 minutes.

132
00:05:04.640 --> 00:05:06.800
In reality, I will be spending a bit more,

133
00:05:06.800 --> 00:05:09.240
because generally, the draft is not perfect.

134
00:05:09.240 --> 00:05:12.160
I will need to change images that are not relevant.

135
00:05:12.160 --> 00:05:14.080
Some articles might not be very relevant,

136
00:05:14.080 --> 00:05:16.460
so I might want to swap them out with other ones.

137
00:05:16.460 --> 00:05:17.960
Or sometimes there are a few articles

138
00:05:17.960 --> 00:05:19.200
that are very similar.

139
00:05:19.200 --> 00:05:23.080
So I don't want just one topic to be a recurring thing

140
00:05:23.080 --> 00:05:24.800
in the newsletter for the week.

141
00:05:24.800 --> 00:05:28.240
So that's also another reason to try to find different articles.

142
00:05:28.240 --> 00:05:29.640
And then for every single article,

143
00:05:29.640 --> 00:05:31.920
I try to change the description a little bit,

144
00:05:31.920 --> 00:05:35.400
because the style is always very different between one

145
00:05:35.400 --> 00:05:36.680
description and the other.

146
00:05:36.680 --> 00:05:39.180
And also, I would like to add a little bit of personal touch.

147
00:05:39.180 --> 00:05:41.520
Why did I think that that particular link was interesting?

148
00:05:41.520 --> 00:05:44.080
Was it something that I played with during that week?

149
00:05:44.080 --> 00:05:46.840
Or is it some technology that I want to experiment more with?

150
00:05:46.840 --> 00:05:49.240
Or is it maybe something new that I think is, I don't know,

151
00:05:49.240 --> 00:05:51.240
revolutionizing some kind of field,

152
00:05:51.240 --> 00:05:53.520
and therefore is going to be something to watch out for?

153
00:05:53.520 --> 00:05:55.440
So I try to add the kind of bit of,

154
00:05:55.440 --> 00:05:57.720
this is why I think this link is something that should

155
00:05:57.720 --> 00:05:58.860
be worth your attention.

156
00:05:58.860 --> 00:06:02.320
And that ends up taking a lot of time sometimes.

157
00:06:02.320 --> 00:06:04.760
Some weeks is really 15 minutes, but most of the time,

158
00:06:04.760 --> 00:06:06.640
it's probably one hour a week that I just spent

159
00:06:06.640 --> 00:06:08.680
refining the newsletter.

160
00:06:08.680 --> 00:06:11.400
That sounds like a really nice process, but I suppose

161
00:06:11.400 --> 00:06:13.120
one of the things about the process that I'm kind of

162
00:06:13.120 --> 00:06:15.800
thinking might be problematic is that you're dependent on

163
00:06:15.800 --> 00:06:17.540
third party systems.

164
00:06:17.540 --> 00:06:21.320
So we're talking about Hootsuite and Twitter and Cloudinary.

165
00:06:21.320 --> 00:06:23.520
And I guess when you have external systems in the mix,

166
00:06:23.520 --> 00:06:26.560
you have to think about fault tolerance and also what

167
00:06:26.560 --> 00:06:29.880
happens when they change their contract and their API.

168
00:06:29.880 --> 00:06:32.160
So what has the implementation been like?

169
00:06:32.160 --> 00:06:33.360
And what have the problems been with it?

170
00:06:33.360 --> 00:06:36.040
Because I know you've been live streaming stuff on this

171
00:06:36.040 --> 00:06:37.520
recently.

172
00:06:37.520 --> 00:06:39.160
Maybe you can give people a bit of background.

173
00:06:39.160 --> 00:06:42.120
Yeah, I think that this Lambda is something that I wrote,

174
00:06:42.120 --> 00:06:44.960
I don't know, five years ago, if not more.

175
00:06:44.960 --> 00:06:47.900
And I didn't really have to change it much since then.

176
00:06:47.900 --> 00:06:50.800
So even if today I'm not super happy with that

177
00:06:50.800 --> 00:06:54.160
implementation, it hasn't really been a problem so far.

178
00:06:54.160 --> 00:06:57.200
Lately, it has become a problem because lots of things

179
00:06:57.200 --> 00:06:58.040
started to break.

180
00:06:58.040 --> 00:07:00.760
And as you said, you depend on external services and things

181
00:07:00.760 --> 00:07:02.640
might change with external services.

182
00:07:02.640 --> 00:07:05.120
Funny enough, lots of them change at the same time,

183
00:07:05.120 --> 00:07:05.960
more or less.

184
00:07:05.960 --> 00:07:08.800
So I was left with a lot of problems to try to solve

185
00:07:08.800 --> 00:07:11.040
in a very short amount of time.

186
00:07:11.040 --> 00:07:14.000
One problem was Twitter, not only made it very difficult

187
00:07:14.000 --> 00:07:16.840
to use their APIs, very expensive as well.

188
00:07:16.840 --> 00:07:19.040
There are some free APIs that you can use,

189
00:07:19.040 --> 00:07:21.880
but I think it was very hard for me, first of all,

190
00:07:21.880 --> 00:07:25.280
to understand how do you even get API keys.

191
00:07:25.280 --> 00:07:28.400
I wasn't able to get API keys for my own personal account.

192
00:07:28.400 --> 00:07:31.000
I was able to get them eventually for the full stack

193
00:07:31.000 --> 00:07:32.200
bulletin account.

194
00:07:32.200 --> 00:07:35.280
But then with those free API keys,

195
00:07:35.280 --> 00:07:38.520
supposedly you can only read user information

196
00:07:38.520 --> 00:07:39.960
but not even the tweets.

197
00:07:39.960 --> 00:07:43.840
So it wasn't really useful at the end to do anything, right?

198
00:07:43.840 --> 00:07:46.280
So I had to change strategy there.

199
00:07:46.280 --> 00:07:47.880
And we'll talk about that in a second.

200
00:07:47.880 --> 00:07:51.600
Then also, OotSuite decided to revoke any free plan.

201
00:07:51.600 --> 00:07:53.520
I was able to use the free plan for a while

202
00:07:53.520 --> 00:07:56.600
because I was tweeting something around 20 maybe

203
00:07:56.600 --> 00:07:57.320
tweets per week.

204
00:07:57.320 --> 00:07:58.160
So it was not a lot.

205
00:07:58.160 --> 00:08:00.600
It was definitely in the realm of the free plan.

206
00:08:00.600 --> 00:08:02.160
But now there is no free plan at all.

207
00:08:02.160 --> 00:08:05.480
And I think that the cheapest one starts at $50 or $60,

208
00:08:05.480 --> 00:08:07.400
which is definitely not worth it for something

209
00:08:07.400 --> 00:08:09.080
I'm doing basically for free.

210
00:08:09.080 --> 00:08:11.520
And then there was another service called Place Image,

211
00:08:11.520 --> 00:08:14.280
which is one of those thumbnail generator services

212
00:08:14.280 --> 00:08:15.200
that you would use.

213
00:08:15.200 --> 00:08:17.320
I don't know if you are sketching out a landing page

214
00:08:17.320 --> 00:08:19.560
and you want to have some place on the image, which

215
00:08:19.560 --> 00:08:21.280
was really nice because just by composing

216
00:08:21.280 --> 00:08:23.360
a URL with specific parameters, you

217
00:08:23.360 --> 00:08:26.840
could get a random image, for instance, technology, right,

218
00:08:26.840 --> 00:08:28.360
through different categories.

219
00:08:28.360 --> 00:08:31.160
That service was a free service and now it's shut down.

220
00:08:31.160 --> 00:08:34.080
So I needed to figure out an alternative for that one.

221
00:08:34.080 --> 00:08:36.680
And with all these things starting to break,

222
00:08:36.680 --> 00:08:38.720
initially it was a bit tricky to understand why is

223
00:08:38.720 --> 00:08:40.880
the newsletter failing this week?

224
00:08:40.880 --> 00:08:42.920
Why is this Lambda not sending me the preview?

225
00:08:42.920 --> 00:08:45.360
And I would log in into AWS, look at the errors

226
00:08:45.360 --> 00:08:48.640
in the console, and it would be just a random JavaScript error

227
00:08:48.640 --> 00:08:49.160
somewhere.

228
00:08:49.160 --> 00:08:52.080
I'm very apt to tell why that was happening.

229
00:08:52.080 --> 00:08:53.200
And for a few reasons.

230
00:08:53.200 --> 00:08:56.720
Admittedly, this Lambda was in a very bad state code-wise.

231
00:08:56.720 --> 00:08:58.960
It was written five years ago.

232
00:08:58.960 --> 00:09:01.120
Async-await wasn't even available in Node.js.

233
00:09:01.120 --> 00:09:04.280
So I was using Babel and Webpack to transpile everything

234
00:09:04.280 --> 00:09:07.160
and be able to still use Async-await to make the code

235
00:09:07.160 --> 00:09:09.400
a little bit easier to write.

236
00:09:09.400 --> 00:09:12.240
But that made it so that when you have a stack trace,

237
00:09:12.240 --> 00:09:14.960
even though I was trying to use one of those source map

238
00:09:14.960 --> 00:09:18.320
libraries that were available five years ago,

239
00:09:18.320 --> 00:09:20.200
it doesn't always resolve correctly.

240
00:09:20.200 --> 00:09:21.520
So sometimes you get stack traces

241
00:09:21.520 --> 00:09:23.160
that they don't make sense at all.

242
00:09:23.160 --> 00:09:25.160
They will just point you to a random place, which

243
00:09:25.160 --> 00:09:27.240
is not really the place where the error is happening.

244
00:09:27.240 --> 00:09:29.160
So you just need to rely on the error message

245
00:09:29.160 --> 00:09:32.040
and try to simulate things locally and try to figure out,

246
00:09:32.040 --> 00:09:33.600
OK, where is this really breaking?

247
00:09:33.600 --> 00:09:35.320
Because if you just look at the stack trace,

248
00:09:35.320 --> 00:09:37.720
it's not really telling you the truth sometimes.

249
00:09:37.720 --> 00:09:40.280
So definitely I had to get my ends dirty

250
00:09:40.280 --> 00:09:42.000
and try to fix all these things.

251
00:09:42.000 --> 00:09:44.160
And at that point, I realized, well,

252
00:09:44.160 --> 00:09:46.240
why did I put everything in one Lambda

253
00:09:46.240 --> 00:09:50.000
when there are clearly a bunch of different separated logical

254
00:09:50.000 --> 00:09:50.720
steps?

255
00:09:50.720 --> 00:09:53.240
So maybe a Step Function there could have been much better.

256
00:09:53.240 --> 00:09:54.120
I hope you don't mind.

257
00:09:54.120 --> 00:09:56.680
But I'm looking at an old version of the Lambda function

258
00:09:56.680 --> 00:09:58.080
handler from 2020.

259
00:09:58.080 --> 00:10:00.280
I just picked one at random just to see what you're

260
00:10:00.280 --> 00:10:01.000
getting at here.

261
00:10:01.000 --> 00:10:02.840
And it looks like it's pretty well structured.

262
00:10:02.840 --> 00:10:06.200
I mean, it actually reminds me of the kind of orchestration

263
00:10:06.200 --> 00:10:08.400
logic you might have in a web service endpoint

264
00:10:08.400 --> 00:10:10.360
where you've got lots of modules.

265
00:10:10.360 --> 00:10:12.160
You've broken down each step in the process

266
00:10:12.160 --> 00:10:13.400
into different node modules.

267
00:10:13.400 --> 00:10:15.240
And then you're calling them one after another

268
00:10:15.240 --> 00:10:16.840
in using async await.

269
00:10:16.840 --> 00:10:18.600
And it's very easy to actually understand.

270
00:10:18.600 --> 00:10:20.200
And this is the nice thing about it

271
00:10:20.200 --> 00:10:22.000
is that you can kind of see it top to bottom.

272
00:10:22.000 --> 00:10:24.520
And the process is pretty clear, at least

273
00:10:24.520 --> 00:10:27.280
from a kind of code understandability point of view.

274
00:10:27.280 --> 00:10:31.000
So what is the motivation then to move to Step Functions?

275
00:10:31.000 --> 00:10:33.400
And what is your thinking there?

276
00:10:33.400 --> 00:10:35.240
Let me try to describe first what

277
00:10:35.240 --> 00:10:36.640
I am thinking in terms of what is

278
00:10:36.640 --> 00:10:38.640
going to be the final state of the Step Function.

279
00:10:38.640 --> 00:10:40.560
And big disclaimer, this is still in progress.

280
00:10:40.560 --> 00:10:43.760
I have done some steps, but it's not fully completed.

281
00:10:43.760 --> 00:10:46.280
So what I have in mind for the final design

282
00:10:46.280 --> 00:10:48.640
is that basically this will be a Step Function

283
00:10:48.640 --> 00:10:50.040
with a bunch of different steps.

284
00:10:50.040 --> 00:10:53.880
The first one is going to be like a parallel step where

285
00:10:53.880 --> 00:10:56.760
we are fetching information from three different data sources,

286
00:10:56.760 --> 00:10:58.720
one for the book, one for the quote,

287
00:10:58.720 --> 00:11:00.080
and then we have all the links.

288
00:11:00.080 --> 00:11:02.880
So that could be three different branches.

289
00:11:02.880 --> 00:11:05.040
And each and every one would fetch their own information

290
00:11:05.040 --> 00:11:06.080
in parallel.

291
00:11:06.080 --> 00:11:08.600
Now, the book and the quote will be relatively easy,

292
00:11:08.600 --> 00:11:11.040
but fetching the links is a little bit involved

293
00:11:11.040 --> 00:11:13.440
because inside that branch, technically, there

294
00:11:13.440 --> 00:11:17.120
could be multiple steps, maybe one step all in sequence, one

295
00:11:17.120 --> 00:11:17.960
after the other.

296
00:11:17.960 --> 00:11:20.440
Maybe the first step fetches the link from Twitter,

297
00:11:20.440 --> 00:11:22.480
which now has been replaced with Mastodon,

298
00:11:22.480 --> 00:11:24.920
just because I cannot use Twitter anymore.

299
00:11:24.920 --> 00:11:26.560
So fetch all the base links.

300
00:11:26.560 --> 00:11:28.040
And then there might be another step

301
00:11:28.040 --> 00:11:30.760
that tries to filter out the ones that are broken or not

302
00:11:30.760 --> 00:11:34.760
relevant or used before, and another step where maybe you

303
00:11:34.760 --> 00:11:36.040
do the top seven.

304
00:11:36.040 --> 00:11:37.560
And then once you have the top seven,

305
00:11:37.560 --> 00:11:39.840
you could do a map step to try to scrape all of them

306
00:11:39.840 --> 00:11:43.040
in parallel and get the metadata for each and every one of them.

307
00:11:43.040 --> 00:11:45.040
At that point, outside the big parallel step,

308
00:11:45.040 --> 00:11:46.920
we could have an extra step that just takes

309
00:11:46.920 --> 00:11:48.760
all of this information from the state

310
00:11:48.760 --> 00:11:51.240
and use it to create the MailChimp preview

311
00:11:51.240 --> 00:11:52.880
and send it by email.

312
00:11:52.880 --> 00:11:54.240
So that would be the structure.

313
00:11:54.240 --> 00:12:00.480
And I think with this idea, the point is basically,

314
00:12:00.480 --> 00:12:03.120
if something fails, it's going to be very easy for me to figure

315
00:12:03.120 --> 00:12:04.520
out exactly which step is failing.

316
00:12:04.520 --> 00:12:06.060
So that's already a big advantage,

317
00:12:06.060 --> 00:12:08.560
because you visually see the representation of the step

318
00:12:08.560 --> 00:12:09.060
function.

319
00:12:09.060 --> 00:12:10.120
You see the execution.

320
00:12:10.120 --> 00:12:11.840
You can see all the green nodes, and you

321
00:12:11.840 --> 00:12:13.520
can see where the nodes are read.

322
00:12:13.520 --> 00:12:15.600
And then you can click and start to zoom in exactly

323
00:12:15.600 --> 00:12:16.680
on that particular Lambda.

324
00:12:16.680 --> 00:12:18.840
So that reduces the scope for the error.

325
00:12:18.840 --> 00:12:21.120
The other thing is that if something fails in a transit

326
00:12:21.120 --> 00:12:22.680
way, for instance, I don't know, maybe

327
00:12:22.680 --> 00:12:24.360
a service as a networking glitch.

328
00:12:24.360 --> 00:12:26.560
You are not able to complete a request.

329
00:12:26.560 --> 00:12:28.720
But if you retry, that time will go well.

330
00:12:28.720 --> 00:12:30.560
So withStep Function, it's actually very easy

331
00:12:30.560 --> 00:12:32.600
to define this retry logic without having

332
00:12:32.600 --> 00:12:33.920
to write custom code for it.

333
00:12:33.920 --> 00:12:35.920
So that's another reason.

334
00:12:35.920 --> 00:12:38.400
And in general, I think the fact that you

335
00:12:38.400 --> 00:12:41.360
can structure all the parallel steps so easily

336
00:12:41.360 --> 00:12:43.360
should make everything faster, because you are not

337
00:12:43.360 --> 00:12:45.600
creating that sequential logic.

338
00:12:45.600 --> 00:12:47.480
Or you are not making your code more complicated

339
00:12:47.480 --> 00:12:50.400
to try to do things in parallel at the level of your code.

340
00:12:50.400 --> 00:12:52.600
But you let the Step Function do all the parallel

341
00:12:52.600 --> 00:12:54.920
ization and dealing with concurrent stuff

342
00:12:54.920 --> 00:12:56.680
wherever possible.

343
00:12:56.680 --> 00:12:58.040
That makes a lot of sense to me.

344
00:12:58.040 --> 00:13:00.200
Just since you're talking about Mastodon,

345
00:13:00.200 --> 00:13:01.960
I mean, I'm on Mastodon too, but I

346
00:13:01.960 --> 00:13:04.480
don't think I've reached the same level engagement as we

347
00:13:04.480 --> 00:13:09.720
had previously on Twitter before it went the way it is.

348
00:13:09.720 --> 00:13:12.560
Where it just seems, I don't know,

349
00:13:12.560 --> 00:13:15.320
every time I open Twitter, it's worse

350
00:13:15.320 --> 00:13:16.480
in lots of different ways.

351
00:13:16.480 --> 00:13:18.680
But let's maybe share our handles

352
00:13:18.680 --> 00:13:21.680
for Mastodon and the full stack one as well in the show notes

353
00:13:21.680 --> 00:13:23.720
for all the listeners who are living in the Fediverse,

354
00:13:23.720 --> 00:13:25.960
and we can try and grow the engagement that way.

355
00:13:25.960 --> 00:13:27.840
I'm also wondering, are you planning on,

356
00:13:27.840 --> 00:13:31.240
are you thinking about Blue Sky, Threads, LinkedIn,

357
00:13:31.240 --> 00:13:34.200
or other platforms as well for full stack bulletin?

358
00:13:34.200 --> 00:13:37.040
Because it seems like things are going to spread out and move

359
00:13:37.040 --> 00:13:39.960
beyond just one platform for this kind of interaction.

360
00:13:39.960 --> 00:13:40.720
Yeah, absolutely.

361
00:13:40.720 --> 00:13:43.720
I did think about using pretty much all of them.

362
00:13:43.720 --> 00:13:46.440
I think I ended up with Mastodon just because the APIs are

363
00:13:46.440 --> 00:13:47.760
so easy to use.

364
00:13:47.760 --> 00:13:51.640
And there is a very good Node.js client that pretty much was

365
00:13:51.640 --> 00:13:54.880
like everything I needed to do in one function call.

366
00:13:54.880 --> 00:13:57.040
Also, you don't have a complicated authentication

367
00:13:57.040 --> 00:13:57.560
process.

368
00:13:57.560 --> 00:14:00.560
You create an app, and then you can get an application token.

369
00:14:00.560 --> 00:14:03.600
So you don't need to do like an OAuth 2 kind of process

370
00:14:03.600 --> 00:14:05.760
just to be able to get your own tokens.

371
00:14:05.760 --> 00:14:08.240
So it was really easy to set up for this particular use case,

372
00:14:08.240 --> 00:14:10.400
and I was able to do that transition

373
00:14:10.400 --> 00:14:11.800
in a couple of hours.

374
00:14:11.800 --> 00:14:14.720
So I was impressed how easy it was to use that API.

375
00:14:14.720 --> 00:14:17.320
And I think going with LinkedIn or Blue Sky or others

376
00:14:17.320 --> 00:14:19.320
would have been more involved.

377
00:14:19.320 --> 00:14:21.800
So I just went for the one that was giving me

378
00:14:21.800 --> 00:14:24.360
the easiest path to migration.

379
00:14:24.360 --> 00:14:26.840
Even though the platform itself, I'm

380
00:14:26.840 --> 00:14:28.360
not getting a lot of engagement yet.

381
00:14:28.360 --> 00:14:31.080
So maybe that's something that will grow, but I don't know.

382
00:14:31.080 --> 00:14:32.520
I have some doubts that it's going

383
00:14:32.520 --> 00:14:34.520
to get at the levels of Twitter, to be honest.

384
00:14:36.040 --> 00:14:37.520
The fact that you have it now or you're moving towards a Step Function means

385
00:14:37.520 --> 00:14:39.920
that it will be easier to modularize it and orchestrate

386
00:14:39.920 --> 00:14:41.640
multiple platforms in the future.

387
00:14:41.640 --> 00:14:43.000
So what's the plan to migrate?

388
00:14:43.000 --> 00:14:45.160
Are you looking at a big migration effort

389
00:14:45.160 --> 00:14:46.560
here to get to the end state?

390
00:14:48.920 --> 00:14:51.200
Yeah, I think the key here is that this is a side project, and I'm not going to be investing more than a couple

391
00:14:51.200 --> 00:14:53.240
of hours a week on it.

392
00:14:53.240 --> 00:14:55.720
And the refactoring is probably about one hour a week

393
00:14:55.720 --> 00:14:57.440
when I'm doing my live streams.

394
00:14:57.440 --> 00:14:59.560
So I need to be strategic about that.

395
00:14:59.560 --> 00:15:03.840
I cannot do a big bang type of migration where I'd be spending

396
00:15:03.840 --> 00:15:05.960
hundreds of hours, and maybe two years later, I

397
00:15:05.960 --> 00:15:07.880
will swap the thing entirely.

398
00:15:07.880 --> 00:15:09.520
Also because it was broken at the time.

399
00:15:09.520 --> 00:15:11.800
So I needed to figure out how to do a migration that

400
00:15:11.800 --> 00:15:13.760
will fix the problem while progressing

401
00:15:13.760 --> 00:15:15.680
in that direction of the migration.

402
00:15:15.680 --> 00:15:18.960
So the idea was that every time I do a change,

403
00:15:18.960 --> 00:15:23.840
I need to figure out what is the minimum valuable, I guess,

404
00:15:23.840 --> 00:15:26.080
change in the direction that I want to go so that I don't

405
00:15:26.080 --> 00:15:28.000
break things, and I can ship it to production

406
00:15:28.000 --> 00:15:31.680
and make sure that I got some extra value.

407
00:15:31.680 --> 00:15:34.320
I went a little step forward in that direction

408
00:15:34.320 --> 00:15:36.600
while still keeping something that works.

409
00:15:36.600 --> 00:15:39.560
So the idea there was let's try to extract.

410
00:15:39.560 --> 00:15:42.200
The first step was, OK, let's just take the monolith Lambda

411
00:15:42.200 --> 00:15:43.440
and wrap it in a Step Function.

412
00:15:43.440 --> 00:15:45.040
This Step Function doesn't do anything special.

413
00:15:45.040 --> 00:15:46.280
It's just one state.

414
00:15:46.280 --> 00:15:48.480
But at least now we are in the realm of Step Function.

415
00:15:48.480 --> 00:15:50.160
That was my first change.

416
00:15:50.160 --> 00:15:51.760
Then after that change was in place,

417
00:15:51.760 --> 00:15:54.080
I was still able to deploy and run it.

418
00:15:54.080 --> 00:15:55.120
It was still failing.

419
00:15:55.120 --> 00:15:58.400
Meanwhile, I had to fix in that Lambda some of the problems.

420
00:15:58.400 --> 00:16:00.640
Like for instance, I swapped Twitter for Mastodon.

421
00:16:00.640 --> 00:16:01.760
I removed Hootsuite.

422
00:16:01.760 --> 00:16:04.280
I changed place image with Unsplash,

423
00:16:04.280 --> 00:16:08.320
which also has nice APIs and a free tier that you can use.

424
00:16:08.320 --> 00:16:10.360
And at that point, I had everything

425
00:16:10.360 --> 00:16:11.560
working in a Step Function.

426
00:16:11.560 --> 00:16:13.400
Still very monolithic, but was something

427
00:16:13.400 --> 00:16:16.160
that I could use to produce the next newsletter.

428
00:16:16.160 --> 00:16:18.880
From there, it's very easy to start to extract states.

429
00:16:18.880 --> 00:16:20.760
For instance, the first state that I extracted,

430
00:16:20.760 --> 00:16:22.600
I didn't even create a parallel step yet.

431
00:16:22.600 --> 00:16:24.520
I just created two sequential states

432
00:16:24.520 --> 00:16:28.160
where I think I started first either the quote or the book.

433
00:16:28.160 --> 00:16:29.000
I'm not sure.

434
00:16:29.000 --> 00:16:30.600
But basically, there were two steps.

435
00:16:30.600 --> 00:16:32.120
One extracted the quote and adding it

436
00:16:32.120 --> 00:16:34.000
to the global state of the Step Function.

437
00:16:34.000 --> 00:16:35.840
And then everything else was pretty much

438
00:16:35.840 --> 00:16:38.520
the same monolithic Lambda, except that rather than taking

439
00:16:38.520 --> 00:16:41.800
the book itself, it was just reading it from the state.

440
00:16:41.800 --> 00:16:43.320
At that point, the next step was, OK,

441
00:16:43.320 --> 00:16:48.160
let's start to create a parallel step at the beginning, where

442
00:16:48.160 --> 00:16:49.680
I can do multiple things together.

443
00:16:49.680 --> 00:16:53.200
So not just fetch the book, but fetch the book and the quote,

444
00:16:53.200 --> 00:16:55.720
and then use them and put them in the global state

445
00:16:55.720 --> 00:16:58.920
and make the current monolithic Lambda a little bit slimmer,

446
00:16:58.920 --> 00:17:00.960
because it can just read things from the state,

447
00:17:00.960 --> 00:17:02.680
rather than doing more stuff.

448
00:17:02.680 --> 00:17:05.560
And the next steps would be to start to branch out also

449
00:17:05.560 --> 00:17:09.000
the link fetching step and processing step

450
00:17:09.000 --> 00:17:11.280
into another branch into the parallel step

451
00:17:11.280 --> 00:17:14.080
and remove all of that code from the monolithic Lambda.

452
00:17:14.080 --> 00:17:15.520
So basically, the monolithic Lambda

453
00:17:15.520 --> 00:17:18.280
is still leaving us the last step of the Step Function,

454
00:17:18.280 --> 00:17:20.120
but it's becoming slimmer and slimmer

455
00:17:20.120 --> 00:17:24.120
as I extract out steps that will go into their own dedicated

456
00:17:24.120 --> 00:17:25.280
Lambda functions.

457
00:17:25.280 --> 00:17:27.680
Given that you're talking about changing a single Lambda

458
00:17:27.680 --> 00:17:31.000
function into Step Function with multiple Lambda functions being

459
00:17:31.000 --> 00:17:32.880
orchestrated, do you have to think more

460
00:17:32.880 --> 00:17:36.080
then about observability and how to monitor

461
00:17:36.080 --> 00:17:37.160
when things go wrong?

462
00:17:37.160 --> 00:17:41.200
Yeah, so I think that just by virtue of being a Step Function

463
00:17:41.200 --> 00:17:43.560
is already a little bit more observable,

464
00:17:43.560 --> 00:17:45.040
because if something goes wrong, you

465
00:17:45.040 --> 00:17:46.320
can just open that execution.

466
00:17:46.320 --> 00:17:48.880
It's very easy to see where things are failing

467
00:17:48.880 --> 00:17:50.920
and what is the error.

468
00:17:50.920 --> 00:17:52.760
If I look at the code, at the time,

469
00:17:52.760 --> 00:17:56.200
I used this debug module from Node.js,

470
00:17:56.200 --> 00:18:00.280
which allows you to create effectively logs,

471
00:18:00.280 --> 00:18:01.960
and then you can select a log level,

472
00:18:01.960 --> 00:18:03.800
and you can make it more or less verbose,

473
00:18:03.800 --> 00:18:05.400
depending on what you want to see.

474
00:18:05.400 --> 00:18:07.280
So that's something that is already in place.

475
00:18:07.280 --> 00:18:08.320
It's not perfect.

476
00:18:08.320 --> 00:18:10.360
There might be some refinement work there

477
00:18:10.360 --> 00:18:12.960
to make it nicer, maybe using structured logs,

478
00:18:12.960 --> 00:18:14.960
just to make it easier to send it to CloudWatch

479
00:18:14.960 --> 00:18:17.720
and then use CloudWatch logs to query the logs.

480
00:18:17.720 --> 00:18:19.920
But I think overall, it's a good starting point.

481
00:18:19.920 --> 00:18:21.360
We can improve it.

482
00:18:21.360 --> 00:18:23.240
Other things could be create custom alarms.

483
00:18:23.240 --> 00:18:24.560
Like right now, there is no alarm.

484
00:18:24.560 --> 00:18:26.720
I think I just get worried if it's Friday evening

485
00:18:26.720 --> 00:18:28.240
and I didn't get the preview email,

486
00:18:28.240 --> 00:18:30.600
and I have to go in and check out, OK, why did it fail?

487
00:18:30.600 --> 00:18:32.200
It would be nice to just have an alarm

488
00:18:32.200 --> 00:18:34.680
if the Step Function fails that sends me an email anyway,

489
00:18:34.680 --> 00:18:36.800
saying, you're not getting it because it failed

490
00:18:36.800 --> 00:18:38.400
and it failed for this reason.

491
00:18:38.400 --> 00:18:41.400
So definitely, there is some room for improvement there.

492
00:18:41.400 --> 00:18:43.800
And one tool that we have been talking about

493
00:18:43.800 --> 00:18:45.720
that we built at fourTheorem is SLIC Watch.

494
00:18:45.720 --> 00:18:47.160
So it will be very easy because I'm

495
00:18:47.160 --> 00:18:49.120
using SAM to integrate SLIC Watch

496
00:18:49.120 --> 00:18:51.880
and get some of that done automatically

497
00:18:51.880 --> 00:18:53.200
for me at the stack level.

498
00:18:53.200 --> 00:18:53.760
That's true.

499
00:18:53.760 --> 00:18:55.760
If you've got a SNS topic, you can just

500
00:18:55.760 --> 00:18:59.000
get alerts for any failing Step Functions or Lambda functions,

501
00:18:59.000 --> 00:19:00.720
APIs, anything else.

502
00:19:00.720 --> 00:19:02.960
This sounds like it's really going in a nice direction,

503
00:19:02.960 --> 00:19:05.120
and it's quite a professional approach you're taking,

504
00:19:05.120 --> 00:19:07.080
given that it's kind of a side project.

505
00:19:07.080 --> 00:19:09.160
But since you want to run it once a week,

506
00:19:09.160 --> 00:19:10.960
it's a fairly controlled environment,

507
00:19:10.960 --> 00:19:12.600
and you're in control of it.

508
00:19:12.600 --> 00:19:14.600
So does it really all matter that much

509
00:19:14.600 --> 00:19:16.280
to take this migration approach?

510
00:19:16.280 --> 00:19:19.120
Is it just an interesting exercise for you?

511
00:19:19.120 --> 00:19:20.840
Or is there some higher level lesson

512
00:19:20.840 --> 00:19:23.800
that we can extrapolate from this for more serious production

513
00:19:23.800 --> 00:19:25.920
workloads, where there might be users relying

514
00:19:25.920 --> 00:19:28.000
on the feature 24-7?

515
00:19:28.000 --> 00:19:28.840
Indeed, you're right.

516
00:19:28.840 --> 00:19:31.520
I mean, I could definitely afford to let this fail,

517
00:19:31.520 --> 00:19:33.320
and I have a weekend to fix it.

518
00:19:33.320 --> 00:19:35.880
And even if it doesn't, I don't fix it,

519
00:19:35.880 --> 00:19:37.200
the worst that happens is that I'm not

520
00:19:37.200 --> 00:19:38.920
going to be publishing a newsletter for a week, which

521
00:19:38.920 --> 00:19:40.760
is not the end of the world.

522
00:19:40.760 --> 00:19:43.680
So I'm probably over-engineering this thing a little bit

523
00:19:43.680 --> 00:19:45.120
as an interesting exercise.

524
00:19:45.120 --> 00:19:46.760
But I think that there are lessons there

525
00:19:46.760 --> 00:19:50.120
that we can extrapolate for more serious production

526
00:19:50.120 --> 00:19:51.760
type of workflows.

527
00:19:51.760 --> 00:19:54.800
And one lesson I think is that I've rarely

528
00:19:54.800 --> 00:19:57.520
seen in my career Big Bang migration succeed.

529
00:19:57.520 --> 00:20:00.920
I think you end up spending way too much time, budget,

530
00:20:00.920 --> 00:20:03.120
energies into Big Bang migrations.

531
00:20:03.120 --> 00:20:05.040
And very often what happens is that when

532
00:20:05.040 --> 00:20:06.360
you are very close to completion,

533
00:20:06.360 --> 00:20:08.280
somebody is just going to cancel the project,

534
00:20:08.280 --> 00:20:10.040
because it has been years in the making,

535
00:20:10.040 --> 00:20:12.200
and nobody has seen value so far.

536
00:20:12.200 --> 00:20:14.720
So yeah, that's always the way they go.

537
00:20:14.720 --> 00:20:16.880
So try not to make another Big Bang migration.

538
00:20:16.880 --> 00:20:19.040
I think in itself is a good exercise.

539
00:20:19.040 --> 00:20:21.400
And I think I can use that practice a little bit more just

540
00:20:21.400 --> 00:20:25.320
to force myself to think into, OK, even if it seems longer,

541
00:20:25.320 --> 00:20:27.320
because you are doing small incremental steps,

542
00:20:27.320 --> 00:20:29.920
and sometimes you have to work around things a little bit just

543
00:20:29.920 --> 00:20:32.040
to make it incremental, it's still functional.

544
00:20:32.040 --> 00:20:35.000
But you get to see value every single time you do a change.

545
00:20:35.000 --> 00:20:37.920
I think it's something that I need to push myself to think

546
00:20:37.920 --> 00:20:39.440
into those terms a little bit more.

547
00:20:39.440 --> 00:20:42.040
So in that sense, the exercise is good.

548
00:20:42.040 --> 00:20:44.120
And in general, it's a lesson for every migration.

549
00:20:44.120 --> 00:20:46.000
Try to think that way whenever possible,

550
00:20:46.000 --> 00:20:48.440
even if it seems you're doing more work,

551
00:20:48.440 --> 00:20:50.040
but you are doing work incrementally,

552
00:20:50.040 --> 00:20:53.240
and every single change gives you value immediately.

553
00:20:53.240 --> 00:20:56.440
Then the other thing is that moving to Step Function

554
00:20:56.440 --> 00:20:59.360
has a bunch of advantages that we described.

555
00:20:59.360 --> 00:21:04.000
So I think by doing that, I will be having something

556
00:21:04.000 --> 00:21:07.520
that it is more observable by default, as we said.

557
00:21:07.520 --> 00:21:10.840
And it is something that long term I can maintain more easily.

558
00:21:10.840 --> 00:21:12.920
And another idea there is that if I

559
00:21:12.920 --> 00:21:15.440
manage to split everything out into the wrong functions,

560
00:21:15.440 --> 00:21:17.560
then if something changes, for instance, as you said,

561
00:21:17.560 --> 00:21:19.600
I want maybe to swap master for something else,

562
00:21:19.600 --> 00:21:22.440
or maybe I want to start to include multiple sources,

563
00:21:22.440 --> 00:21:24.760
it should be easier to do it with a Step Function where

564
00:21:24.760 --> 00:21:27.880
you can just create more steps or change very specific steps

565
00:21:27.880 --> 00:21:30.440
rather than thinking, OK, there is a massive monolithic code

566
00:21:30.440 --> 00:21:30.920
base.

567
00:21:30.920 --> 00:21:32.000
Where do I do the changes?

568
00:21:32.000 --> 00:21:33.360
How do I change the tests?

569
00:21:33.360 --> 00:21:35.040
How do I test everything again?

570
00:21:35.040 --> 00:21:37.080
While if you can do all these things in isolation

571
00:21:37.080 --> 00:21:39.880
and then just compose them, it should be a little bit easier.

572
00:21:39.880 --> 00:21:41.400
And another idea there which could

573
00:21:41.400 --> 00:21:43.160
be relevant in production environment

574
00:21:43.160 --> 00:21:45.120
is let's just imagine that at some point

575
00:21:45.120 --> 00:21:47.040
you realize that you have a bottleneck,

576
00:21:47.040 --> 00:21:49.440
and you have a Lambda that takes forever because you're doing

577
00:21:49.440 --> 00:21:51.480
maybe something very confusing, dense,

578
00:21:51.480 --> 00:21:53.840
you could decide to swap the Lambda for something else,

579
00:21:53.840 --> 00:21:55.720
or you could rewrite it in another language.

580
00:21:55.720 --> 00:21:57.400
I think that that composability gives you

581
00:21:57.400 --> 00:21:58.800
a lot of opportunities for change

582
00:21:58.800 --> 00:22:01.400
where optimizations opportunities arise.

583
00:22:01.400 --> 00:22:03.640
So maybe you want to rewrite something you've asked for fun

584
00:22:03.640 --> 00:22:06.280
or for performance, you can rewrite one Lambda at a time,

585
00:22:06.280 --> 00:22:09.400
for instance, or maybe just very specific Lambdas.

586
00:22:09.400 --> 00:22:12.240
I like the way you're taking the one bite at a time approach

587
00:22:12.240 --> 00:22:13.320
to eating this elephant.

588
00:22:13.320 --> 00:22:15.480
And I think it's going to be fascinating to watch

589
00:22:15.480 --> 00:22:18.560
the rest of the live streams and see where this ends up.

590
00:22:20.880 --> 00:22:22.800
Yeah, and on that note, I want to mention that we will have some links in the show notes

591
00:22:22.800 --> 00:22:24.280
because all the code is open source,

592
00:22:24.280 --> 00:22:25.840
has been open source since day one.

593
00:22:25.840 --> 00:22:28.000
So if you're curious, you can see all the evolution

594
00:22:28.000 --> 00:22:29.360
by just looking at the history.

595
00:22:29.360 --> 00:22:32.920
And we'll have the link of the repository on the show notes.

596
00:22:32.920 --> 00:22:34.640
I'm doing the live streams on Twitch,

597
00:22:34.640 --> 00:22:36.920
so you can check out my Twitch profile.

598
00:22:36.920 --> 00:22:38.360
If you're interested, generally it's

599
00:22:38.360 --> 00:22:42.000
every Monday afternoon in Irish time zone.

600
00:22:42.000 --> 00:22:44.280
And there is also a playlist on YouTube

601
00:22:44.280 --> 00:22:45.440
with the previous recording.

602
00:22:45.440 --> 00:22:47.120
So if you want to check out the previous episodes,

603
00:22:47.120 --> 00:22:50.480
just see the incremental changes, you can do that there.

604
00:22:50.480 --> 00:22:52.200
So on that note, I think we've reached

605
00:22:52.200 --> 00:22:53.320
the end of this episode.

606
00:22:53.320 --> 00:22:55.040
I hope that this migration story is going

607
00:22:55.040 --> 00:22:56.120
to be interesting for you.

608
00:22:56.120 --> 00:22:57.560
If you have done something similar,

609
00:22:57.560 --> 00:22:59.760
be curious to know what did you do.

610
00:22:59.760 --> 00:23:03.040
Maybe you took a different path using different services

611
00:23:03.040 --> 00:23:04.600
or maybe a different architecture.

612
00:23:04.600 --> 00:23:06.440
So definitely share your experience with us

613
00:23:06.440 --> 00:23:09.120
in the comments or reach out to us online on Twitter

614
00:23:09.120 --> 00:23:12.120
or LinkedIn or master as well.

615
00:23:12.120 --> 00:23:13.400
All right, thank you very much.

616
00:23:13.400 --> 00:23:14.880
We'll see you in the next episode.
