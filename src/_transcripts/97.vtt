WEBVTT

1
00:00:00.000 --> 00:00:02.640
One of the things that's very common for web applications running in the cloud

2
00:00:02.640 --> 00:00:04.960
is that you will need to handle configuration.

3
00:00:04.960 --> 00:00:07.200
You're probably running your application in different environments,

4
00:00:07.200 --> 00:00:08.960
dev, staging, production, etc.

5
00:00:08.960 --> 00:00:11.000
And most likely you'll need to provide simple things

6
00:00:11.000 --> 00:00:12.880
like database connection details,

7
00:00:12.880 --> 00:00:16.160
various secrets for things like API keys, session storage,

8
00:00:16.160 --> 00:00:19.800
or simply referencing different S3 buckets or DynamoDB tables.

9
00:00:19.800 --> 00:00:23.240
Most likely these values will be different for every environment.

10
00:00:23.240 --> 00:00:25.560
In this episode, we'll discuss which AWS services

11
00:00:25.560 --> 00:00:28.480
you can leverage to store configuration for your web apps.

12
00:00:28.480 --> 00:00:32.160
We will discuss simple strategies such as just using environment variables

13
00:00:32.160 --> 00:00:35.880
or services such as SSM, Secrets Managerr, App Config,

14
00:00:35.880 --> 00:00:38.840
and even how you can even roll your own configuration storage.

15
00:00:38.840 --> 00:00:41.080
We'll discuss the pros and cons of every approach.

16
00:00:41.080 --> 00:00:43.040
And if you stick till the end of the episode,

17
00:00:43.040 --> 00:00:45.720
we'll also give you our recommendation on what's the best strategy

18
00:00:45.720 --> 00:00:47.840
for different kinds of applications.

19
00:00:47.840 --> 00:00:48.680
My name is Eoin.

20
00:00:48.680 --> 00:01:00.040
I'm joined by Luciano for another episode of the AWS Bites podcast.

21
00:01:00.040 --> 00:01:02.840
fourTheorem is the company that makes AWS Bites possible.

22
00:01:02.840 --> 00:01:05.920
If you're looking for a partner to accompany you on your cloud journey,

23
00:01:05.920 --> 00:01:08.200
check them out at fourtherem.com.

24
00:01:08.200 --> 00:01:09.880
Now Luciano, before we start, as usual,

25
00:01:09.880 --> 00:01:12.680
we should probably begin by clarifying the use case a little bit more.

26
00:01:12.680 --> 00:01:15.960
Almost every application needs some degree of configuration.

27
00:01:15.960 --> 00:01:19.200
As we mentioned in the intro, what is really configuration?

28
00:01:19.200 --> 00:01:22.760
It's generally something environment specific that your software needs

29
00:01:22.760 --> 00:01:26.880
as an input to be able to perform whatever task it needs to perform.

30
00:01:26.880 --> 00:01:30.360
And just to give you some examples that can be different kinds of configuration,

31
00:01:30.360 --> 00:01:33.440
maybe your application needs to call a specific third party API.

32
00:01:33.440 --> 00:01:38.120
So you need to have an API key for that that is injected somehow at runtime.

33
00:01:38.120 --> 00:01:42.280
It can be database credentials if you need your application to connect to a database,

34
00:01:42.280 --> 00:01:45.240
or maybe you need your application to do some kind of client side

35
00:01:45.240 --> 00:01:48.200
TLS under shake, so you need to have client TLS certificates.

36
00:01:48.200 --> 00:01:51.600
So you need to have a way to also provide those as parameters.

37
00:01:51.600 --> 00:01:54.200
Or in AWS, it's very common that you build, I don't know,

38
00:01:54.200 --> 00:01:56.840
a Lambda or a container running on Fargate,

39
00:01:56.840 --> 00:02:00.760
and they often need to use other services like S3 or DynamoDB.

40
00:02:00.760 --> 00:02:03.800
So you might create everything together in a stack,

41
00:02:03.800 --> 00:02:05.880
and then you need to have a way to tell the application,

42
00:02:05.880 --> 00:02:10.440
OK, which DynamoDB table do you need to use or which S3 bucket do you need to use,

43
00:02:10.440 --> 00:02:12.760
and somehow be able to provide that reference.

44
00:02:12.760 --> 00:02:16.520
But it can be also something more like application configuration level,

45
00:02:16.520 --> 00:02:18.840
like what kind of logging level do you want?

46
00:02:18.840 --> 00:02:20.960
You might want to provide that as a parameter

47
00:02:20.960 --> 00:02:24.120
because maybe in a development environment you want to be very, very verbose.

48
00:02:24.120 --> 00:02:26.400
But in production, you don't need to be as verbose

49
00:02:26.400 --> 00:02:30.920
because otherwise you might collect too many logs that you don't really need all the time.

50
00:02:30.920 --> 00:02:33.240
And other more functional parameters could be, I don't know,

51
00:02:33.240 --> 00:02:37.000
timeouts when doing HTTP requests or different kinds of connection.

52
00:02:37.000 --> 00:02:39.840
Or if you really buy into this mental model,

53
00:02:39.840 --> 00:02:44.120
you can start to do things like feature flags to enable or disable specific features

54
00:02:44.120 --> 00:02:47.960
or maintain allow list or deny list to expose certain capabilities

55
00:02:47.960 --> 00:02:52.280
only to specific users or customers that maybe have different tiers.

56
00:02:52.280 --> 00:02:54.880
So really, there is no limit to imagination.

57
00:02:54.880 --> 00:02:59.120
You can use different kinds of parameters for all sorts of different things.

58
00:02:59.120 --> 00:03:03.000
So traditionally, configuration was stored mostly in code.

59
00:03:03.000 --> 00:03:07.360
So you would have one configuration file that will contain all this information,

60
00:03:07.360 --> 00:03:11.640
maybe multiple configuration files, one for a different environment.

61
00:03:11.640 --> 00:03:15.520
And this is a simple and effective practice, but it comes with a problem.

62
00:03:15.520 --> 00:03:20.000
And the problem is that you are effectively maintaining all your configuration as code.

63
00:03:20.000 --> 00:03:23.400
And therefore, every time you need to change even one single configuration value,

64
00:03:23.400 --> 00:03:25.680
that means you need to go through a code change

65
00:03:25.680 --> 00:03:29.160
and through the full lifecycle of deploying that code change.

66
00:03:29.160 --> 00:03:31.480
And this is still not necessarily too bad,

67
00:03:31.480 --> 00:03:33.680
but it becomes really bad when you need to store secrets

68
00:03:33.680 --> 00:03:39.920
because maintaining secrets in plain text in your Git or whatever other source control tool you use

69
00:03:39.920 --> 00:03:42.440
is not always easy to do securely.

70
00:03:42.440 --> 00:03:46.320
Most likely you are going to end up disclosing stuff that should be sensitive

71
00:03:46.320 --> 00:03:48.040
and should be managed more properly.

72
00:03:48.040 --> 00:03:51.240
So definitely, there needs to be a better way to manage configuration.

73
00:03:51.240 --> 00:03:53.040
And today, this is what we want to talk about.

74
00:03:53.040 --> 00:03:55.560
So what would be the first option Eoin?

75
00:03:55.560 --> 00:03:58.520
Well, there's an old document at this stage called the 12-Factor App,

76
00:03:58.520 --> 00:04:00.840
which is very popular, I think, still.

77
00:04:00.840 --> 00:04:05.520
And it's all about best practices for designing running applications.

78
00:04:05.520 --> 00:04:07.560
One of the things in there is that they say

79
00:04:07.560 --> 00:04:10.600
you should store your configuration as environment variables.

80
00:04:10.600 --> 00:04:12.480
So maybe we can talk about that one first.

81
00:04:12.480 --> 00:04:14.400
So what are environment variables?

82
00:04:14.400 --> 00:04:15.440
Probably have used them.

83
00:04:15.440 --> 00:04:21.280
But when you start a process on any system, Windows, Linux, any Unix system,

84
00:04:21.280 --> 00:04:24.000
you're provided with access to a set of key value pairs

85
00:04:24.000 --> 00:04:26.520
that are in the environment of the running process.

86
00:04:26.520 --> 00:04:30.560
So you might have seen AWS credentials, for example, like AWS_REGION,

87
00:04:30.560 --> 00:04:34.400
AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, standard Unix ones,

88
00:04:34.400 --> 00:04:38.480
like PATH, USER, PWD for the current directory, hostname, etc.

89
00:04:38.480 --> 00:04:41.600
And then different runtimes have their own ones as well.

90
00:04:41.600 --> 00:04:44.280
Like in Java, you'll have CLASS_PATH and JAVA_HOME.

91
00:04:44.280 --> 00:04:45.920
In Python, you'll have PYTHONPATH.

92
00:04:45.920 --> 00:04:48.480
In AWS, you can use environment variables with Lambda,

93
00:04:48.480 --> 00:04:50.920
with Fargate, EC2, any process really.

94
00:04:50.920 --> 00:04:54.520
AWS generally provide mechanisms for you to configure the environment variables

95
00:04:54.520 --> 00:04:57.760
when you deploy runtime.

96
00:04:57.760 --> 00:04:59.640
Now, it's convenient with infrastructure as code as well

97
00:04:59.640 --> 00:05:01.280
when you're creating resources in the same stack,

98
00:05:01.280 --> 00:05:04.120
you can define them in your infrastructure as code,

99
00:05:04.120 --> 00:05:05.680
so you can reference them when you need.

100
00:05:05.680 --> 00:05:08.480
So it's quite typical that you'd have an environment variable

101
00:05:08.480 --> 00:05:09.640
to point to an S3 bucket,

102
00:05:09.640 --> 00:05:12.280
so the process will know which bucket to write to and read from,

103
00:05:12.280 --> 00:05:15.080
or an SQS queue or a DynamoDB table.

104
00:05:15.080 --> 00:05:17.440
This allows you to use auto-generated names,

105
00:05:17.440 --> 00:05:20.280
names that are generated by your infrastructure as code,

106
00:05:20.280 --> 00:05:23.520
and your infrastructure as code tools will then track dependencies

107
00:05:23.520 --> 00:05:27.760
and make sure to create all the necessary resources before the compute one,

108
00:05:27.760 --> 00:05:30.200
so that you have the right environment variables.

109
00:05:30.200 --> 00:05:31.400
So what are the pros and cons then?

110
00:05:31.400 --> 00:05:34.320
Well, they're very simple to use and often very effective.

111
00:05:34.320 --> 00:05:35.280
They're free, right?

112
00:05:35.280 --> 00:05:38.240
They're a built-in concept for most operating systems,

113
00:05:38.240 --> 00:05:40.800
so you don't need to buy into a particular service and pay for it.

114
00:05:40.800 --> 00:05:43.520
On the other hand, they're not great for secrets, right?

115
00:05:43.520 --> 00:05:45.560
So environment variables are clear text.

116
00:05:45.560 --> 00:05:48.720
You can obviously put an encrypted version in your environment variables,

117
00:05:48.720 --> 00:05:51.360
but then you need to have a key somewhere.

118
00:05:51.360 --> 00:05:53.680
You can generally see these values from the web console

119
00:05:53.680 --> 00:05:55.720
or querying resources from the CLI.

120
00:05:55.720 --> 00:06:00.520
It's also risky in that environment variables may be logged to a log file,

121
00:06:00.520 --> 00:06:03.600
or anyone with access to the host can inspect the process

122
00:06:03.600 --> 00:06:05.240
and find out what the environment variables are.

123
00:06:05.240 --> 00:06:08.800
So in general, it's not a good practice to use environment variables for secrets.

124
00:06:08.800 --> 00:06:11.120
They can also only be strings, which can be a bit tricky

125
00:06:11.120 --> 00:06:13.880
if your configuration is complex with some sort of structure.

126
00:06:13.880 --> 00:06:17.680
Different runtimes will provide their own interminable environment variables as well,

127
00:06:17.680 --> 00:06:20.520
so there might be a risk of collision if you're not careful with naming.

128
00:06:20.520 --> 00:06:24.040
Even though this 12-factor app, which I mentioned at the start of this bit,

129
00:06:24.040 --> 00:06:25.920
is recommending environment variables,

130
00:06:25.920 --> 00:06:29.920
I find that to be a little bit dated and also not very effective for secrets.

131
00:06:29.920 --> 00:06:32.920
And I think we've moved on a little bit and we've got a lot more options now.

132
00:06:32.920 --> 00:06:37.000
So in AWS, we've got a few different options for storing configuration.

133
00:06:37.000 --> 00:06:39.120
All with our pros and cons, so let's get started on those.

134
00:06:39.120 --> 00:06:40.080
What's the first one?

135
00:06:40.080 --> 00:06:43.320
The first one that comes to mind is Systems Manager Parameter Store,

136
00:06:43.320 --> 00:06:45.800
or SSM parameters for short.

137
00:06:45.800 --> 00:06:49.840
And it's a managed service that it's a little bit like a key value pair storage,

138
00:06:49.840 --> 00:06:53.200
where basically you can store as many parameters as you want

139
00:06:53.200 --> 00:06:55.440
and it gives you a very simple mental model.

140
00:06:55.440 --> 00:06:59.480
You can store one parameter at a time, you decide the key, you decide the value,

141
00:06:59.480 --> 00:07:00.640
and that's pretty much it.

142
00:07:00.640 --> 00:07:03.880
It's up to you to organize the keys in a manageable way,

143
00:07:03.880 --> 00:07:06.560
maybe by application, maybe by environment.

144
00:07:06.560 --> 00:07:09.560
Maybe you find some kind of convention where you say,

145
00:07:09.560 --> 00:07:13.960
OK, I'm going to try to stick to a tree of different things

146
00:07:13.960 --> 00:07:18.120
where I always start with slash an environment, slash an application name,

147
00:07:18.120 --> 00:07:21.880
slash maybe database, slash maybe different parameters

148
00:07:21.880 --> 00:07:23.560
that are relevant to your database.

149
00:07:23.560 --> 00:07:26.400
So you can build a structure that way, but it's totally up to you

150
00:07:26.400 --> 00:07:31.600
to define that convention and actually implement it correctly and consistently.

151
00:07:31.600 --> 00:07:34.760
It can give you values in different formats,

152
00:07:34.760 --> 00:07:38.400
so you can store strings, of course, but you can also store strings lists.

153
00:07:38.400 --> 00:07:42.400
So if you have an array, that could be a more ideal way of doing that.

154
00:07:42.400 --> 00:07:46.040
And if you do that, there are certain conventions that you can use

155
00:07:46.040 --> 00:07:49.400
when you do infrastructure as code with CloudFormations or with SAM

156
00:07:49.400 --> 00:07:53.600
so that you can easily iterate through all the values in an array list.

157
00:07:53.600 --> 00:07:57.200
And you can also store secure strings, which are encrypted values,

158
00:07:57.200 --> 00:08:01.520
which give you some degree of extra security and control

159
00:08:01.520 --> 00:08:03.400
in case you are storing sensitive information,

160
00:08:03.400 --> 00:08:06.400
because that value is not going to be visible in clear text

161
00:08:06.400 --> 00:08:10.400
unless you have access to the key that allows you to decrypt that clear text.

162
00:08:10.400 --> 00:08:13.880
And also, that gives you a bunch of tools and automation

163
00:08:13.880 --> 00:08:15.800
that can make integration more seamless,

164
00:08:15.800 --> 00:08:19.000
so you don't really need to manually encrypt and decrypt that information.

165
00:08:19.000 --> 00:08:21.800
One of the downsides is that there is no validation built in.

166
00:08:21.800 --> 00:08:24.120
So again, this is something else that is up to you to make sure

167
00:08:24.120 --> 00:08:28.360
that every time you insert the values for the first time or change them over time,

168
00:08:28.360 --> 00:08:31.880
you are actually doing that, respecting whatever is the correct format

169
00:08:31.880 --> 00:08:35.360
for that particular key value pair.

170
00:08:35.360 --> 00:08:38.200
On the good side, you also get an audit trail of changes.

171
00:08:38.200 --> 00:08:42.080
So every time you change something, you can see that the value is changing

172
00:08:42.080 --> 00:08:45.160
and you can keep track of values being changed,

173
00:08:45.160 --> 00:08:46.680
which is something that can be very important,

174
00:08:46.680 --> 00:08:49.800
especially again when dealing with security sensitive information,

175
00:08:49.800 --> 00:08:51.880
like maybe you are changing an API key,

176
00:08:51.880 --> 00:08:55.280
it's important to know that that API key is changing.

177
00:08:55.280 --> 00:08:58.040
In terms of service, it comes in two tiers.

178
00:08:58.040 --> 00:09:01.400
The first one is called standard tier, and we also have advanced tier,

179
00:09:01.400 --> 00:09:04.800
and you just get slightly different features and different pricing.

180
00:09:04.800 --> 00:09:11.400
The standard tier is free and allows you to store a maximum of 4 kilobytes in size.

181
00:09:11.400 --> 00:09:14.000
So I think that's generally more than enough,

182
00:09:14.000 --> 00:09:16.720
but if you really need to store more information in a key,

183
00:09:16.720 --> 00:09:18.040
you need to use the advanced tier,

184
00:09:18.040 --> 00:09:23.280
which can go as high as 8 kilobytes per key value pair.

185
00:09:23.280 --> 00:09:26.000
The advanced tier is also more interesting because you can use policies,

186
00:09:26.000 --> 00:09:28.400
so you can add additional rules.

187
00:09:28.400 --> 00:09:31.280
For instance, you can say this particular parameter is going to expire

188
00:09:31.280 --> 00:09:35.040
after a certain amount of days or months, whatever,

189
00:09:35.040 --> 00:09:36.480
but it comes with an extra cost

190
00:09:36.480 --> 00:09:38.560
because when you switch to the advanced tier,

191
00:09:38.560 --> 00:09:42.040
you have to pay $0.00 per parameter,

192
00:09:42.040 --> 00:09:44.400
so $0.05 per parameter.

193
00:09:44.400 --> 00:09:48.120
And there is also an interesting caveat that is that you can,

194
00:09:48.120 --> 00:09:50.040
if you switch to the advanced tier,

195
00:09:50.040 --> 00:09:52.840
you can easily upgrade basically from the standard to the advanced,

196
00:09:52.840 --> 00:09:54.280
but you cannot go back.

197
00:09:54.280 --> 00:09:56.760
So of course, when you decide to buy into the advanced tier,

198
00:09:56.760 --> 00:09:59.760
you need to consider it's not as easy to go back again.

199
00:09:59.760 --> 00:10:01.160
And if you think about that, it makes sense

200
00:10:01.160 --> 00:10:04.680
because you might start to store an 8 kilobyte value.

201
00:10:04.680 --> 00:10:06.760
So how would you transition back at that point?

202
00:10:06.760 --> 00:10:08.520
You will lose some information.

203
00:10:08.520 --> 00:10:10.760
So AWS doesn't really give you a way to do that

204
00:10:10.760 --> 00:10:13.440
as a, I guess, a preventative mechanism

205
00:10:13.440 --> 00:10:16.680
to avoid you losing data in your parameters.

206
00:10:16.680 --> 00:10:17.840
Now, how do you use it?

207
00:10:17.840 --> 00:10:19.280
Is it, it is actually really easy.

208
00:10:19.280 --> 00:10:22.880
Like you can do an API called get parameter

209
00:10:22.880 --> 00:10:25.520
where you provide the key for the specific value

210
00:10:25.520 --> 00:10:28.400
you want to read and you get back the value.

211
00:10:28.400 --> 00:10:30.960
And of course, you can do that from the CLI,

212
00:10:30.960 --> 00:10:34.120
you can do that from the different SDKs,

213
00:10:34.120 --> 00:10:37.720
or you can even see the values from the web console.

214
00:10:37.720 --> 00:10:39.440
You need to have the right permissions.

215
00:10:39.440 --> 00:10:40.720
This is actually a really good thing.

216
00:10:40.720 --> 00:10:43.360
That you can define fine grained permissions with IAM

217
00:10:43.360 --> 00:10:45.840
to effectively say which principles can have access

218
00:10:45.840 --> 00:10:47.080
to which keys.

219
00:10:47.080 --> 00:10:48.600
And if you have created that structure,

220
00:10:48.600 --> 00:10:50.800
there's like a tree using prefixes,

221
00:10:50.800 --> 00:10:52.760
you can use the asterisk just to say, okay,

222
00:10:52.760 --> 00:10:55.280
I'm going to give you access to this specific sub-tree

223
00:10:55.280 --> 00:10:56.160
of configuration.

224
00:10:56.160 --> 00:10:58.440
So maybe just by environment and application

225
00:10:58.440 --> 00:11:01.240
and not every single parameter in your account.

226
00:11:03.720 --> 00:11:07.000
There is also, if you're using it with Lambda,

227
00:11:07.000 --> 00:11:09.440
it is a bit of extra code that you need to write

228
00:11:09.440 --> 00:11:10.280
at bootstrap time.

229
00:11:10.280 --> 00:11:12.520
So when the Lambda is doing the first call start,

230
00:11:12.520 --> 00:11:14.680
you probably want to fetch some of this parameter

231
00:11:14.680 --> 00:11:16.440
and you need also to have some piece of logic,

232
00:11:16.440 --> 00:11:18.940
maybe to try to refresh them every once in a while.

233
00:11:18.940 --> 00:11:21.440
So it might be a bit complex to do it in a Lambda

234
00:11:21.440 --> 00:11:23.160
because the Lambda is generally more focused

235
00:11:23.160 --> 00:11:24.000
on the business logic.

236
00:11:24.000 --> 00:11:25.400
You don't want to pollute it too much

237
00:11:25.400 --> 00:11:27.120
with all this extra management code

238
00:11:27.120 --> 00:11:28.820
just to fetch configuration.

239
00:11:28.820 --> 00:11:31.600
So one idea there is if you don't want to do all of that

240
00:11:31.600 --> 00:11:35.000
yourself, you can use an AWS provided Lambda extension,

241
00:11:35.000 --> 00:11:36.200
which once you install it,

242
00:11:36.200 --> 00:11:38.000
is going to do all of this work in the background

243
00:11:38.000 --> 00:11:40.560
and in your Lambda you already have immediate access

244
00:11:40.560 --> 00:11:44.160
to the value coming from SSN parameters.

245
00:11:44.160 --> 00:11:47.040
If you do Node.js and if you're using Middy

246
00:11:47.040 --> 00:11:50.000
as a middleware system for your Lambda,

247
00:11:50.000 --> 00:11:52.700
there is actually a middleware that you can just enable

248
00:11:52.700 --> 00:11:55.660
and it does exactly the same thing as the extension.

249
00:11:55.660 --> 00:11:57.440
I am of course biased because being involved

250
00:11:57.440 --> 00:11:59.800
in the Middy project, I tend to prefer this option,

251
00:11:59.800 --> 00:12:01.600
but I think it's a little bit easier

252
00:12:01.600 --> 00:12:03.320
because you don't need to install an extra extension,

253
00:12:03.320 --> 00:12:05.120
it's just dependencies in your Lambda.

254
00:12:05.120 --> 00:12:06.720
So if you already have dependencies,

255
00:12:06.720 --> 00:12:08.880
you can easily just do an MPM install

256
00:12:08.880 --> 00:12:10.880
and everything is then packaged together

257
00:12:10.880 --> 00:12:13.600
without needing additional extensions.

258
00:12:13.600 --> 00:12:16.080
If you use Python, there is something similar,

259
00:12:16.080 --> 00:12:19.200
I think by Alex Casalboni, which is called SSM cache

260
00:12:19.200 --> 00:12:21.760
and it's pretty much a library that again you install

261
00:12:21.760 --> 00:12:23.760
and it can do all of this stuff seamlessly for you.

262
00:12:23.760 --> 00:12:25.640
So with very minimal configuration,

263
00:12:25.640 --> 00:12:28.320
it takes care of all the life cycle of fetching

264
00:12:28.320 --> 00:12:29.960
the parameters and making them available

265
00:12:29.960 --> 00:12:31.520
to your Lambda handler.

266
00:12:31.520 --> 00:12:34.880
And there is also something similar in Lambda power tools.

267
00:12:34.880 --> 00:12:37.400
I think there is definitely support for TypeScript.

268
00:12:37.400 --> 00:12:39.000
I imagine there is also for Python,

269
00:12:39.000 --> 00:12:40.700
but worth double checking that.

270
00:12:41.560 --> 00:12:46.120
And then if you're using tools for infrastructure as code,

271
00:12:46.120 --> 00:12:48.520
such as SAM or serverless,

272
00:12:48.520 --> 00:12:51.360
there are often very interesting pieces of syntax

273
00:12:51.360 --> 00:12:54.160
that can facilitate fetching SSM parameters

274
00:12:54.160 --> 00:12:55.400
at different stages.

275
00:12:55.400 --> 00:12:58.840
Of course you can reference SSM parameters at deploy time,

276
00:12:58.840 --> 00:13:00.520
but the more interesting thing is that sometimes

277
00:13:00.520 --> 00:13:02.400
you can also prefetch this parameter

278
00:13:02.400 --> 00:13:03.700
before the deployment time.

279
00:13:03.700 --> 00:13:07.760
So you can effectively interpolate the actual values

280
00:13:07.760 --> 00:13:08.600
into your templates,

281
00:13:08.600 --> 00:13:11.000
which sometimes allows you to do more dynamic things

282
00:13:11.000 --> 00:13:12.800
like, I don't know, conditionals,

283
00:13:12.800 --> 00:13:15.240
where you could say if the value of this SSM parameter

284
00:13:15.240 --> 00:13:18.360
is something that maybe you change the template slightly

285
00:13:18.360 --> 00:13:20.920
to deploy something rather than referencing something

286
00:13:20.920 --> 00:13:22.920
that exists already in another stack.

287
00:13:22.920 --> 00:13:25.160
So it can be actually a very powerful model.

288
00:13:25.160 --> 00:13:27.320
And actually I believe Eoin that you have an article on that

289
00:13:27.320 --> 00:13:29.920
so we'll make sure to link that in the show notes

290
00:13:29.920 --> 00:13:33.320
for people that want to deep dive into this approach.

291
00:13:33.320 --> 00:13:36.680
So in summary, let's try to say what are the pros and cons

292
00:13:36.680 --> 00:13:37.840
of this approach.

293
00:13:37.840 --> 00:13:39.160
I think it's generally a good approach

294
00:13:39.160 --> 00:13:41.320
because it's relatively simple and cheap

295
00:13:41.320 --> 00:13:43.520
and you also get a quite good throughput.

296
00:13:43.520 --> 00:13:46.520
So if you have lots of services, lots of applications,

297
00:13:46.520 --> 00:13:49.000
reading parameters all the time,

298
00:13:49.000 --> 00:13:50.920
you should have still significant throughput

299
00:13:50.920 --> 00:13:52.600
to be able to support all of that.

300
00:13:53.480 --> 00:13:55.640
But of course there are some problems.

301
00:13:55.640 --> 00:13:58.120
It's not great for very structured use cases

302
00:13:58.120 --> 00:14:00.200
because you need to come up with your own structure

303
00:14:00.200 --> 00:14:01.760
and make sure to be consistent.

304
00:14:01.760 --> 00:14:02.960
You don't get any validation.

305
00:14:02.960 --> 00:14:05.720
So you are always at risk that somebody is gonna

306
00:14:05.720 --> 00:14:08.280
mistype something and then the application breaks

307
00:14:08.280 --> 00:14:11.320
because you cannot really parse that information at runtime.

308
00:14:12.820 --> 00:14:16.000
It doesn't deal too well with sensitive data.

309
00:14:16.000 --> 00:14:18.200
You can definitely do encryption

310
00:14:18.200 --> 00:14:20.760
using the secrets value approach,

311
00:14:20.760 --> 00:14:22.420
but it's not very structured again.

312
00:14:22.420 --> 00:14:25.280
So for sensitive data like API keys,

313
00:14:25.280 --> 00:14:27.720
you also don't get a concept of rotation built in.

314
00:14:27.720 --> 00:14:30.920
So it's up to you to create some kind of automation,

315
00:14:30.920 --> 00:14:33.340
maybe a Lambda that runs on a schedule,

316
00:14:33.340 --> 00:14:36.000
just to make sure that you remember to rotate a key

317
00:14:36.000 --> 00:14:38.280
that might expire after a while.

318
00:14:38.280 --> 00:14:40.680
And speaking again of throughput limits,

319
00:14:40.680 --> 00:14:42.440
you have 40 reads per second,

320
00:14:43.480 --> 00:14:45.640
unless you buy into the higher throughput mode,

321
00:14:45.640 --> 00:14:49.240
which is 10,000, I think, reads per second.

322
00:14:50.600 --> 00:14:52.160
But there is an extra cost for that.

323
00:14:52.160 --> 00:14:54.780
So I say that it's good because you generally get throughputs

324
00:14:54.780 --> 00:14:56.480
but if that throughput is not enough,

325
00:14:56.480 --> 00:14:57.680
it comes with extra costs.

326
00:14:57.680 --> 00:14:59.120
So you have options there,

327
00:14:59.120 --> 00:15:01.240
but you need to account for all the features

328
00:15:01.240 --> 00:15:02.600
that you need to build yourself

329
00:15:02.600 --> 00:15:03.980
and all the extra costs that you get

330
00:15:03.980 --> 00:15:07.040
when you need the more advanced features.

331
00:15:07.040 --> 00:15:10.440
So should we talk about the other approach?

332
00:15:10.440 --> 00:15:11.960
Yeah, I think we've got a few other approaches.

333
00:15:11.960 --> 00:15:15.080
And the last one is going to be less familiar to people,

334
00:15:15.080 --> 00:15:18.020
but Secrets Managerr, which I think we'll talk about next,

335
00:15:18.020 --> 00:15:19.680
is probably more familiar.

336
00:15:19.680 --> 00:15:22.920
And this is a specific managed distributed service

337
00:15:22.920 --> 00:15:24.400
dedicated to storing secrets, right?

338
00:15:24.400 --> 00:15:26.640
So this is about passwords, API tokens,

339
00:15:26.640 --> 00:15:28.320
things you want to really protect.

340
00:15:28.320 --> 00:15:30.600
Again, you can create key value pairs,

341
00:15:30.600 --> 00:15:33.280
but unlike parameter store, you've got more options.

342
00:15:33.280 --> 00:15:34.680
You can have structured JSON.

343
00:15:34.680 --> 00:15:38.400
So if you've got hierarchical document oriented values,

344
00:15:38.400 --> 00:15:39.760
that's possible too.

345
00:15:39.760 --> 00:15:42.440
The difference between the secret value in parameter store

346
00:15:42.440 --> 00:15:44.200
and a secret in Secrets Managerr

347
00:15:44.200 --> 00:15:47.220
is that Secrets Managerr would use KMS to do the encryption

348
00:15:47.220 --> 00:15:49.300
rather than that being all hidden from you.

349
00:15:49.300 --> 00:15:52.480
So you need to understand how KMS works a little bit

350
00:15:52.480 --> 00:15:57.120
for the key management and also provide access to the key

351
00:15:57.120 --> 00:15:59.760
as well as to Secrets Managerr for principals

352
00:15:59.760 --> 00:16:02.360
who are trying to retrieve and update secrets.

353
00:16:02.360 --> 00:16:05.000
So to read a secret, you need to use the API,

354
00:16:05.000 --> 00:16:08.220
GetSecretValue with the IAM permission for that.

355
00:16:08.220 --> 00:16:11.120
And you can be very granular then as you would want to be

356
00:16:11.120 --> 00:16:13.080
on which gets access to a secret.

357
00:16:14.240 --> 00:16:17.280
You can keep data versioned also for auditing,

358
00:16:17.280 --> 00:16:18.240
which is important.

359
00:16:19.120 --> 00:16:21.280
You can monitor access to secrets thanks to Cloud Trail,

360
00:16:21.280 --> 00:16:24.200
which is very important for governance and compliance.

361
00:16:24.200 --> 00:16:27.160
And then the really outstanding feature really

362
00:16:27.160 --> 00:16:28.720
for Secrets Managerr, I think is the ability

363
00:16:28.720 --> 00:16:30.960
to automate secret rotation.

364
00:16:30.960 --> 00:16:34.280
So it can rotate secrets automatically on a schedule

365
00:16:34.280 --> 00:16:37.440
for certain types of credentials like access to Redshift,

366
00:16:37.440 --> 00:16:39.800
RDS or DocumentDB.

367
00:16:39.800 --> 00:16:42.680
And if you want to customize the nature of that rotation,

368
00:16:42.680 --> 00:16:44.580
you can use Lambda as well.

369
00:16:44.580 --> 00:16:49.580
So it's more of a complete managed service for secrets.

370
00:16:49.780 --> 00:16:52.560
And one of the advantages also when it comes to things

371
00:16:52.560 --> 00:16:56.160
like databases is that it will integrate into RDS,

372
00:16:56.160 --> 00:16:58.640
DocumentDB and lots of other AWS services

373
00:16:58.640 --> 00:17:00.800
so that you don't have to go through the dance

374
00:17:00.800 --> 00:17:03.800
of retrieving a secret, making sure it's stored secretly

375
00:17:03.800 --> 00:17:06.320
and even in or sensitively in memory

376
00:17:06.320 --> 00:17:08.440
and then passing it onto another service.

377
00:17:08.440 --> 00:17:10.680
AWS will glue those things together for you.

378
00:17:10.680 --> 00:17:13.120
An example of that is you're using CloudFormation

379
00:17:13.120 --> 00:17:14.740
to create an RDS cluster.

380
00:17:14.740 --> 00:17:16.840
You can set the master password to be a secret

381
00:17:16.840 --> 00:17:18.720
that's also created in that template.

382
00:17:18.720 --> 00:17:20.240
You can configure the rotation for it.

383
00:17:20.240 --> 00:17:22.100
You never even have to see that password.

384
00:17:22.100 --> 00:17:24.280
It's all just wired together automatically.

385
00:17:24.280 --> 00:17:25.600
So that's pretty nice.

386
00:17:25.600 --> 00:17:28.960
On the cons, I guess, for Secrets Managerr,

387
00:17:28.960 --> 00:17:30.060
it can be more expensive,

388
00:17:30.060 --> 00:17:33.280
especially compared to the parameter store free tier.

389
00:17:33.280 --> 00:17:36.440
If you heard a few people kind of suggesting skeptically

390
00:17:36.440 --> 00:17:39.800
that AWS are, you know, realize the parameter store

391
00:17:39.800 --> 00:17:41.520
was a little bit too cheap, especially with the free tier.

392
00:17:41.520 --> 00:17:43.680
That's why they invented Secrets Managerr.

393
00:17:43.680 --> 00:17:46.560
But Secrets Managerr allows you, I suppose, more throughput.

394
00:17:46.560 --> 00:17:49.440
Yeah, I think you get 30 days free per secret

395
00:17:49.440 --> 00:17:53.840
and then it gets into a 5 cents for 10,000 API calls.

396
00:17:53.840 --> 00:17:54.680
So with all these things,

397
00:17:54.680 --> 00:17:56.800
you really have to think about your throughput, right?

398
00:17:56.800 --> 00:17:59.840
Parameter store, you've got those throughput limits.

399
00:17:59.840 --> 00:18:00.960
You need to make sure you're caching.

400
00:18:00.960 --> 00:18:02.600
You can't be reading too aggressively.

401
00:18:02.600 --> 00:18:04.560
I've seen lots of teams run into limits

402
00:18:04.560 --> 00:18:06.080
with parameter store.

403
00:18:06.080 --> 00:18:08.320
With Secrets Managerr, it might be just a question of cost.

404
00:18:08.320 --> 00:18:09.520
So you need to think about, okay,

405
00:18:09.520 --> 00:18:11.160
how many processes do I have running?

406
00:18:11.160 --> 00:18:13.160
How often are they reading these values?

407
00:18:13.160 --> 00:18:14.440
And what's that gonna cost me?

408
00:18:14.440 --> 00:18:16.680
And will I stay within the throughput quotas?

409
00:18:16.680 --> 00:18:19.120
So Secrets Managerr has that throughput cost,

410
00:18:19.120 --> 00:18:22.520
but it also has a 50 cent per secret per month cost as well.

411
00:18:22.520 --> 00:18:23.720
So think about that.

412
00:18:23.720 --> 00:18:26.400
And maybe think about some of the alternatives.

413
00:18:26.400 --> 00:18:28.560
So where are we when it comes to alternatives?

414
00:18:28.560 --> 00:18:30.200
I mentioned one that's less familiar for people

415
00:18:30.200 --> 00:18:32.600
and I'm definitely interested to hear about App Config.

416
00:18:32.600 --> 00:18:34.120
Can you walk us through that one Luciano?

417
00:18:35.600 --> 00:18:37.480
Yes, App Config is really interesting because I think it tries to give you

418
00:18:37.480 --> 00:18:39.480
a more structured experience,

419
00:18:39.480 --> 00:18:41.080
trying to fill all the missing gaps

420
00:18:41.080 --> 00:18:43.400
of the other approaches we mentioned before.

421
00:18:43.400 --> 00:18:45.960
So let's try to describe everything in order.

422
00:18:45.960 --> 00:18:49.440
So what it is really is an order managed service from AWS

423
00:18:49.440 --> 00:18:51.560
and it allows you to store configuration.

424
00:18:51.560 --> 00:18:52.920
But this time, rather than thinking

425
00:18:52.920 --> 00:18:54.400
in terms of key value pairs,

426
00:18:54.400 --> 00:18:57.160
it's more you are storing an entire configuration object

427
00:18:57.160 --> 00:19:00.040
that makes sense in a specific context.

428
00:19:00.040 --> 00:19:02.400
And this configuration object is of course replicated

429
00:19:02.400 --> 00:19:05.480
across different ADs, so it's always highly available.

430
00:19:05.480 --> 00:19:08.760
So you don't really have to worry about the storage piece.

431
00:19:08.760 --> 00:19:11.680
It's more, it's there and AWS make sure

432
00:19:11.680 --> 00:19:13.560
that it's always available for you when you need it

433
00:19:13.560 --> 00:19:16.440
to reference in your application or your infrastructure

434
00:19:16.440 --> 00:19:17.280
as code.

435
00:19:17.280 --> 00:19:20.520
And one of the new features compared to the other ones

436
00:19:20.520 --> 00:19:22.920
is that it uses a concept called validators

437
00:19:22.920 --> 00:19:24.600
that is actually something you can configure

438
00:19:24.600 --> 00:19:25.960
very, very granularly.

439
00:19:25.960 --> 00:19:28.320
And you can define exactly what are the rules

440
00:19:28.320 --> 00:19:31.080
that basically say that the values you are inserting

441
00:19:31.080 --> 00:19:33.320
in this configuration object are actually conformed

442
00:19:33.320 --> 00:19:36.160
with what your application is going to look for.

443
00:19:36.160 --> 00:19:37.640
So basically that is gonna save you

444
00:19:37.640 --> 00:19:39.360
from somebody making a typo

445
00:19:39.360 --> 00:19:42.000
because maybe they forgot a quote or a semicolon

446
00:19:42.000 --> 00:19:44.040
or a curly brace, whatever.

447
00:19:44.040 --> 00:19:46.520
And that is something you will see

448
00:19:46.520 --> 00:19:48.400
when you try to change the value.

449
00:19:48.400 --> 00:19:50.640
So when you try to deploy the value itself,

450
00:19:50.640 --> 00:19:52.160
not when your application starts

451
00:19:52.160 --> 00:19:53.520
and then your application is going to crash.

452
00:19:53.520 --> 00:19:55.000
So basically this measure allows you

453
00:19:55.000 --> 00:19:57.640
to prevent accidental crashes of your application

454
00:19:57.640 --> 00:19:59.920
by seeing the issues when you try to change

455
00:19:59.920 --> 00:20:02.120
the configuration rather than when you deploy

456
00:20:02.120 --> 00:20:04.000
the new configuration and the application crashes,

457
00:20:04.000 --> 00:20:05.600
which I think is really, really cool

458
00:20:05.600 --> 00:20:07.840
because it can prevent also downtimes,

459
00:20:07.840 --> 00:20:10.240
accidental downtimes just due to human error.

460
00:20:10.240 --> 00:20:13.960
And in that light of trying to make deployment safer,

461
00:20:13.960 --> 00:20:16.160
there is an entire mechanism that allows you

462
00:20:16.160 --> 00:20:18.880
to roll out deployments of configuration changes

463
00:20:18.880 --> 00:20:19.720
in different ways.

464
00:20:19.720 --> 00:20:21.640
We'll talk a little bit more about that.

465
00:20:21.640 --> 00:20:24.320
But again, the idea is try not just to manage configuration

466
00:20:24.320 --> 00:20:26.040
in a more structured way, but also to make sure

467
00:20:26.040 --> 00:20:28.320
that every time you change that configuration,

468
00:20:28.320 --> 00:20:30.840
deploys are actually managed more carefully

469
00:20:30.840 --> 00:20:33.280
and you try to spot as soon as possible

470
00:20:33.280 --> 00:20:35.760
if that configuration is gonna break your application

471
00:20:35.760 --> 00:20:38.000
and take preventive measures or roll back

472
00:20:38.000 --> 00:20:38.840
as soon as possible.

473
00:20:38.840 --> 00:20:42.440
Again, the service keeps an audit trail

474
00:20:42.440 --> 00:20:43.760
of all the configuration changes.

475
00:20:43.760 --> 00:20:45.240
So this is not necessarily new,

476
00:20:45.240 --> 00:20:47.200
but of course you also have that feature.

477
00:20:47.200 --> 00:20:49.880
So let's try to talk more about what is the experience

478
00:20:49.880 --> 00:20:50.720
of using it.

479
00:20:50.720 --> 00:20:53.160
And I think that will describe a little bit more

480
00:20:53.160 --> 00:20:55.200
all the different concepts and how this tool

481
00:20:55.200 --> 00:20:58.160
is a little bit more feature complete than the other ones.

482
00:20:58.160 --> 00:20:59.000
So when you start,

483
00:20:59.000 --> 00:21:01.280
you need to define an application configuration.

484
00:21:01.280 --> 00:21:03.400
And this is already the first big change

485
00:21:03.400 --> 00:21:05.040
because right now we have been talking

486
00:21:05.040 --> 00:21:06.080
about key value pairs.

487
00:21:06.080 --> 00:21:08.880
So not necessarily tied to one environment

488
00:21:08.880 --> 00:21:09.880
or one application.

489
00:21:09.880 --> 00:21:12.280
AppConf immediately makes you think about,

490
00:21:12.280 --> 00:21:14.960
no, this configuration is not something very generic.

491
00:21:14.960 --> 00:21:17.720
It's not one parameter that exists on its own.

492
00:21:17.720 --> 00:21:19.520
You need to think about an application

493
00:21:19.520 --> 00:21:21.680
and we are defining the entire configuration

494
00:21:21.680 --> 00:21:22.800
for that application.

495
00:21:22.800 --> 00:21:25.400
So you start by defining this concept of a container

496
00:21:25.400 --> 00:21:27.000
that represents your application.

497
00:21:28.920 --> 00:21:33.280
You can integrate that basically

498
00:21:33.280 --> 00:21:36.200
into once you have basically the application stored

499
00:21:36.200 --> 00:21:38.240
into App Config, of course you need to do something

500
00:21:38.240 --> 00:21:39.960
at the application level to make sure

501
00:21:39.960 --> 00:21:41.920
that you can fetch that information.

502
00:21:41.920 --> 00:21:44.840
And this is interesting because it's again a pull mode.

503
00:21:44.840 --> 00:21:47.040
So it's your application that needs to know exactly

504
00:21:47.040 --> 00:21:48.880
when to fetch that information.

505
00:21:48.880 --> 00:21:51.040
And it needs to do that by calling explicit

506
00:21:51.040 --> 00:21:54.160
the get latest configuration command again.

507
00:21:54.160 --> 00:21:55.480
So you can do from the CLI,

508
00:21:55.480 --> 00:21:57.080
so you can do it from the SDK

509
00:21:57.080 --> 00:21:58.600
or with a bunch of other helpers

510
00:21:58.600 --> 00:22:00.000
that we will describe later.

511
00:22:00.000 --> 00:22:03.000
One of these helpers is an extension for AWS Lambda.

512
00:22:03.000 --> 00:22:03.840
If you use Lambda,

513
00:22:03.840 --> 00:22:06.440
so very similar to the one we described for SSM

514
00:22:06.440 --> 00:22:08.840
that can fetch the configuration automatically for you

515
00:22:08.840 --> 00:22:11.120
and can try to refetch it after a while

516
00:22:11.120 --> 00:22:12.680
to make sure it's always kept in sync

517
00:22:12.680 --> 00:22:14.280
with the latest configuration.

518
00:22:15.440 --> 00:22:17.960
If you use Middy, again, there is a middleware for it.

519
00:22:17.960 --> 00:22:20.640
So very similar to the SSM parameters one,

520
00:22:20.640 --> 00:22:23.880
does auto fetching, caching and refreshing for you.

521
00:22:24.880 --> 00:22:26.720
And another thing that you can do

522
00:22:26.720 --> 00:22:30.120
is fetching and refreshing for you.

523
00:22:30.120 --> 00:22:33.040
And I think from a configuration perspective,

524
00:22:33.040 --> 00:22:34.520
there are some interesting concepts

525
00:22:34.520 --> 00:22:37.560
that are worth expanding on a little bit more.

526
00:22:37.560 --> 00:22:39.840
So when you define an application configuration,

527
00:22:39.840 --> 00:22:41.720
you also need to define environments.

528
00:22:41.720 --> 00:22:44.440
So again, the approach is very methodical and structured.

529
00:22:44.440 --> 00:22:45.920
You don't have to invent anything.

530
00:22:45.920 --> 00:22:47.600
You just need to follow the process.

531
00:22:47.600 --> 00:22:49.360
So an environment is something like depth,

532
00:22:49.360 --> 00:22:51.320
staging, production, beta, preview,

533
00:22:51.320 --> 00:22:52.160
whatever you want to call it,

534
00:22:52.160 --> 00:22:53.960
that makes sense for the different stages

535
00:22:53.960 --> 00:22:56.200
of your application life cycle.

536
00:22:56.200 --> 00:22:58.200
So you can pick different configuration profiles.

537
00:22:58.200 --> 00:23:01.360
You can pick between freeform and Fisher-Flack,

538
00:23:01.360 --> 00:23:03.360
and they give you a very different experience

539
00:23:03.360 --> 00:23:06.040
on how to define your entire configuration.

540
00:23:06.040 --> 00:23:08.960
So Fisher-Flack is probably a little bit simpler,

541
00:23:08.960 --> 00:23:11.440
but it's probably more specialized for the cases

542
00:23:11.440 --> 00:23:13.640
where you are actually really thinking about enabling

543
00:23:13.640 --> 00:23:15.720
or disabling specific features

544
00:23:15.720 --> 00:23:18.420
for specific classes of users.

545
00:23:18.420 --> 00:23:20.440
While freeform is a lot more,

546
00:23:20.440 --> 00:23:23.280
you have a big structured configuration file,

547
00:23:23.280 --> 00:23:24.720
I'm going to give you all the tools

548
00:23:24.720 --> 00:23:27.400
that you need to manage that configuration file.

549
00:23:27.400 --> 00:23:28.520
And it's not really a file,

550
00:23:28.520 --> 00:23:30.060
it's just something you are storing in AWS

551
00:23:30.060 --> 00:23:33.000
and you load it when you need that information.

552
00:23:33.000 --> 00:23:36.120
So when you use that freeform configuration profile,

553
00:23:36.120 --> 00:23:38.440
you have a choice of how are you going to define

554
00:23:38.440 --> 00:23:41.040
the object structure, and you can define plain text,

555
00:23:41.040 --> 00:23:44.220
JSON and YAML as the three available option.

556
00:23:44.220 --> 00:23:47.140
I think JSON is of course the most common.

557
00:23:47.140 --> 00:23:50.560
And if you use JSON, you can even use JSON schemas

558
00:23:50.560 --> 00:23:52.120
to create your own validators,

559
00:23:52.120 --> 00:23:53.600
which when you do APIs,

560
00:23:53.600 --> 00:23:55.120
they're probably used to JSON schema.

561
00:23:55.120 --> 00:23:57.360
So it can be very convenient way of defining

562
00:23:57.360 --> 00:24:00.160
all the validation rules for a piece of JSON.

563
00:24:00.160 --> 00:24:01.840
But if you use something else,

564
00:24:01.840 --> 00:24:04.500
like if you want to use plain text and use your own format,

565
00:24:04.500 --> 00:24:06.800
because I don't know, maybe you like TOML, let's say,

566
00:24:06.800 --> 00:24:08.960
which is not really supported out of the box,

567
00:24:08.960 --> 00:24:10.240
then you can even create a Lambda

568
00:24:10.240 --> 00:24:11.740
that can do the custom validation for you.

569
00:24:11.740 --> 00:24:13.920
So it's really an extensible model

570
00:24:13.920 --> 00:24:16.640
where if you really have bespoke use cases,

571
00:24:16.640 --> 00:24:18.560
let's say maybe you are migrating an application

572
00:24:18.560 --> 00:24:21.420
that I don't know, from Java using INE files

573
00:24:21.420 --> 00:24:22.600
for configuration,

574
00:24:22.600 --> 00:24:23.880
you can still use this approach.

575
00:24:23.880 --> 00:24:25.800
You just need to do a little bit of extra work

576
00:24:25.800 --> 00:24:27.560
if you want to have validators,

577
00:24:27.560 --> 00:24:30.520
making sure that everything is configured correctly.

578
00:24:31.600 --> 00:24:33.720
When it comes to deploying a change,

579
00:24:33.720 --> 00:24:34.720
as we mentioned before,

580
00:24:34.720 --> 00:24:36.520
we have different deployment strategies.

581
00:24:36.520 --> 00:24:38.160
And just to give you an example,

582
00:24:38.160 --> 00:24:41.680
you can go for like an immediate rollout where you say,

583
00:24:41.680 --> 00:24:44.360
every fetch that happens after I click okay,

584
00:24:44.360 --> 00:24:46.600
needs to get the latest version of the application,

585
00:24:46.600 --> 00:24:48.080
of the application configuration.

586
00:24:48.080 --> 00:24:50.400
This is of course the simplest rollout model,

587
00:24:50.400 --> 00:24:52.840
where it's like, I'm sure everything is gonna work fine,

588
00:24:52.840 --> 00:24:55.240
and no worry, just push it to everyone.

589
00:24:55.240 --> 00:24:57.220
But if you want to be a little bit more careful,

590
00:24:57.220 --> 00:25:00.320
you can use different strategies for software layouts.

591
00:25:00.320 --> 00:25:01.740
And just to give you an idea,

592
00:25:01.740 --> 00:25:03.600
for instance, you can say, okay,

593
00:25:03.600 --> 00:25:06.720
I want to linearly increase the number of clients

594
00:25:06.720 --> 00:25:08.580
that see the latest configuration.

595
00:25:08.580 --> 00:25:10.500
For instance, you might start with 10%,

596
00:25:10.500 --> 00:25:12.960
then after a minute, an additional 10%

597
00:25:12.960 --> 00:25:14.960
is gonna get the new configuration

598
00:25:14.960 --> 00:25:17.320
until you reach the 100%.

599
00:25:17.320 --> 00:25:19.320
Or you can even define that by time.

600
00:25:19.320 --> 00:25:20.160
So you want to say, okay,

601
00:25:20.160 --> 00:25:21.680
I want to gradually rollout everything

602
00:25:21.680 --> 00:25:23.480
in the next three minutes.

603
00:25:23.480 --> 00:25:25.920
And of course you can monitor the software rollout,

604
00:25:25.920 --> 00:25:27.040
and if something goes wrong,

605
00:25:27.040 --> 00:25:30.160
you can basically define in App Config,

606
00:25:30.160 --> 00:25:33.440
you can tell it to watch for a specific CloudWatch alarm.

607
00:25:33.440 --> 00:25:35.100
If that CloudWatch alarm fires

608
00:25:35.100 --> 00:25:37.080
while you are doing a software rollout,

609
00:25:37.080 --> 00:25:39.160
then it's gonna assume that something went wrong,

610
00:25:39.160 --> 00:25:41.860
and it's gonna roll back to the previous configuration.

611
00:25:41.860 --> 00:25:43.960
So this is actually a very powerful mechanism

612
00:25:43.960 --> 00:25:46.760
that allows you to safely rollout

613
00:25:46.760 --> 00:25:48.960
with the least damage possible,

614
00:25:48.960 --> 00:25:51.020
because you have validation upfront,

615
00:25:51.020 --> 00:25:52.000
you can still break things,

616
00:25:52.000 --> 00:25:54.840
because even if your configuration is syntactically valid,

617
00:25:54.840 --> 00:25:57.080
maybe the content is not correct,

618
00:25:57.080 --> 00:25:58.740
maybe you have the wrong API keys,

619
00:25:58.740 --> 00:26:00.120
so your application, when it starts,

620
00:26:00.120 --> 00:26:01.280
is gonna start to fail,

621
00:26:01.280 --> 00:26:03.740
because it cannot call a third party service.

622
00:26:03.740 --> 00:26:06.280
So you can roll back as soon as possible

623
00:26:06.280 --> 00:26:07.800
while you maybe have impacted

624
00:26:07.800 --> 00:26:09.760
only a small fraction of your users.

625
00:26:09.760 --> 00:26:11.720
And I think this is the most powerful feature,

626
00:26:11.720 --> 00:26:14.280
and if you would have to replicate that yourself,

627
00:26:14.280 --> 00:26:15.640
it is really a lot of work,

628
00:26:15.640 --> 00:26:16.880
and it's hard to get it right.

629
00:26:16.880 --> 00:26:18.160
So this is definitely, I think,

630
00:26:18.160 --> 00:26:20.600
the power feature that you get by using App Config.

631
00:26:21.640 --> 00:26:22.880
One last note that I have

632
00:26:22.880 --> 00:26:24.920
is that it can be integrated with Secret Manager,

633
00:26:24.920 --> 00:26:27.320
so if you are worried about storing secrets,

634
00:26:27.320 --> 00:26:28.640
there is a nice integration there

635
00:26:28.640 --> 00:26:31.060
where you don't really have to manage secrets yourself

636
00:26:31.060 --> 00:26:33.320
in plain text or encrypt them yourself,

637
00:26:33.320 --> 00:26:35.400
because you can rely on Secrets Managerr

638
00:26:35.400 --> 00:26:37.220
doing all of that for you.

639
00:26:37.220 --> 00:26:39.280
And another interesting feature,

640
00:26:39.280 --> 00:26:41.880
which I was not really sure when it could be useful,

641
00:26:41.880 --> 00:26:45.560
but if you want to store the actual content of the object

642
00:26:45.560 --> 00:26:47.800
in things like S3 or SSM parameter,

643
00:26:47.800 --> 00:26:51.000
or even SSM documents, you can even do that.

644
00:26:51.000 --> 00:26:54.120
So the backend doesn't have to be App Config itself,

645
00:26:54.120 --> 00:26:56.480
but you can even rely on using other services

646
00:26:56.480 --> 00:26:57.320
as the backend.

647
00:26:58.800 --> 00:27:00.720
Finally, let's talk about pricing.

648
00:27:00.720 --> 00:27:04.720
It seems very appealing just from the outside.

649
00:27:04.720 --> 00:27:06.220
I haven't used it really at scale,

650
00:27:06.220 --> 00:27:09.540
so I don't know if there is any hidden surprise with pricing,

651
00:27:09.540 --> 00:27:14.200
but basically it's a usual pay-as-you-use model,

652
00:27:14.200 --> 00:27:16.580
only unfortunately there is no free tier,

653
00:27:16.580 --> 00:27:18.760
but then the price seems relatively low,

654
00:27:18.760 --> 00:27:20.840
so I don't think it's really a problem.

655
00:27:20.840 --> 00:27:23.340
So you basically pay for configuration updates,

656
00:27:23.340 --> 00:27:24.720
which is a very low charge.

657
00:27:24.720 --> 00:27:28.240
Like you will need to do 10,000 changes in a document

658
00:27:28.240 --> 00:27:30.140
to get charged $8,

659
00:27:30.140 --> 00:27:32.400
and I don't really see most applications

660
00:27:32.400 --> 00:27:36.040
doing 10,000 changes even in like 10 years, probably.

661
00:27:36.040 --> 00:27:38.800
So yeah, I think it's a very reasonable charge.

662
00:27:38.800 --> 00:27:41.380
So most of the time that cost should be neglectable,

663
00:27:41.380 --> 00:27:43.260
unless you really have huge applications

664
00:27:43.260 --> 00:27:44.620
that are changing all the time,

665
00:27:44.620 --> 00:27:46.840
because maybe they are extremely highly dynamic,

666
00:27:46.840 --> 00:27:48.320
integrating, I don't know,

667
00:27:48.320 --> 00:27:50.720
configuration for multiple sources.

668
00:27:50.720 --> 00:27:52.720
And then of course you pay per API call,

669
00:27:52.720 --> 00:27:55.440
so every time you fetch the configuration, there is a cost.

670
00:27:55.440 --> 00:27:57.400
It is relatively low, but again,

671
00:27:57.400 --> 00:27:59.380
worth doing some maths there,

672
00:27:59.380 --> 00:28:01.320
making sure that if you have thousands and thousands

673
00:28:01.320 --> 00:28:03.880
of services trying to read the same configuration,

674
00:28:03.880 --> 00:28:05.280
you have multiple environments,

675
00:28:05.280 --> 00:28:07.480
so that kind of multiplies even more.

676
00:28:07.480 --> 00:28:10.440
Of course, that low cost can easily compound

677
00:28:10.440 --> 00:28:12.720
and get to a point where it's not sustainable anymore.

678
00:28:12.720 --> 00:28:15.920
So always take our recommendation

679
00:28:15.920 --> 00:28:18.040
when it comes to prices with a pinch of salt,

680
00:28:18.040 --> 00:28:20.160
because every use case is very different,

681
00:28:20.160 --> 00:28:21.700
and you always need to do your own maths

682
00:28:21.700 --> 00:28:24.720
to make sure that service and that pricing model

683
00:28:24.720 --> 00:28:26.360
makes sense for your use case.

684
00:28:28.020 --> 00:28:30.780
Okay, Shu will talk now about the crazy idea

685
00:28:30.780 --> 00:28:33.280
that you don't like all the other services,

686
00:28:33.280 --> 00:28:34.680
and you are just feeling confident

687
00:28:34.680 --> 00:28:37.000
that you can build your own service,

688
00:28:37.000 --> 00:28:38.440
managing all this configuration.

689
00:28:41.220 --> 00:28:43.400
I think the main reason that anybody would be motivated to roll your own probably based on everything we've said

690
00:28:43.400 --> 00:28:46.000
is if the pricing or throughput constraints

691
00:28:46.000 --> 00:28:47.680
of any of the services we've mentioned

692
00:28:47.680 --> 00:28:49.720
don't really fit their access patterns.

693
00:28:49.720 --> 00:28:51.720
Seems like it would be simple to implement,

694
00:28:51.720 --> 00:28:53.560
but not necessarily so.

695
00:28:53.560 --> 00:28:55.560
You could do it, I've seen it

696
00:28:55.560 --> 00:28:57.960
and built systems like this in the past,

697
00:28:57.960 --> 00:29:01.660
and you can use services like S3 or DynamoDB,

698
00:29:01.660 --> 00:29:06.280
or ElastiCache or Redis or Memcache for this kind of thing.

699
00:29:06.280 --> 00:29:09.480
All depends on what kind of performance you need ultimately.

700
00:29:09.480 --> 00:29:12.480
Then it's up to you to define all the necessary conventions

701
00:29:12.480 --> 00:29:15.400
to manage the data consistently per app and per environment

702
00:29:15.400 --> 00:29:18.600
and ensure that the consistency is in place

703
00:29:18.600 --> 00:29:20.160
according to what you need as you replicate

704
00:29:20.160 --> 00:29:22.160
across multiple availability zones.

705
00:29:22.160 --> 00:29:23.880
You might need to add validation.

706
00:29:23.880 --> 00:29:26.600
You'd need to think about how to manage sensitive data

707
00:29:26.600 --> 00:29:29.600
in a secure way and maybe provide rotation support,

708
00:29:29.600 --> 00:29:31.800
and then defining an API to make it easier

709
00:29:31.800 --> 00:29:35.180
to fetch specific versions or a subset of the configuration.

710
00:29:35.180 --> 00:29:37.160
Then you need to think about controlling access

711
00:29:37.160 --> 00:29:38.580
to the configuration layer,

712
00:29:38.580 --> 00:29:42.180
your change log, keeping a history of changes for auditing.

713
00:29:42.180 --> 00:29:45.840
And if you do, probably in a regulated environment,

714
00:29:45.840 --> 00:29:47.600
you need to then think about getting compliance for that,

715
00:29:47.600 --> 00:29:50.100
which AWS have already taken care of.

716
00:29:50.100 --> 00:29:52.680
So for simple cases, it might work.

717
00:29:52.680 --> 00:29:55.280
You can imagine if you look at the SSM Parameter Store API

718
00:29:55.280 --> 00:29:56.120
and you don't like the cost,

719
00:29:56.120 --> 00:29:59.120
you could say, well, I can implement this with DynamoDB.

720
00:29:59.120 --> 00:30:03.480
I can easily do starts with secondary key match

721
00:30:03.480 --> 00:30:04.800
to retrieve the values,

722
00:30:04.800 --> 00:30:06.800
and I can pretty easily build an API

723
00:30:06.800 --> 00:30:09.360
that's compatible with the SSM Parameter Store API,

724
00:30:09.360 --> 00:30:11.000
but you have to think about all those other pieces

725
00:30:11.000 --> 00:30:13.340
and keeping it up to date, et cetera.

726
00:30:13.340 --> 00:30:15.480
Even though you might end up getting very good performance,

727
00:30:15.480 --> 00:30:18.020
throughput and cost with your custom built solution,

728
00:30:18.020 --> 00:30:19.960
you end up with another chunk of code

729
00:30:19.960 --> 00:30:22.360
that you probably don't really want to maintain

730
00:30:22.360 --> 00:30:25.800
once the novelty of building such a system has died down.

731
00:30:25.800 --> 00:30:28.080
For simple cases, if you have config files

732
00:30:28.080 --> 00:30:30.900
and you just want to store them in S3 or a DynamoDB table,

733
00:30:30.900 --> 00:30:32.480
there are solutions that help you there.

734
00:30:32.480 --> 00:30:34.320
Even we've mentioned Middy a few times

735
00:30:34.320 --> 00:30:36.300
and Middy offers a collection of middlewares

736
00:30:36.300 --> 00:30:38.880
that make it easy to prefetch and cache configuration

737
00:30:38.880 --> 00:30:40.320
that's stored in places like that.

738
00:30:40.320 --> 00:30:42.160
You can even do that with power tools as well.

739
00:30:42.160 --> 00:30:44.480
It's one for the people

740
00:30:44.480 --> 00:30:46.080
that like to build everything themselves, I guess,

741
00:30:46.080 --> 00:30:48.440
but best avoided otherwise.

742
00:30:48.440 --> 00:30:49.780
And I think that's our final one

743
00:30:49.780 --> 00:30:52.600
in this collection of options for storing configuration.

744
00:30:52.600 --> 00:30:54.600
Luciano, do you want to give people

745
00:30:54.600 --> 00:30:55.640
what we promised at the start,

746
00:30:55.640 --> 00:30:58.040
our recommendations for what approach to take?

747
00:30:59.800 --> 00:31:00.880
Yeah, I'll try to give a more, it's definitely opinionated,

748
00:31:00.880 --> 00:31:03.040
but hopefully sensible enough in terms of

749
00:31:03.040 --> 00:31:04.680
how do you approach even choosing

750
00:31:04.680 --> 00:31:07.040
between all these different options.

751
00:31:07.040 --> 00:31:09.600
I think starting simple is always a good recommendation.

752
00:31:09.600 --> 00:31:11.440
If you're building something small,

753
00:31:11.440 --> 00:31:13.320
maybe doing infrastructure as code,

754
00:31:13.320 --> 00:31:16.040
you don't really need to reference anything sensitive,

755
00:31:16.040 --> 00:31:17.560
but maybe you just want to reference, I don't know,

756
00:31:17.560 --> 00:31:21.440
DynamoDB table names, S3 packets names,

757
00:31:21.440 --> 00:31:23.140
that you are building the same stack,

758
00:31:23.140 --> 00:31:24.640
going with environment variables

759
00:31:24.640 --> 00:31:26.400
is going to be super simple,

760
00:31:26.400 --> 00:31:28.420
no problems in terms of security.

761
00:31:28.420 --> 00:31:30.500
Everything's populated by infrastructure as code,

762
00:31:30.500 --> 00:31:34.120
so even the risk of doing mistakes is very low.

763
00:31:34.120 --> 00:31:35.920
So why not doing that?

764
00:31:35.920 --> 00:31:38.200
It's something that you see a lot in every tutorial

765
00:31:38.200 --> 00:31:39.020
when you see, I don't know,

766
00:31:39.020 --> 00:31:43.280
how to get started with Lambda and API Gateway and DynamoDB,

767
00:31:43.280 --> 00:31:44.480
you will see something like that.

768
00:31:44.480 --> 00:31:46.100
So also a very common approach

769
00:31:46.100 --> 00:31:48.200
and worth using it for the simplest cases.

770
00:31:48.200 --> 00:31:50.560
You can switch to SSM and Secrets Managerr

771
00:31:50.560 --> 00:31:53.120
as soon as you start to have more advanced use cases,

772
00:31:53.120 --> 00:31:56.840
where maybe you need to manage a bit more configuration

773
00:31:56.840 --> 00:31:58.660
and you want to define your own structure,

774
00:31:58.660 --> 00:32:00.740
or maybe when you need to start managing secrets

775
00:32:00.740 --> 00:32:03.160
and you need to manage all the life cycle

776
00:32:03.160 --> 00:32:04.480
of those secrets correctly,

777
00:32:04.480 --> 00:32:08.040
make sure that they are stored correctly, rotated correctly,

778
00:32:08.040 --> 00:32:12.360
and you have control on who gets to access those secrets.

779
00:32:12.360 --> 00:32:14.120
But of course, when you get to work

780
00:32:14.120 --> 00:32:16.020
on more complex applications

781
00:32:16.020 --> 00:32:19.640
and you want to really have a fine-tuned life cycle

782
00:32:19.640 --> 00:32:20.640
for all the configuration,

783
00:32:20.640 --> 00:32:22.780
I think App Config is really the service

784
00:32:22.780 --> 00:32:24.020
that you want to use.

785
00:32:24.020 --> 00:32:25.280
It is relatively new,

786
00:32:25.280 --> 00:32:28.120
so no surprise that tries to fill all the gaps

787
00:32:28.120 --> 00:32:29.860
of the previous services,

788
00:32:29.860 --> 00:32:32.020
but it seems to give you really an entire life cycle,

789
00:32:32.020 --> 00:32:34.360
so you can have, I guess, a better experience

790
00:32:34.360 --> 00:32:37.480
and you don't really need to build anything

791
00:32:37.480 --> 00:32:39.240
to fill the gaps yourself.

792
00:32:39.240 --> 00:32:40.580
Now, finally, we would, of course,

793
00:32:40.580 --> 00:32:42.400
discourage the custom build solution,

794
00:32:42.400 --> 00:32:44.000
unless you really have good reasons,

795
00:32:44.000 --> 00:32:45.160
and good reasons, as we said,

796
00:32:45.160 --> 00:32:47.280
it might be cost or performance,

797
00:32:47.280 --> 00:32:49.400
because you might have really bespoke use cases

798
00:32:49.400 --> 00:32:51.080
where going with the other services

799
00:32:51.080 --> 00:32:52.720
would be either too expensive,

800
00:32:52.720 --> 00:32:53.880
or maybe you need a throughput

801
00:32:53.880 --> 00:32:57.080
that is not really friendly enough.

802
00:32:57.080 --> 00:32:59.800
Either you cannot do it because there are service quotas

803
00:32:59.800 --> 00:33:01.640
or because it gets too expensive again, right?

804
00:33:01.640 --> 00:33:04.440
So considering cost and throughput together,

805
00:33:04.440 --> 00:33:05.920
you might want to build something yourself

806
00:33:05.920 --> 00:33:08.620
that might be, I guess, reasonable at that point.

807
00:33:08.620 --> 00:33:10.120
Or maybe another use case for this

808
00:33:10.120 --> 00:33:11.640
is when you are doing a migration

809
00:33:11.640 --> 00:33:14.080
and you already have a very bespoke mechanism

810
00:33:14.080 --> 00:33:17.040
to manage all the configuration for your application,

811
00:33:17.040 --> 00:33:19.800
and you don't really want to start to change all of that

812
00:33:19.800 --> 00:33:21.580
as a first step in your migration,

813
00:33:21.580 --> 00:33:24.500
maybe that's a place where it might make sense

814
00:33:24.500 --> 00:33:25.960
to do something a little bit custom

815
00:33:25.960 --> 00:33:27.960
as you continue through your migration.

816
00:33:27.960 --> 00:33:30.080
But I suppose you still eventually want to migrate

817
00:33:30.080 --> 00:33:32.600
to something more structured like App Config,

818
00:33:32.600 --> 00:33:35.080
just so that you can clean up all this custom code

819
00:33:35.080 --> 00:33:37.400
and keep your application a little bit more focused

820
00:33:37.400 --> 00:33:38.760
on what is the business value

821
00:33:38.760 --> 00:33:41.320
that it's providing for your company.

822
00:33:41.320 --> 00:33:44.680
And I think that's our generic recommendation.

823
00:33:44.680 --> 00:33:46.280
Let us know if you agree with it

824
00:33:46.280 --> 00:33:48.960
and which kind of services have you used already,

825
00:33:48.960 --> 00:33:50.820
and if you have, I guess, a similar experience

826
00:33:50.820 --> 00:33:53.400
and perspective on all of those.

827
00:33:53.400 --> 00:33:55.080
Well, to wrap up, I'm going to point people

828
00:33:55.080 --> 00:33:56.960
to a few resources that we've found,

829
00:33:56.960 --> 00:34:00.880
and Be a Better Dev has some great videos with deep dives

830
00:34:00.880 --> 00:34:03.880
and demos on all of the options here.

831
00:34:03.880 --> 00:34:05.360
Those links will be in the show notes.

832
00:34:05.360 --> 00:34:08.360
Everything we mentioned with Middy and power tools,

833
00:34:08.360 --> 00:34:10.360
everything else, all the other articles we mentioned

834
00:34:10.360 --> 00:34:11.600
are also in the show notes.

835
00:34:11.600 --> 00:34:13.200
So once again, thank you very much for joining us

836
00:34:13.200 --> 00:34:14.440
and listening, we really appreciate it,

837
00:34:14.440 --> 00:34:17.120
and we'll see you in the next episode of AWS Bites.
